!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(require("react"),require("prop-types")):"function"==typeof define&&define.amd?define(["react","prop-types"],n):"object"==typeof exports?exports.index=n(require("react"),require("prop-types")):(e["deriv-p2p"]=e["deriv-p2p"]||{},e["deriv-p2p"].index=n(e.react,e["prop-types"]))}(window,(function(__WEBPACK_EXTERNAL_MODULE__0__,__WEBPACK_EXTERNAL_MODULE__16__){return function(e){var n={};function t(c){if(n[c])return n[c].exports;var l=n[c]={i:c,l:!1,exports:{}};return e[c].call(l.exports,l,l.exports,t),l.l=!0,l.exports}return t.m=e,t.c=n,t.d=function(e,n,c){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:c})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var c=Object.create(null);if(t.r(c),Object.defineProperty(c,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var l in e)t.d(c,l,function(n){return e[n]}.bind(null,l));return c},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=17)}([function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE__0__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlcml2LXAycC5bbmFtZV0vZXh0ZXJuYWwgXCJyZWFjdFwiPzU4OGUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18wX187Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){eval('!function(e){ true?module.exports=e(null):undefined}(function e(a){"use strict";var r=/^\\0+/g,c=/[\\0\\r\\f]/g,s=/: */g,t=/zoo|gra/,i=/([,: ])(transform)/g,f=/,+\\s*(?![^(]*[)])/g,n=/ +\\s*(?![^(]*[)])/g,l=/ *[\\0] */g,o=/,\\r+?/g,h=/([\\t\\r\\n ])*\\f?&/g,u=/:global\\(((?:[^\\(\\)\\[\\]]*|\\[.*\\]|\\([^\\(\\)]*\\))*)\\)/g,d=/\\W+/g,b=/@(k\\w+)\\s*(\\S*)\\s*/,p=/::(place)/g,k=/:(read-only)/g,g=/\\s+(?=[{\\];=:>])/g,A=/([[}=:>])\\s+/g,C=/(\\{[^{]+?);(?=\\})/g,w=/\\s{2,}/g,v=/([^\\(])(:+) */g,m=/[svh]\\w+-[tblr]{2}/,x=/\\(\\s*(.*)\\s*\\)/g,$=/([\\s\\S]*?);/g,y=/-self|flex-/g,O=/[^]*?(:[rp][el]a[\\w-]+)[^]*/,j=/stretch|:\\s*\\w+\\-(?:conte|avail)/,z=/([^-])(image-set\\()/,N="-webkit-",S="-moz-",F="-ms-",W=59,q=125,B=123,D=40,E=41,G=91,H=93,I=10,J=13,K=9,L=64,M=32,P=38,Q=45,R=95,T=42,U=44,V=58,X=39,Y=34,Z=47,_=62,ee=43,ae=126,re=0,ce=12,se=11,te=107,ie=109,fe=115,ne=112,le=111,oe=105,he=99,ue=100,de=112,be=1,pe=1,ke=0,ge=1,Ae=1,Ce=1,we=0,ve=0,me=0,xe=[],$e=[],ye=0,Oe=null,je=-2,ze=-1,Ne=0,Se=1,Fe=2,We=3,qe=0,Be=1,De="",Ee="",Ge="";function He(e,a,s,t,i){for(var f,n,o=0,h=0,u=0,d=0,g=0,A=0,C=0,w=0,m=0,$=0,y=0,O=0,j=0,z=0,R=0,we=0,$e=0,Oe=0,je=0,ze=s.length,Je=ze-1,Re="",Te="",Ue="",Ve="",Xe="",Ye="";R<ze;){if(C=s.charCodeAt(R),R===Je)if(h+d+u+o!==0){if(0!==h)C=h===Z?I:Z;d=u=o=0,ze++,Je++}if(h+d+u+o===0){if(R===Je){if(we>0)Te=Te.replace(c,"");if(Te.trim().length>0){switch(C){case M:case K:case W:case J:case I:break;default:Te+=s.charAt(R)}C=W}}if(1===$e)switch(C){case B:case q:case W:case Y:case X:case D:case E:case U:$e=0;case K:case J:case I:case M:break;default:for($e=0,je=R,g=C,R--,C=W;je<ze;)switch(s.charCodeAt(je++)){case I:case J:case W:++R,C=g,je=ze;break;case V:if(we>0)++R,C=g;case B:je=ze}}switch(C){case B:for(g=(Te=Te.trim()).charCodeAt(0),y=1,je=++R;R<ze;){switch(C=s.charCodeAt(R)){case B:y++;break;case q:y--;break;case Z:switch(A=s.charCodeAt(R+1)){case T:case Z:R=Qe(A,R,Je,s)}break;case G:C++;case D:C++;case Y:case X:for(;R++<Je&&s.charCodeAt(R)!==C;);}if(0===y)break;R++}if(Ue=s.substring(je,R),g===re)g=(Te=Te.replace(r,"").trim()).charCodeAt(0);switch(g){case L:if(we>0)Te=Te.replace(c,"");switch(A=Te.charCodeAt(1)){case ue:case ie:case fe:case Q:f=a;break;default:f=xe}if(je=(Ue=He(a,f,Ue,A,i+1)).length,me>0&&0===je)je=Te.length;if(ye>0)if(f=Ie(xe,Te,Oe),n=Pe(We,Ue,f,a,pe,be,je,A,i,t),Te=f.join(""),void 0!==n)if(0===(je=(Ue=n.trim()).length))A=0,Ue="";if(je>0)switch(A){case fe:Te=Te.replace(x,Me);case ue:case ie:case Q:Ue=Te+"{"+Ue+"}";break;case te:if(Ue=(Te=Te.replace(b,"$1 $2"+(Be>0?De:"")))+"{"+Ue+"}",1===Ae||2===Ae&&Le("@"+Ue,3))Ue="@"+N+Ue+"@"+Ue;else Ue="@"+Ue;break;default:if(Ue=Te+Ue,t===de)Ve+=Ue,Ue=""}else Ue="";break;default:Ue=He(a,Ie(a,Te,Oe),Ue,t,i+1)}Xe+=Ue,O=0,$e=0,z=0,we=0,Oe=0,j=0,Te="",Ue="",C=s.charCodeAt(++R);break;case q:case W:if((je=(Te=(we>0?Te.replace(c,""):Te).trim()).length)>1){if(0===z)if((g=Te.charCodeAt(0))===Q||g>96&&g<123)je=(Te=Te.replace(" ",":")).length;if(ye>0)if(void 0!==(n=Pe(Se,Te,a,e,pe,be,Ve.length,t,i,t)))if(0===(je=(Te=n.trim()).length))Te="\\0\\0";switch(g=Te.charCodeAt(0),A=Te.charCodeAt(1),g){case re:break;case L:if(A===oe||A===he){Ye+=Te+s.charAt(R);break}default:if(Te.charCodeAt(je-1)===V)break;Ve+=Ke(Te,g,A,Te.charCodeAt(2))}}O=0,$e=0,z=0,we=0,Oe=0,Te="",C=s.charCodeAt(++R)}}switch(C){case J:case I:if(h+d+u+o+ve===0)switch($){case E:case X:case Y:case L:case ae:case _:case T:case ee:case Z:case Q:case V:case U:case W:case B:case q:break;default:if(z>0)$e=1}if(h===Z)h=0;else if(ge+O===0&&t!==te&&Te.length>0)we=1,Te+="\\0";if(ye*qe>0)Pe(Ne,Te,a,e,pe,be,Ve.length,t,i,t);be=1,pe++;break;case W:case q:if(h+d+u+o===0){be++;break}default:switch(be++,Re=s.charAt(R),C){case K:case M:if(d+o+h===0)switch(w){case U:case V:case K:case M:Re="";break;default:if(C!==M)Re=" "}break;case re:Re="\\\\0";break;case ce:Re="\\\\f";break;case se:Re="\\\\v";break;case P:if(d+h+o===0&&ge>0)Oe=1,we=1,Re="\\f"+Re;break;case 108:if(d+h+o+ke===0&&z>0)switch(R-z){case 2:if(w===ne&&s.charCodeAt(R-3)===V)ke=w;case 8:if(m===le)ke=m}break;case V:if(d+h+o===0)z=R;break;case U:if(h+u+d+o===0)we=1,Re+="\\r";break;case Y:case X:if(0===h)d=d===C?0:0===d?C:d;break;case G:if(d+h+u===0)o++;break;case H:if(d+h+u===0)o--;break;case E:if(d+h+o===0)u--;break;case D:if(d+h+o===0){if(0===O)switch(2*w+3*m){case 533:break;default:y=0,O=1}u++}break;case L:if(h+u+d+o+z+j===0)j=1;break;case T:case Z:if(d+o+u>0)break;switch(h){case 0:switch(2*C+3*s.charCodeAt(R+1)){case 235:h=Z;break;case 220:je=R,h=T}break;case T:if(C===Z&&w===T&&je+2!==R){if(33===s.charCodeAt(je+2))Ve+=s.substring(je,R+1);Re="",h=0}}}if(0===h){if(ge+d+o+j===0&&t!==te&&C!==W)switch(C){case U:case ae:case _:case ee:case E:case D:if(0===O){switch(w){case K:case M:case I:case J:Re+="\\0";break;default:Re="\\0"+Re+(C===U?"":"\\0")}we=1}else switch(C){case D:if(z+7===R&&108===w)z=0;O=++y;break;case E:if(0==(O=--y))we=1,Re+="\\0"}break;case K:case M:switch(w){case re:case B:case q:case W:case U:case ce:case K:case M:case I:case J:break;default:if(0===O)we=1,Re+="\\0"}}if(Te+=Re,C!==M&&C!==K)$=C}}m=w,w=C,R++}if(je=Ve.length,me>0)if(0===je&&0===Xe.length&&0===a[0].length==false)if(t!==ie||1===a.length&&(ge>0?Ee:Ge)===a[0])je=a.join(",").length+2;if(je>0){if(f=0===ge&&t!==te?function(e){for(var a,r,s=0,t=e.length,i=Array(t);s<t;++s){for(var f=e[s].split(l),n="",o=0,h=0,u=0,d=0,b=f.length;o<b;++o){if(0===(h=(r=f[o]).length)&&b>1)continue;if(u=n.charCodeAt(n.length-1),d=r.charCodeAt(0),a="",0!==o)switch(u){case T:case ae:case _:case ee:case M:case D:break;default:a=" "}switch(d){case P:r=a+Ee;case ae:case _:case ee:case M:case E:case D:break;case G:r=a+r+Ee;break;case V:switch(2*r.charCodeAt(1)+3*r.charCodeAt(2)){case 530:if(Ce>0){r=a+r.substring(8,h-1);break}default:if(o<1||f[o-1].length<1)r=a+Ee+r}break;case U:a="";default:if(h>1&&r.indexOf(":")>0)r=a+r.replace(v,"$1"+Ee+"$2");else r=a+r+Ee}n+=r}i[s]=n.replace(c,"").trim()}return i}(a):a,ye>0)if(void 0!==(n=Pe(Fe,Ve,f,e,pe,be,je,t,i,t))&&0===(Ve=n).length)return Ye+Ve+Xe;if(Ve=f.join(",")+"{"+Ve+"}",Ae*ke!=0){if(2===Ae&&!Le(Ve,2))ke=0;switch(ke){case le:Ve=Ve.replace(k,":"+S+"$1")+Ve;break;case ne:Ve=Ve.replace(p,"::"+N+"input-$1")+Ve.replace(p,"::"+S+"$1")+Ve.replace(p,":"+F+"input-$1")+Ve}ke=0}}return Ye+Ve+Xe}function Ie(e,a,r){var c=a.trim().split(o),s=c,t=c.length,i=e.length;switch(i){case 0:case 1:for(var f=0,n=0===i?"":e[0]+" ";f<t;++f)s[f]=Je(n,s[f],r,i).trim();break;default:f=0;var l=0;for(s=[];f<t;++f)for(var h=0;h<i;++h)s[l++]=Je(e[h]+" ",c[f],r,i).trim()}return s}function Je(e,a,r,c){var s=a,t=s.charCodeAt(0);if(t<33)t=(s=s.trim()).charCodeAt(0);switch(t){case P:switch(ge+c){case 0:case 1:if(0===e.trim().length)break;default:return s.replace(h,"$1"+e.trim())}break;case V:switch(s.charCodeAt(1)){case 103:if(Ce>0&&ge>0)return s.replace(u,"$1").replace(h,"$1"+Ge);break;default:return e.trim()+s.replace(h,"$1"+e.trim())}default:if(r*ge>0&&s.indexOf("\\f")>0)return s.replace(h,(e.charCodeAt(0)===V?"":"$1")+e.trim())}return e+s}function Ke(e,a,r,c){var l,o=0,h=e+";",u=2*a+3*r+4*c;if(944===u)return function(e){var a=e.length,r=e.indexOf(":",9)+1,c=e.substring(0,r).trim(),s=e.substring(r,a-1).trim();switch(e.charCodeAt(9)*Be){case 0:break;case Q:if(110!==e.charCodeAt(10))break;default:for(var t=s.split((s="",f)),i=0,r=0,a=t.length;i<a;r=0,++i){for(var l=t[i],o=l.split(n);l=o[r];){var h=l.charCodeAt(0);if(1===Be&&(h>L&&h<90||h>96&&h<123||h===R||h===Q&&l.charCodeAt(1)!==Q))switch(isNaN(parseFloat(l))+(-1!==l.indexOf("("))){case 1:switch(l){case"infinite":case"alternate":case"backwards":case"running":case"normal":case"forwards":case"both":case"none":case"linear":case"ease":case"ease-in":case"ease-out":case"ease-in-out":case"paused":case"reverse":case"alternate-reverse":case"inherit":case"initial":case"unset":case"step-start":case"step-end":break;default:l+=De}}o[r++]=l}s+=(0===i?"":",")+o.join(" ")}}if(s=c+s+";",1===Ae||2===Ae&&Le(s,1))return N+s+s;return s}(h);else if(0===Ae||2===Ae&&!Le(h,1))return h;switch(u){case 1015:return 97===h.charCodeAt(10)?N+h+h:h;case 951:return 116===h.charCodeAt(3)?N+h+h:h;case 963:return 110===h.charCodeAt(5)?N+h+h:h;case 1009:if(100!==h.charCodeAt(4))break;case 969:case 942:return N+h+h;case 978:return N+h+S+h+h;case 1019:case 983:return N+h+S+h+F+h+h;case 883:if(h.charCodeAt(8)===Q)return N+h+h;if(h.indexOf("image-set(",11)>0)return h.replace(z,"$1"+N+"$2")+h;return h;case 932:if(h.charCodeAt(4)===Q)switch(h.charCodeAt(5)){case 103:return N+"box-"+h.replace("-grow","")+N+h+F+h.replace("grow","positive")+h;case 115:return N+h+F+h.replace("shrink","negative")+h;case 98:return N+h+F+h.replace("basis","preferred-size")+h}return N+h+F+h+h;case 964:return N+h+F+"flex-"+h+h;case 1023:if(99!==h.charCodeAt(8))break;return l=h.substring(h.indexOf(":",15)).replace("flex-","").replace("space-between","justify"),N+"box-pack"+l+N+h+F+"flex-pack"+l+h;case 1005:return t.test(h)?h.replace(s,":"+N)+h.replace(s,":"+S)+h:h;case 1e3:switch(o=(l=h.substring(13).trim()).indexOf("-")+1,l.charCodeAt(0)+l.charCodeAt(o)){case 226:l=h.replace(m,"tb");break;case 232:l=h.replace(m,"tb-rl");break;case 220:l=h.replace(m,"lr");break;default:return h}return N+h+F+l+h;case 1017:if(-1===h.indexOf("sticky",9))return h;case 975:switch(o=(h=e).length-10,u=(l=(33===h.charCodeAt(o)?h.substring(0,o):h).substring(e.indexOf(":",7)+1).trim()).charCodeAt(0)+(0|l.charCodeAt(7))){case 203:if(l.charCodeAt(8)<111)break;case 115:h=h.replace(l,N+l)+";"+h;break;case 207:case 102:h=h.replace(l,N+(u>102?"inline-":"")+"box")+";"+h.replace(l,N+l)+";"+h.replace(l,F+l+"box")+";"+h}return h+";";case 938:if(h.charCodeAt(5)===Q)switch(h.charCodeAt(6)){case 105:return l=h.replace("-items",""),N+h+N+"box-"+l+F+"flex-"+l+h;case 115:return N+h+F+"flex-item-"+h.replace(y,"")+h;default:return N+h+F+"flex-line-pack"+h.replace("align-content","").replace(y,"")+h}break;case 973:case 989:if(h.charCodeAt(3)!==Q||122===h.charCodeAt(4))break;case 931:case 953:if(true===j.test(e))if(115===(l=e.substring(e.indexOf(":")+1)).charCodeAt(0))return Ke(e.replace("stretch","fill-available"),a,r,c).replace(":fill-available",":stretch");else return h.replace(l,N+l)+h.replace(l,S+l.replace("fill-",""))+h;break;case 962:if(h=N+h+(102===h.charCodeAt(5)?F+h:"")+h,r+c===211&&105===h.charCodeAt(13)&&h.indexOf("transform",10)>0)return h.substring(0,h.indexOf(";",27)+1).replace(i,"$1"+N+"$2")+h}return h}function Le(e,a){var r=e.indexOf(1===a?":":"{"),c=e.substring(0,3!==a?r:10),s=e.substring(r+1,e.length-1);return Oe(2!==a?c:c.replace(O,"$1"),s,a)}function Me(e,a){var r=Ke(a,a.charCodeAt(0),a.charCodeAt(1),a.charCodeAt(2));return r!==a+";"?r.replace($," or ($1)").substring(4):"("+a+")"}function Pe(e,a,r,c,s,t,i,f,n,l){for(var o,h=0,u=a;h<ye;++h)switch(o=$e[h].call(Te,e,u,r,c,s,t,i,f,n,l)){case void 0:case false:case true:case null:break;default:u=o}if(u!==a)return u}function Qe(e,a,r,c){for(var s=a+1;s<r;++s)switch(c.charCodeAt(s)){case Z:if(e===T)if(c.charCodeAt(s-1)===T&&a+2!==s)return s+1;break;case I:if(e===Z)return s+1}return s}function Re(e){for(var a in e){var r=e[a];switch(a){case"keyframe":Be=0|r;break;case"global":Ce=0|r;break;case"cascade":ge=0|r;break;case"compress":we=0|r;break;case"semicolon":ve=0|r;break;case"preserve":me=0|r;break;case"prefix":if(Oe=null,!r)Ae=0;else if("function"!=typeof r)Ae=1;else Ae=2,Oe=r}}return Re}function Te(a,r){if(void 0!==this&&this.constructor===Te)return e(a);var s=a,t=s.charCodeAt(0);if(t<33)t=(s=s.trim()).charCodeAt(0);if(Be>0)De=s.replace(d,t===G?"":"-");if(t=1,1===ge)Ge=s;else Ee=s;var i,f=[Ge];if(ye>0)if(void 0!==(i=Pe(ze,r,f,f,pe,be,0,0,0,0))&&"string"==typeof i)r=i;var n=He(xe,f,r,0,0);if(ye>0)if(void 0!==(i=Pe(je,n,f,f,pe,be,n.length,0,0,0))&&"string"!=typeof(n=i))t=0;return De="",Ge="",Ee="",ke=0,pe=1,be=1,we*t==0?n:n.replace(c,"").replace(g,"").replace(A,"$1").replace(C,"$1").replace(w," ")}if(Te.use=function e(a){switch(a){case void 0:case null:ye=$e.length=0;break;default:if("function"==typeof a)$e[ye++]=a;else if("object"==typeof a)for(var r=0,c=a.length;r<c;++r)e(a[r]);else qe=0|!!a}return e},Te.set=Re,void 0!==a)Re(a);return Te});\n//# sourceMappingURL=stylis.min.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlcml2LXAycC5bbmFtZV0vLi9ub2RlX21vZHVsZXMvc3R5bGlzL3N0eWxpcy5taW4uanM/Njg5OCJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZShudWxsKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGUobnVsbCkpOndpbmRvdy5zdHlsaXM9ZShudWxsKX0oZnVuY3Rpb24gZShhKXtcInVzZSBzdHJpY3RcIjt2YXIgcj0vXlxcMCsvZyxjPS9bXFwwXFxyXFxmXS9nLHM9LzogKi9nLHQ9L3pvb3xncmEvLGk9LyhbLDogXSkodHJhbnNmb3JtKS9nLGY9LywrXFxzKig/IVteKF0qWyldKS9nLG49LyArXFxzKig/IVteKF0qWyldKS9nLGw9LyAqW1xcMF0gKi9nLG89LyxcXHIrPy9nLGg9LyhbXFx0XFxyXFxuIF0pKlxcZj8mL2csdT0vOmdsb2JhbFxcKCgoPzpbXlxcKFxcKVxcW1xcXV0qfFxcWy4qXFxdfFxcKFteXFwoXFwpXSpcXCkpKilcXCkvZyxkPS9cXFcrL2csYj0vQChrXFx3KylcXHMqKFxcUyopXFxzKi8scD0vOjoocGxhY2UpL2csaz0vOihyZWFkLW9ubHkpL2csZz0vXFxzKyg/PVt7XFxdOz06Pl0pL2csQT0vKFtbfT06Pl0pXFxzKy9nLEM9LyhcXHtbXntdKz8pOyg/PVxcfSkvZyx3PS9cXHN7Mix9L2csdj0vKFteXFwoXSkoOispICovZyxtPS9bc3ZoXVxcdystW3RibHJdezJ9Lyx4PS9cXChcXHMqKC4qKVxccypcXCkvZywkPS8oW1xcc1xcU10qPyk7L2cseT0vLXNlbGZ8ZmxleC0vZyxPPS9bXl0qPyg6W3JwXVtlbF1hW1xcdy1dKylbXl0qLyxqPS9zdHJldGNofDpcXHMqXFx3K1xcLSg/OmNvbnRlfGF2YWlsKS8sej0vKFteLV0pKGltYWdlLXNldFxcKCkvLE49XCItd2Via2l0LVwiLFM9XCItbW96LVwiLEY9XCItbXMtXCIsVz01OSxxPTEyNSxCPTEyMyxEPTQwLEU9NDEsRz05MSxIPTkzLEk9MTAsSj0xMyxLPTksTD02NCxNPTMyLFA9MzgsUT00NSxSPTk1LFQ9NDIsVT00NCxWPTU4LFg9MzksWT0zNCxaPTQ3LF89NjIsZWU9NDMsYWU9MTI2LHJlPTAsY2U9MTIsc2U9MTEsdGU9MTA3LGllPTEwOSxmZT0xMTUsbmU9MTEyLGxlPTExMSxvZT0xMDUsaGU9OTksdWU9MTAwLGRlPTExMixiZT0xLHBlPTEsa2U9MCxnZT0xLEFlPTEsQ2U9MSx3ZT0wLHZlPTAsbWU9MCx4ZT1bXSwkZT1bXSx5ZT0wLE9lPW51bGwsamU9LTIsemU9LTEsTmU9MCxTZT0xLEZlPTIsV2U9MyxxZT0wLEJlPTEsRGU9XCJcIixFZT1cIlwiLEdlPVwiXCI7ZnVuY3Rpb24gSGUoZSxhLHMsdCxpKXtmb3IodmFyIGYsbixvPTAsaD0wLHU9MCxkPTAsZz0wLEE9MCxDPTAsdz0wLG09MCwkPTAseT0wLE89MCxqPTAsej0wLFI9MCx3ZT0wLCRlPTAsT2U9MCxqZT0wLHplPXMubGVuZ3RoLEplPXplLTEsUmU9XCJcIixUZT1cIlwiLFVlPVwiXCIsVmU9XCJcIixYZT1cIlwiLFllPVwiXCI7Ujx6ZTspe2lmKEM9cy5jaGFyQ29kZUF0KFIpLFI9PT1KZSlpZihoK2QrdStvIT09MCl7aWYoMCE9PWgpQz1oPT09Wj9JOlo7ZD11PW89MCx6ZSsrLEplKyt9aWYoaCtkK3Urbz09PTApe2lmKFI9PT1KZSl7aWYod2U+MClUZT1UZS5yZXBsYWNlKGMsXCJcIik7aWYoVGUudHJpbSgpLmxlbmd0aD4wKXtzd2l0Y2goQyl7Y2FzZSBNOmNhc2UgSzpjYXNlIFc6Y2FzZSBKOmNhc2UgSTpicmVhaztkZWZhdWx0OlRlKz1zLmNoYXJBdChSKX1DPVd9fWlmKDE9PT0kZSlzd2l0Y2goQyl7Y2FzZSBCOmNhc2UgcTpjYXNlIFc6Y2FzZSBZOmNhc2UgWDpjYXNlIEQ6Y2FzZSBFOmNhc2UgVTokZT0wO2Nhc2UgSzpjYXNlIEo6Y2FzZSBJOmNhc2UgTTpicmVhaztkZWZhdWx0OmZvcigkZT0wLGplPVIsZz1DLFItLSxDPVc7amU8emU7KXN3aXRjaChzLmNoYXJDb2RlQXQoamUrKykpe2Nhc2UgSTpjYXNlIEo6Y2FzZSBXOisrUixDPWcsamU9emU7YnJlYWs7Y2FzZSBWOmlmKHdlPjApKytSLEM9ZztjYXNlIEI6amU9emV9fXN3aXRjaChDKXtjYXNlIEI6Zm9yKGc9KFRlPVRlLnRyaW0oKSkuY2hhckNvZGVBdCgwKSx5PTEsamU9KytSO1I8emU7KXtzd2l0Y2goQz1zLmNoYXJDb2RlQXQoUikpe2Nhc2UgQjp5Kys7YnJlYWs7Y2FzZSBxOnktLTticmVhaztjYXNlIFo6c3dpdGNoKEE9cy5jaGFyQ29kZUF0KFIrMSkpe2Nhc2UgVDpjYXNlIFo6Uj1RZShBLFIsSmUscyl9YnJlYWs7Y2FzZSBHOkMrKztjYXNlIEQ6QysrO2Nhc2UgWTpjYXNlIFg6Zm9yKDtSKys8SmUmJnMuY2hhckNvZGVBdChSKSE9PUM7KTt9aWYoMD09PXkpYnJlYWs7UisrfWlmKFVlPXMuc3Vic3RyaW5nKGplLFIpLGc9PT1yZSlnPShUZT1UZS5yZXBsYWNlKHIsXCJcIikudHJpbSgpKS5jaGFyQ29kZUF0KDApO3N3aXRjaChnKXtjYXNlIEw6aWYod2U+MClUZT1UZS5yZXBsYWNlKGMsXCJcIik7c3dpdGNoKEE9VGUuY2hhckNvZGVBdCgxKSl7Y2FzZSB1ZTpjYXNlIGllOmNhc2UgZmU6Y2FzZSBROmY9YTticmVhaztkZWZhdWx0OmY9eGV9aWYoamU9KFVlPUhlKGEsZixVZSxBLGkrMSkpLmxlbmd0aCxtZT4wJiYwPT09amUpamU9VGUubGVuZ3RoO2lmKHllPjApaWYoZj1JZSh4ZSxUZSxPZSksbj1QZShXZSxVZSxmLGEscGUsYmUsamUsQSxpLHQpLFRlPWYuam9pbihcIlwiKSx2b2lkIDAhPT1uKWlmKDA9PT0oamU9KFVlPW4udHJpbSgpKS5sZW5ndGgpKUE9MCxVZT1cIlwiO2lmKGplPjApc3dpdGNoKEEpe2Nhc2UgZmU6VGU9VGUucmVwbGFjZSh4LE1lKTtjYXNlIHVlOmNhc2UgaWU6Y2FzZSBROlVlPVRlK1wie1wiK1VlK1wifVwiO2JyZWFrO2Nhc2UgdGU6aWYoVWU9KFRlPVRlLnJlcGxhY2UoYixcIiQxICQyXCIrKEJlPjA/RGU6XCJcIikpKStcIntcIitVZStcIn1cIiwxPT09QWV8fDI9PT1BZSYmTGUoXCJAXCIrVWUsMykpVWU9XCJAXCIrTitVZStcIkBcIitVZTtlbHNlIFVlPVwiQFwiK1VlO2JyZWFrO2RlZmF1bHQ6aWYoVWU9VGUrVWUsdD09PWRlKVZlKz1VZSxVZT1cIlwifWVsc2UgVWU9XCJcIjticmVhaztkZWZhdWx0OlVlPUhlKGEsSWUoYSxUZSxPZSksVWUsdCxpKzEpfVhlKz1VZSxPPTAsJGU9MCx6PTAsd2U9MCxPZT0wLGo9MCxUZT1cIlwiLFVlPVwiXCIsQz1zLmNoYXJDb2RlQXQoKytSKTticmVhaztjYXNlIHE6Y2FzZSBXOmlmKChqZT0oVGU9KHdlPjA/VGUucmVwbGFjZShjLFwiXCIpOlRlKS50cmltKCkpLmxlbmd0aCk+MSl7aWYoMD09PXopaWYoKGc9VGUuY2hhckNvZGVBdCgwKSk9PT1RfHxnPjk2JiZnPDEyMylqZT0oVGU9VGUucmVwbGFjZShcIiBcIixcIjpcIikpLmxlbmd0aDtpZih5ZT4wKWlmKHZvaWQgMCE9PShuPVBlKFNlLFRlLGEsZSxwZSxiZSxWZS5sZW5ndGgsdCxpLHQpKSlpZigwPT09KGplPShUZT1uLnRyaW0oKSkubGVuZ3RoKSlUZT1cIlxcMFxcMFwiO3N3aXRjaChnPVRlLmNoYXJDb2RlQXQoMCksQT1UZS5jaGFyQ29kZUF0KDEpLGcpe2Nhc2UgcmU6YnJlYWs7Y2FzZSBMOmlmKEE9PT1vZXx8QT09PWhlKXtZZSs9VGUrcy5jaGFyQXQoUik7YnJlYWt9ZGVmYXVsdDppZihUZS5jaGFyQ29kZUF0KGplLTEpPT09VilicmVhaztWZSs9S2UoVGUsZyxBLFRlLmNoYXJDb2RlQXQoMikpfX1PPTAsJGU9MCx6PTAsd2U9MCxPZT0wLFRlPVwiXCIsQz1zLmNoYXJDb2RlQXQoKytSKX19c3dpdGNoKEMpe2Nhc2UgSjpjYXNlIEk6aWYoaCtkK3Urbyt2ZT09PTApc3dpdGNoKCQpe2Nhc2UgRTpjYXNlIFg6Y2FzZSBZOmNhc2UgTDpjYXNlIGFlOmNhc2UgXzpjYXNlIFQ6Y2FzZSBlZTpjYXNlIFo6Y2FzZSBROmNhc2UgVjpjYXNlIFU6Y2FzZSBXOmNhc2UgQjpjYXNlIHE6YnJlYWs7ZGVmYXVsdDppZih6PjApJGU9MX1pZihoPT09WiloPTA7ZWxzZSBpZihnZStPPT09MCYmdCE9PXRlJiZUZS5sZW5ndGg+MCl3ZT0xLFRlKz1cIlxcMFwiO2lmKHllKnFlPjApUGUoTmUsVGUsYSxlLHBlLGJlLFZlLmxlbmd0aCx0LGksdCk7YmU9MSxwZSsrO2JyZWFrO2Nhc2UgVzpjYXNlIHE6aWYoaCtkK3Urbz09PTApe2JlKys7YnJlYWt9ZGVmYXVsdDpzd2l0Y2goYmUrKyxSZT1zLmNoYXJBdChSKSxDKXtjYXNlIEs6Y2FzZSBNOmlmKGQrbytoPT09MClzd2l0Y2godyl7Y2FzZSBVOmNhc2UgVjpjYXNlIEs6Y2FzZSBNOlJlPVwiXCI7YnJlYWs7ZGVmYXVsdDppZihDIT09TSlSZT1cIiBcIn1icmVhaztjYXNlIHJlOlJlPVwiXFxcXDBcIjticmVhaztjYXNlIGNlOlJlPVwiXFxcXGZcIjticmVhaztjYXNlIHNlOlJlPVwiXFxcXHZcIjticmVhaztjYXNlIFA6aWYoZCtoK289PT0wJiZnZT4wKU9lPTEsd2U9MSxSZT1cIlxcZlwiK1JlO2JyZWFrO2Nhc2UgMTA4OmlmKGQraCtvK2tlPT09MCYmej4wKXN3aXRjaChSLXope2Nhc2UgMjppZih3PT09bmUmJnMuY2hhckNvZGVBdChSLTMpPT09VilrZT13O2Nhc2UgODppZihtPT09bGUpa2U9bX1icmVhaztjYXNlIFY6aWYoZCtoK289PT0wKXo9UjticmVhaztjYXNlIFU6aWYoaCt1K2Qrbz09PTApd2U9MSxSZSs9XCJcXHJcIjticmVhaztjYXNlIFk6Y2FzZSBYOmlmKDA9PT1oKWQ9ZD09PUM/MDowPT09ZD9DOmQ7YnJlYWs7Y2FzZSBHOmlmKGQraCt1PT09MClvKys7YnJlYWs7Y2FzZSBIOmlmKGQraCt1PT09MClvLS07YnJlYWs7Y2FzZSBFOmlmKGQraCtvPT09MCl1LS07YnJlYWs7Y2FzZSBEOmlmKGQraCtvPT09MCl7aWYoMD09PU8pc3dpdGNoKDIqdyszKm0pe2Nhc2UgNTMzOmJyZWFrO2RlZmF1bHQ6eT0wLE89MX11Kyt9YnJlYWs7Y2FzZSBMOmlmKGgrdStkK28reitqPT09MClqPTE7YnJlYWs7Y2FzZSBUOmNhc2UgWjppZihkK28rdT4wKWJyZWFrO3N3aXRjaChoKXtjYXNlIDA6c3dpdGNoKDIqQyszKnMuY2hhckNvZGVBdChSKzEpKXtjYXNlIDIzNTpoPVo7YnJlYWs7Y2FzZSAyMjA6amU9UixoPVR9YnJlYWs7Y2FzZSBUOmlmKEM9PT1aJiZ3PT09VCYmamUrMiE9PVIpe2lmKDMzPT09cy5jaGFyQ29kZUF0KGplKzIpKVZlKz1zLnN1YnN0cmluZyhqZSxSKzEpO1JlPVwiXCIsaD0wfX19aWYoMD09PWgpe2lmKGdlK2QrbytqPT09MCYmdCE9PXRlJiZDIT09Vylzd2l0Y2goQyl7Y2FzZSBVOmNhc2UgYWU6Y2FzZSBfOmNhc2UgZWU6Y2FzZSBFOmNhc2UgRDppZigwPT09Tyl7c3dpdGNoKHcpe2Nhc2UgSzpjYXNlIE06Y2FzZSBJOmNhc2UgSjpSZSs9XCJcXDBcIjticmVhaztkZWZhdWx0OlJlPVwiXFwwXCIrUmUrKEM9PT1VP1wiXCI6XCJcXDBcIil9d2U9MX1lbHNlIHN3aXRjaChDKXtjYXNlIEQ6aWYoeis3PT09UiYmMTA4PT09dyl6PTA7Tz0rK3k7YnJlYWs7Y2FzZSBFOmlmKDA9PShPPS0teSkpd2U9MSxSZSs9XCJcXDBcIn1icmVhaztjYXNlIEs6Y2FzZSBNOnN3aXRjaCh3KXtjYXNlIHJlOmNhc2UgQjpjYXNlIHE6Y2FzZSBXOmNhc2UgVTpjYXNlIGNlOmNhc2UgSzpjYXNlIE06Y2FzZSBJOmNhc2UgSjpicmVhaztkZWZhdWx0OmlmKDA9PT1PKXdlPTEsUmUrPVwiXFwwXCJ9fWlmKFRlKz1SZSxDIT09TSYmQyE9PUspJD1DfX1tPXcsdz1DLFIrK31pZihqZT1WZS5sZW5ndGgsbWU+MClpZigwPT09amUmJjA9PT1YZS5sZW5ndGgmJjA9PT1hWzBdLmxlbmd0aD09ZmFsc2UpaWYodCE9PWllfHwxPT09YS5sZW5ndGgmJihnZT4wP0VlOkdlKT09PWFbMF0pamU9YS5qb2luKFwiLFwiKS5sZW5ndGgrMjtpZihqZT4wKXtpZihmPTA9PT1nZSYmdCE9PXRlP2Z1bmN0aW9uKGUpe2Zvcih2YXIgYSxyLHM9MCx0PWUubGVuZ3RoLGk9QXJyYXkodCk7czx0Oysrcyl7Zm9yKHZhciBmPWVbc10uc3BsaXQobCksbj1cIlwiLG89MCxoPTAsdT0wLGQ9MCxiPWYubGVuZ3RoO288YjsrK28pe2lmKDA9PT0oaD0ocj1mW29dKS5sZW5ndGgpJiZiPjEpY29udGludWU7aWYodT1uLmNoYXJDb2RlQXQobi5sZW5ndGgtMSksZD1yLmNoYXJDb2RlQXQoMCksYT1cIlwiLDAhPT1vKXN3aXRjaCh1KXtjYXNlIFQ6Y2FzZSBhZTpjYXNlIF86Y2FzZSBlZTpjYXNlIE06Y2FzZSBEOmJyZWFrO2RlZmF1bHQ6YT1cIiBcIn1zd2l0Y2goZCl7Y2FzZSBQOnI9YStFZTtjYXNlIGFlOmNhc2UgXzpjYXNlIGVlOmNhc2UgTTpjYXNlIEU6Y2FzZSBEOmJyZWFrO2Nhc2UgRzpyPWErcitFZTticmVhaztjYXNlIFY6c3dpdGNoKDIqci5jaGFyQ29kZUF0KDEpKzMqci5jaGFyQ29kZUF0KDIpKXtjYXNlIDUzMDppZihDZT4wKXtyPWErci5zdWJzdHJpbmcoOCxoLTEpO2JyZWFrfWRlZmF1bHQ6aWYobzwxfHxmW28tMV0ubGVuZ3RoPDEpcj1hK0VlK3J9YnJlYWs7Y2FzZSBVOmE9XCJcIjtkZWZhdWx0OmlmKGg+MSYmci5pbmRleE9mKFwiOlwiKT4wKXI9YStyLnJlcGxhY2UodixcIiQxXCIrRWUrXCIkMlwiKTtlbHNlIHI9YStyK0VlfW4rPXJ9aVtzXT1uLnJlcGxhY2UoYyxcIlwiKS50cmltKCl9cmV0dXJuIGl9KGEpOmEseWU+MClpZih2b2lkIDAhPT0obj1QZShGZSxWZSxmLGUscGUsYmUsamUsdCxpLHQpKSYmMD09PShWZT1uKS5sZW5ndGgpcmV0dXJuIFllK1ZlK1hlO2lmKFZlPWYuam9pbihcIixcIikrXCJ7XCIrVmUrXCJ9XCIsQWUqa2UhPTApe2lmKDI9PT1BZSYmIUxlKFZlLDIpKWtlPTA7c3dpdGNoKGtlKXtjYXNlIGxlOlZlPVZlLnJlcGxhY2UoayxcIjpcIitTK1wiJDFcIikrVmU7YnJlYWs7Y2FzZSBuZTpWZT1WZS5yZXBsYWNlKHAsXCI6OlwiK04rXCJpbnB1dC0kMVwiKStWZS5yZXBsYWNlKHAsXCI6OlwiK1MrXCIkMVwiKStWZS5yZXBsYWNlKHAsXCI6XCIrRitcImlucHV0LSQxXCIpK1ZlfWtlPTB9fXJldHVybiBZZStWZStYZX1mdW5jdGlvbiBJZShlLGEscil7dmFyIGM9YS50cmltKCkuc3BsaXQobykscz1jLHQ9Yy5sZW5ndGgsaT1lLmxlbmd0aDtzd2l0Y2goaSl7Y2FzZSAwOmNhc2UgMTpmb3IodmFyIGY9MCxuPTA9PT1pP1wiXCI6ZVswXStcIiBcIjtmPHQ7KytmKXNbZl09SmUobixzW2ZdLHIsaSkudHJpbSgpO2JyZWFrO2RlZmF1bHQ6Zj0wO3ZhciBsPTA7Zm9yKHM9W107Zjx0OysrZilmb3IodmFyIGg9MDtoPGk7KytoKXNbbCsrXT1KZShlW2hdK1wiIFwiLGNbZl0scixpKS50cmltKCl9cmV0dXJuIHN9ZnVuY3Rpb24gSmUoZSxhLHIsYyl7dmFyIHM9YSx0PXMuY2hhckNvZGVBdCgwKTtpZih0PDMzKXQ9KHM9cy50cmltKCkpLmNoYXJDb2RlQXQoMCk7c3dpdGNoKHQpe2Nhc2UgUDpzd2l0Y2goZ2UrYyl7Y2FzZSAwOmNhc2UgMTppZigwPT09ZS50cmltKCkubGVuZ3RoKWJyZWFrO2RlZmF1bHQ6cmV0dXJuIHMucmVwbGFjZShoLFwiJDFcIitlLnRyaW0oKSl9YnJlYWs7Y2FzZSBWOnN3aXRjaChzLmNoYXJDb2RlQXQoMSkpe2Nhc2UgMTAzOmlmKENlPjAmJmdlPjApcmV0dXJuIHMucmVwbGFjZSh1LFwiJDFcIikucmVwbGFjZShoLFwiJDFcIitHZSk7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gZS50cmltKCkrcy5yZXBsYWNlKGgsXCIkMVwiK2UudHJpbSgpKX1kZWZhdWx0OmlmKHIqZ2U+MCYmcy5pbmRleE9mKFwiXFxmXCIpPjApcmV0dXJuIHMucmVwbGFjZShoLChlLmNoYXJDb2RlQXQoMCk9PT1WP1wiXCI6XCIkMVwiKStlLnRyaW0oKSl9cmV0dXJuIGUrc31mdW5jdGlvbiBLZShlLGEscixjKXt2YXIgbCxvPTAsaD1lK1wiO1wiLHU9MiphKzMqcis0KmM7aWYoOTQ0PT09dSlyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIGE9ZS5sZW5ndGgscj1lLmluZGV4T2YoXCI6XCIsOSkrMSxjPWUuc3Vic3RyaW5nKDAscikudHJpbSgpLHM9ZS5zdWJzdHJpbmcocixhLTEpLnRyaW0oKTtzd2l0Y2goZS5jaGFyQ29kZUF0KDkpKkJlKXtjYXNlIDA6YnJlYWs7Y2FzZSBROmlmKDExMCE9PWUuY2hhckNvZGVBdCgxMCkpYnJlYWs7ZGVmYXVsdDpmb3IodmFyIHQ9cy5zcGxpdCgocz1cIlwiLGYpKSxpPTAscj0wLGE9dC5sZW5ndGg7aTxhO3I9MCwrK2kpe2Zvcih2YXIgbD10W2ldLG89bC5zcGxpdChuKTtsPW9bcl07KXt2YXIgaD1sLmNoYXJDb2RlQXQoMCk7aWYoMT09PUJlJiYoaD5MJiZoPDkwfHxoPjk2JiZoPDEyM3x8aD09PVJ8fGg9PT1RJiZsLmNoYXJDb2RlQXQoMSkhPT1RKSlzd2l0Y2goaXNOYU4ocGFyc2VGbG9hdChsKSkrKC0xIT09bC5pbmRleE9mKFwiKFwiKSkpe2Nhc2UgMTpzd2l0Y2gobCl7Y2FzZVwiaW5maW5pdGVcIjpjYXNlXCJhbHRlcm5hdGVcIjpjYXNlXCJiYWNrd2FyZHNcIjpjYXNlXCJydW5uaW5nXCI6Y2FzZVwibm9ybWFsXCI6Y2FzZVwiZm9yd2FyZHNcIjpjYXNlXCJib3RoXCI6Y2FzZVwibm9uZVwiOmNhc2VcImxpbmVhclwiOmNhc2VcImVhc2VcIjpjYXNlXCJlYXNlLWluXCI6Y2FzZVwiZWFzZS1vdXRcIjpjYXNlXCJlYXNlLWluLW91dFwiOmNhc2VcInBhdXNlZFwiOmNhc2VcInJldmVyc2VcIjpjYXNlXCJhbHRlcm5hdGUtcmV2ZXJzZVwiOmNhc2VcImluaGVyaXRcIjpjYXNlXCJpbml0aWFsXCI6Y2FzZVwidW5zZXRcIjpjYXNlXCJzdGVwLXN0YXJ0XCI6Y2FzZVwic3RlcC1lbmRcIjpicmVhaztkZWZhdWx0OmwrPURlfX1vW3IrK109bH1zKz0oMD09PWk/XCJcIjpcIixcIikrby5qb2luKFwiIFwiKX19aWYocz1jK3MrXCI7XCIsMT09PUFlfHwyPT09QWUmJkxlKHMsMSkpcmV0dXJuIE4rcytzO3JldHVybiBzfShoKTtlbHNlIGlmKDA9PT1BZXx8Mj09PUFlJiYhTGUoaCwxKSlyZXR1cm4gaDtzd2l0Y2godSl7Y2FzZSAxMDE1OnJldHVybiA5Nz09PWguY2hhckNvZGVBdCgxMCk/TitoK2g6aDtjYXNlIDk1MTpyZXR1cm4gMTE2PT09aC5jaGFyQ29kZUF0KDMpP04raCtoOmg7Y2FzZSA5NjM6cmV0dXJuIDExMD09PWguY2hhckNvZGVBdCg1KT9OK2graDpoO2Nhc2UgMTAwOTppZigxMDAhPT1oLmNoYXJDb2RlQXQoNCkpYnJlYWs7Y2FzZSA5Njk6Y2FzZSA5NDI6cmV0dXJuIE4raCtoO2Nhc2UgOTc4OnJldHVybiBOK2grUytoK2g7Y2FzZSAxMDE5OmNhc2UgOTgzOnJldHVybiBOK2grUytoK0YraCtoO2Nhc2UgODgzOmlmKGguY2hhckNvZGVBdCg4KT09PVEpcmV0dXJuIE4raCtoO2lmKGguaW5kZXhPZihcImltYWdlLXNldChcIiwxMSk+MClyZXR1cm4gaC5yZXBsYWNlKHosXCIkMVwiK04rXCIkMlwiKStoO3JldHVybiBoO2Nhc2UgOTMyOmlmKGguY2hhckNvZGVBdCg0KT09PVEpc3dpdGNoKGguY2hhckNvZGVBdCg1KSl7Y2FzZSAxMDM6cmV0dXJuIE4rXCJib3gtXCIraC5yZXBsYWNlKFwiLWdyb3dcIixcIlwiKStOK2grRitoLnJlcGxhY2UoXCJncm93XCIsXCJwb3NpdGl2ZVwiKStoO2Nhc2UgMTE1OnJldHVybiBOK2grRitoLnJlcGxhY2UoXCJzaHJpbmtcIixcIm5lZ2F0aXZlXCIpK2g7Y2FzZSA5ODpyZXR1cm4gTitoK0YraC5yZXBsYWNlKFwiYmFzaXNcIixcInByZWZlcnJlZC1zaXplXCIpK2h9cmV0dXJuIE4raCtGK2graDtjYXNlIDk2NDpyZXR1cm4gTitoK0YrXCJmbGV4LVwiK2graDtjYXNlIDEwMjM6aWYoOTkhPT1oLmNoYXJDb2RlQXQoOCkpYnJlYWs7cmV0dXJuIGw9aC5zdWJzdHJpbmcoaC5pbmRleE9mKFwiOlwiLDE1KSkucmVwbGFjZShcImZsZXgtXCIsXCJcIikucmVwbGFjZShcInNwYWNlLWJldHdlZW5cIixcImp1c3RpZnlcIiksTitcImJveC1wYWNrXCIrbCtOK2grRitcImZsZXgtcGFja1wiK2wraDtjYXNlIDEwMDU6cmV0dXJuIHQudGVzdChoKT9oLnJlcGxhY2UocyxcIjpcIitOKStoLnJlcGxhY2UocyxcIjpcIitTKStoOmg7Y2FzZSAxZTM6c3dpdGNoKG89KGw9aC5zdWJzdHJpbmcoMTMpLnRyaW0oKSkuaW5kZXhPZihcIi1cIikrMSxsLmNoYXJDb2RlQXQoMCkrbC5jaGFyQ29kZUF0KG8pKXtjYXNlIDIyNjpsPWgucmVwbGFjZShtLFwidGJcIik7YnJlYWs7Y2FzZSAyMzI6bD1oLnJlcGxhY2UobSxcInRiLXJsXCIpO2JyZWFrO2Nhc2UgMjIwOmw9aC5yZXBsYWNlKG0sXCJsclwiKTticmVhaztkZWZhdWx0OnJldHVybiBofXJldHVybiBOK2grRitsK2g7Y2FzZSAxMDE3OmlmKC0xPT09aC5pbmRleE9mKFwic3RpY2t5XCIsOSkpcmV0dXJuIGg7Y2FzZSA5NzU6c3dpdGNoKG89KGg9ZSkubGVuZ3RoLTEwLHU9KGw9KDMzPT09aC5jaGFyQ29kZUF0KG8pP2guc3Vic3RyaW5nKDAsbyk6aCkuc3Vic3RyaW5nKGUuaW5kZXhPZihcIjpcIiw3KSsxKS50cmltKCkpLmNoYXJDb2RlQXQoMCkrKDB8bC5jaGFyQ29kZUF0KDcpKSl7Y2FzZSAyMDM6aWYobC5jaGFyQ29kZUF0KDgpPDExMSlicmVhaztjYXNlIDExNTpoPWgucmVwbGFjZShsLE4rbCkrXCI7XCIraDticmVhaztjYXNlIDIwNzpjYXNlIDEwMjpoPWgucmVwbGFjZShsLE4rKHU+MTAyP1wiaW5saW5lLVwiOlwiXCIpK1wiYm94XCIpK1wiO1wiK2gucmVwbGFjZShsLE4rbCkrXCI7XCIraC5yZXBsYWNlKGwsRitsK1wiYm94XCIpK1wiO1wiK2h9cmV0dXJuIGgrXCI7XCI7Y2FzZSA5Mzg6aWYoaC5jaGFyQ29kZUF0KDUpPT09USlzd2l0Y2goaC5jaGFyQ29kZUF0KDYpKXtjYXNlIDEwNTpyZXR1cm4gbD1oLnJlcGxhY2UoXCItaXRlbXNcIixcIlwiKSxOK2grTitcImJveC1cIitsK0YrXCJmbGV4LVwiK2wraDtjYXNlIDExNTpyZXR1cm4gTitoK0YrXCJmbGV4LWl0ZW0tXCIraC5yZXBsYWNlKHksXCJcIikraDtkZWZhdWx0OnJldHVybiBOK2grRitcImZsZXgtbGluZS1wYWNrXCIraC5yZXBsYWNlKFwiYWxpZ24tY29udGVudFwiLFwiXCIpLnJlcGxhY2UoeSxcIlwiKStofWJyZWFrO2Nhc2UgOTczOmNhc2UgOTg5OmlmKGguY2hhckNvZGVBdCgzKSE9PVF8fDEyMj09PWguY2hhckNvZGVBdCg0KSlicmVhaztjYXNlIDkzMTpjYXNlIDk1MzppZih0cnVlPT09ai50ZXN0KGUpKWlmKDExNT09PShsPWUuc3Vic3RyaW5nKGUuaW5kZXhPZihcIjpcIikrMSkpLmNoYXJDb2RlQXQoMCkpcmV0dXJuIEtlKGUucmVwbGFjZShcInN0cmV0Y2hcIixcImZpbGwtYXZhaWxhYmxlXCIpLGEscixjKS5yZXBsYWNlKFwiOmZpbGwtYXZhaWxhYmxlXCIsXCI6c3RyZXRjaFwiKTtlbHNlIHJldHVybiBoLnJlcGxhY2UobCxOK2wpK2gucmVwbGFjZShsLFMrbC5yZXBsYWNlKFwiZmlsbC1cIixcIlwiKSkraDticmVhaztjYXNlIDk2MjppZihoPU4raCsoMTAyPT09aC5jaGFyQ29kZUF0KDUpP0YraDpcIlwiKStoLHIrYz09PTIxMSYmMTA1PT09aC5jaGFyQ29kZUF0KDEzKSYmaC5pbmRleE9mKFwidHJhbnNmb3JtXCIsMTApPjApcmV0dXJuIGguc3Vic3RyaW5nKDAsaC5pbmRleE9mKFwiO1wiLDI3KSsxKS5yZXBsYWNlKGksXCIkMVwiK04rXCIkMlwiKStofXJldHVybiBofWZ1bmN0aW9uIExlKGUsYSl7dmFyIHI9ZS5pbmRleE9mKDE9PT1hP1wiOlwiOlwie1wiKSxjPWUuc3Vic3RyaW5nKDAsMyE9PWE/cjoxMCkscz1lLnN1YnN0cmluZyhyKzEsZS5sZW5ndGgtMSk7cmV0dXJuIE9lKDIhPT1hP2M6Yy5yZXBsYWNlKE8sXCIkMVwiKSxzLGEpfWZ1bmN0aW9uIE1lKGUsYSl7dmFyIHI9S2UoYSxhLmNoYXJDb2RlQXQoMCksYS5jaGFyQ29kZUF0KDEpLGEuY2hhckNvZGVBdCgyKSk7cmV0dXJuIHIhPT1hK1wiO1wiP3IucmVwbGFjZSgkLFwiIG9yICgkMSlcIikuc3Vic3RyaW5nKDQpOlwiKFwiK2ErXCIpXCJ9ZnVuY3Rpb24gUGUoZSxhLHIsYyxzLHQsaSxmLG4sbCl7Zm9yKHZhciBvLGg9MCx1PWE7aDx5ZTsrK2gpc3dpdGNoKG89JGVbaF0uY2FsbChUZSxlLHUscixjLHMsdCxpLGYsbixsKSl7Y2FzZSB2b2lkIDA6Y2FzZSBmYWxzZTpjYXNlIHRydWU6Y2FzZSBudWxsOmJyZWFrO2RlZmF1bHQ6dT1vfWlmKHUhPT1hKXJldHVybiB1fWZ1bmN0aW9uIFFlKGUsYSxyLGMpe2Zvcih2YXIgcz1hKzE7czxyOysrcylzd2l0Y2goYy5jaGFyQ29kZUF0KHMpKXtjYXNlIFo6aWYoZT09PVQpaWYoYy5jaGFyQ29kZUF0KHMtMSk9PT1UJiZhKzIhPT1zKXJldHVybiBzKzE7YnJlYWs7Y2FzZSBJOmlmKGU9PT1aKXJldHVybiBzKzF9cmV0dXJuIHN9ZnVuY3Rpb24gUmUoZSl7Zm9yKHZhciBhIGluIGUpe3ZhciByPWVbYV07c3dpdGNoKGEpe2Nhc2VcImtleWZyYW1lXCI6QmU9MHxyO2JyZWFrO2Nhc2VcImdsb2JhbFwiOkNlPTB8cjticmVhaztjYXNlXCJjYXNjYWRlXCI6Z2U9MHxyO2JyZWFrO2Nhc2VcImNvbXByZXNzXCI6d2U9MHxyO2JyZWFrO2Nhc2VcInNlbWljb2xvblwiOnZlPTB8cjticmVhaztjYXNlXCJwcmVzZXJ2ZVwiOm1lPTB8cjticmVhaztjYXNlXCJwcmVmaXhcIjppZihPZT1udWxsLCFyKUFlPTA7ZWxzZSBpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiByKUFlPTE7ZWxzZSBBZT0yLE9lPXJ9fXJldHVybiBSZX1mdW5jdGlvbiBUZShhLHIpe2lmKHZvaWQgMCE9PXRoaXMmJnRoaXMuY29uc3RydWN0b3I9PT1UZSlyZXR1cm4gZShhKTt2YXIgcz1hLHQ9cy5jaGFyQ29kZUF0KDApO2lmKHQ8MzMpdD0ocz1zLnRyaW0oKSkuY2hhckNvZGVBdCgwKTtpZihCZT4wKURlPXMucmVwbGFjZShkLHQ9PT1HP1wiXCI6XCItXCIpO2lmKHQ9MSwxPT09Z2UpR2U9cztlbHNlIEVlPXM7dmFyIGksZj1bR2VdO2lmKHllPjApaWYodm9pZCAwIT09KGk9UGUoemUscixmLGYscGUsYmUsMCwwLDAsMCkpJiZcInN0cmluZ1wiPT10eXBlb2YgaSlyPWk7dmFyIG49SGUoeGUsZixyLDAsMCk7aWYoeWU+MClpZih2b2lkIDAhPT0oaT1QZShqZSxuLGYsZixwZSxiZSxuLmxlbmd0aCwwLDAsMCkpJiZcInN0cmluZ1wiIT10eXBlb2Yobj1pKSl0PTA7cmV0dXJuIERlPVwiXCIsR2U9XCJcIixFZT1cIlwiLGtlPTAscGU9MSxiZT0xLHdlKnQ9PTA/bjpuLnJlcGxhY2UoYyxcIlwiKS5yZXBsYWNlKGcsXCJcIikucmVwbGFjZShBLFwiJDFcIikucmVwbGFjZShDLFwiJDFcIikucmVwbGFjZSh3LFwiIFwiKX1pZihUZS51c2U9ZnVuY3Rpb24gZShhKXtzd2l0Y2goYSl7Y2FzZSB2b2lkIDA6Y2FzZSBudWxsOnllPSRlLmxlbmd0aD0wO2JyZWFrO2RlZmF1bHQ6aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgYSkkZVt5ZSsrXT1hO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGEpZm9yKHZhciByPTAsYz1hLmxlbmd0aDtyPGM7KytyKWUoYVtyXSk7ZWxzZSBxZT0wfCEhYX1yZXR1cm4gZX0sVGUuc2V0PVJlLHZvaWQgMCE9PWEpUmUoYSk7cmV0dXJuIFRlfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsaXMubWluLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(15);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlcml2LXAycC5bbmFtZV0vLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanM/NGNlYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUVBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('function areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (newInputs[i] !== lastInputs[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\n/* harmony default export */ __webpack_exports__["a"] = (memoizeOne);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlcml2LXAycC5bbmFtZV0vLi9ub2RlX21vZHVsZXMvbWVtb2l6ZS1vbmUvZGlzdC9tZW1vaXplLW9uZS5lc20uanM/NWIwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBhcmVJbnB1dHNFcXVhbChuZXdJbnB1dHMsIGxhc3RJbnB1dHMpIHtcbiAgICBpZiAobmV3SW5wdXRzLmxlbmd0aCAhPT0gbGFzdElucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0lucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobmV3SW5wdXRzW2ldICE9PSBsYXN0SW5wdXRzW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG1lbW9pemVPbmUocmVzdWx0Rm4sIGlzRXF1YWwpIHtcbiAgICBpZiAoaXNFcXVhbCA9PT0gdm9pZCAwKSB7IGlzRXF1YWwgPSBhcmVJbnB1dHNFcXVhbDsgfVxuICAgIHZhciBsYXN0VGhpcztcbiAgICB2YXIgbGFzdEFyZ3MgPSBbXTtcbiAgICB2YXIgbGFzdFJlc3VsdDtcbiAgICB2YXIgY2FsbGVkT25jZSA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIG1lbW9pemVkKCkge1xuICAgICAgICB2YXIgbmV3QXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbmV3QXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsZWRPbmNlICYmIGxhc3RUaGlzID09PSB0aGlzICYmIGlzRXF1YWwobmV3QXJncywgbGFzdEFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UmVzdWx0ID0gcmVzdWx0Rm4uYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgICAgIGNhbGxlZE9uY2UgPSB0cnVlO1xuICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICAgIGxhc3RBcmdzID0gbmV3QXJncztcbiAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBtZW1vaXplZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWVtb2l6ZU9uZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export createGlobalStyle */\n/* unused harmony export css */\n/* unused harmony export isStyledComponent */\n/* unused harmony export keyframes */\n/* unused harmony export ServerStyleSheet */\n/* unused harmony export StyleSheetConsumer */\n/* unused harmony export StyleSheetContext */\n/* unused harmony export StyleSheetManager */\n/* unused harmony export ThemeConsumer */\n/* unused harmony export ThemeContext */\n/* unused harmony export ThemeProvider */\n/* unused harmony export withTheme */\n/* unused harmony export __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS */\n/* harmony import */ var stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var stylis_rule_sheet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);\n/* harmony import */ var stylis_rule_sheet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(stylis_rule_sheet__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _emotion_unitless__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);\n/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2);\n/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_is__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(16);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7);\n/* harmony import */ var merge_anything__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(8);\n\n\n\n\n\n\n\n\n\n\n// \n\nvar interleave = (function (strings, interpolations) {\n  var result = [strings[0]];\n\n  for (var i = 0, len = interpolations.length; i < len; i += 1) {\n    result.push(interpolations[i], strings[i + 1]);\n  }\n\n  return result;\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n// \nvar isPlainObject = (function (x) {\n  return (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x.constructor === Object;\n});\n\n// \nvar EMPTY_ARRAY = Object.freeze([]);\nvar EMPTY_OBJECT = Object.freeze({});\n\n// \nfunction isFunction(test) {\n  return typeof test === 'function';\n}\n\n// \n\nfunction getComponentName(target) {\n  return ( false) || target.displayName || target.name || 'Component';\n}\n\n// \nfunction isStatelessFunction(test) {\n  return typeof test === 'function' && !(test.prototype && test.prototype.isReactComponent);\n}\n\n// \nfunction isStyledComponent(target) {\n  return target && typeof target.styledComponentId === 'string';\n}\n\n// \n\nvar SC_ATTR = typeof process !== 'undefined' && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || 'data-styled';\n\nvar SC_VERSION_ATTR = 'data-styled-version';\n\nvar SC_STREAM_ATTR = 'data-styled-streamed';\n\nvar IS_BROWSER = typeof window !== 'undefined' && 'HTMLElement' in window;\n\nvar DISABLE_SPEEDY = typeof SC_DISABLE_SPEEDY === 'boolean' && SC_DISABLE_SPEEDY || typeof process !== 'undefined' && (process.env.REACT_APP_SC_DISABLE_SPEEDY || process.env.SC_DISABLE_SPEEDY) || \"production\" !== 'production';\n\n// Shared empty execution context when generating static styles\nvar STATIC_EXECUTION_CONTEXT = {};\n\n// \n\n\n/**\n * Parse errors.md and turn it into a simple hash of code: message\n */\nvar ERRORS =  false ? undefined : {};\n\n/**\n * super basic version of sprintf\n */\nfunction format() {\n  var a = arguments.length <= 0 ? undefined : arguments[0];\n  var b = [];\n\n  for (var c = 1, len = arguments.length; c < len; c += 1) {\n    b.push(arguments.length <= c ? undefined : arguments[c]);\n  }\n\n  b.forEach(function (d) {\n    a = a.replace(/%[a-z]/, d);\n  });\n\n  return a;\n}\n\n/**\n * Create an error file out of errors.md for development and a simple web link to the full errors\n * in production mode.\n */\n\nvar StyledComponentsError = function (_Error) {\n  inherits(StyledComponentsError, _Error);\n\n  function StyledComponentsError(code) {\n    classCallCheck(this, StyledComponentsError);\n\n    for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      interpolations[_key - 1] = arguments[_key];\n    }\n\n    if (true) {\n      var _this = possibleConstructorReturn(this, _Error.call(this, 'An error occurred. See https://github.com/styled-components/styled-components/blob/master/packages/styled-components/src/utils/errors.md#' + code + ' for more information.' + (interpolations.length > 0 ? ' Additional arguments: ' + interpolations.join(', ') : '')));\n    } else { var _this; }\n    return possibleConstructorReturn(_this);\n  }\n\n  return StyledComponentsError;\n}(Error);\n\n// \nvar SC_COMPONENT_ID = /^[^\\S\\n]*?\\/\\* sc-component-id:\\s*(\\S+)\\s+\\*\\//gm;\n\nvar extractComps = (function (maybeCSS) {\n  var css = '' + (maybeCSS || ''); // Definitely a string, and a clone\n  var existingComponents = [];\n  css.replace(SC_COMPONENT_ID, function (match, componentId, matchIndex) {\n    existingComponents.push({ componentId: componentId, matchIndex: matchIndex });\n    return match;\n  });\n  return existingComponents.map(function (_ref, i) {\n    var componentId = _ref.componentId,\n        matchIndex = _ref.matchIndex;\n\n    var nextComp = existingComponents[i + 1];\n    var cssFromDOM = nextComp ? css.slice(matchIndex, nextComp.matchIndex) : css.slice(matchIndex);\n    return { componentId: componentId, cssFromDOM: cssFromDOM };\n  });\n});\n\n// \n\nvar COMMENT_REGEX = /^\\s*\\/\\/.*$/gm;\n\n// NOTE: This stylis instance is only used to split rules from SSR'd style tags\nvar stylisSplitter = new stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0___default.a({\n  global: false,\n  cascade: true,\n  keyframe: false,\n  prefix: false,\n  compress: false,\n  semicolon: true\n});\n\nvar stylis = new stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0___default.a({\n  global: false,\n  cascade: true,\n  keyframe: false,\n  prefix: true,\n  compress: false,\n  semicolon: false // NOTE: This means \"autocomplete missing semicolons\"\n});\n\n// Wrap `insertRulePlugin to build a list of rules,\n// and then make our own plugin to return the rules. This\n// makes it easier to hook into the existing SSR architecture\n\nvar parsingRules = [];\n\n// eslint-disable-next-line consistent-return\nvar returnRulesPlugin = function returnRulesPlugin(context) {\n  if (context === -2) {\n    var parsedRules = parsingRules;\n    parsingRules = [];\n    return parsedRules;\n  }\n};\n\nvar parseRulesPlugin = stylis_rule_sheet__WEBPACK_IMPORTED_MODULE_1___default()(function (rule) {\n  parsingRules.push(rule);\n});\n\nvar _componentId = void 0;\nvar _selector = void 0;\nvar _selectorRegexp = void 0;\n\nvar selfReferenceReplacer = function selfReferenceReplacer(match, offset, string) {\n  if (\n  // the first self-ref is always untouched\n  offset > 0 &&\n  // there should be at least two self-refs to do a replacement (.b > .b)\n  string.slice(0, offset).indexOf(_selector) !== -1 &&\n  // no consecutive self refs (.b.b); that is a precedence boost and treated differently\n  string.slice(offset - _selector.length, offset) !== _selector) {\n    return '.' + _componentId;\n  }\n\n  return match;\n};\n\n/**\n * When writing a style like\n *\n * & + & {\n *   color: red;\n * }\n *\n * The second ampersand should be a reference to the static component class. stylis\n * has no knowledge of static class so we have to intelligently replace the base selector.\n */\nvar selfReferenceReplacementPlugin = function selfReferenceReplacementPlugin(context, _, selectors) {\n  if (context === 2 && selectors.length && selectors[0].lastIndexOf(_selector) > 0) {\n    // eslint-disable-next-line no-param-reassign\n    selectors[0] = selectors[0].replace(_selectorRegexp, selfReferenceReplacer);\n  }\n};\n\nstylis.use([selfReferenceReplacementPlugin, parseRulesPlugin, returnRulesPlugin]);\nstylisSplitter.use([parseRulesPlugin, returnRulesPlugin]);\n\nvar splitByRules = function splitByRules(css) {\n  return stylisSplitter('', css);\n};\n\nfunction stringifyRules(rules, selector, prefix) {\n  var componentId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '&';\n\n  var flatCSS = rules.join('').replace(COMMENT_REGEX, ''); // replace JS comments\n\n  var cssStr = selector && prefix ? prefix + ' ' + selector + ' { ' + flatCSS + ' }' : flatCSS;\n\n  // stylis has no concept of state to be passed to plugins\n  // but since JS is single=threaded, we can rely on that to ensure\n  // these properties stay in sync with the current stylis run\n  _componentId = componentId;\n  _selector = selector;\n  _selectorRegexp = new RegExp('\\\\' + _selector + '\\\\b', 'g');\n\n  return stylis(prefix || !selector ? '' : selector, cssStr);\n}\n\n// \n/* eslint-disable camelcase, no-undef */\n\nvar getNonce = (function () {\n  return  true ? __webpack_require__.nc : undefined;\n});\n\n// \n/* These are helpers for the StyleTags to keep track of the injected\n * rule names for each (component) ID that they're keeping track of.\n * They're crucial for detecting whether a name has already been\n * injected.\n * (This excludes rehydrated names) */\n\n/* adds a new ID:name pairing to a names dictionary */\nvar addNameForId = function addNameForId(names, id, name) {\n  if (name) {\n    // eslint-disable-next-line no-param-reassign\n    var namesForId = names[id] || (names[id] = Object.create(null));\n    namesForId[name] = true;\n  }\n};\n\n/* resets an ID entirely by overwriting it in the dictionary */\nvar resetIdNames = function resetIdNames(names, id) {\n  // eslint-disable-next-line no-param-reassign\n  names[id] = Object.create(null);\n};\n\n/* factory for a names dictionary checking the existance of an ID:name pairing */\nvar hasNameForId = function hasNameForId(names) {\n  return function (id, name) {\n    return names[id] !== undefined && names[id][name];\n  };\n};\n\n/* stringifies names for the html/element output */\nvar stringifyNames = function stringifyNames(names) {\n  var str = '';\n  // eslint-disable-next-line guard-for-in\n  for (var id in names) {\n    str += Object.keys(names[id]).join(' ') + ' ';\n  }\n  return str.trim();\n};\n\n/* clones the nested names dictionary */\nvar cloneNames = function cloneNames(names) {\n  var clone = Object.create(null);\n  // eslint-disable-next-line guard-for-in\n  for (var id in names) {\n    clone[id] = _extends({}, names[id]);\n  }\n  return clone;\n};\n\n// \n\n/* These are helpers that deal with the insertRule (aka speedy) API\n * They are used in the StyleTags and specifically the speedy tag\n */\n\n/* retrieve a sheet for a given style tag */\nvar sheetForTag = function sheetForTag(tag) {\n  // $FlowFixMe\n  if (tag.sheet) return tag.sheet;\n\n  /* Firefox quirk requires us to step through all stylesheets to find one owned by the given tag */\n  var size = tag.ownerDocument.styleSheets.length;\n  for (var i = 0; i < size; i += 1) {\n    var sheet = tag.ownerDocument.styleSheets[i];\n    // $FlowFixMe\n    if (sheet.ownerNode === tag) return sheet;\n  }\n\n  /* we should always be able to find a tag */\n  throw new StyledComponentsError(10);\n};\n\n/* insert a rule safely and return whether it was actually injected */\nvar safeInsertRule = function safeInsertRule(sheet, cssRule, index) {\n  /* abort early if cssRule string is falsy */\n  if (!cssRule) return false;\n\n  var maxIndex = sheet.cssRules.length;\n\n  try {\n    /* use insertRule and cap passed index with maxIndex (no of cssRules) */\n    sheet.insertRule(cssRule, index <= maxIndex ? index : maxIndex);\n  } catch (err) {\n    /* any error indicates an invalid rule */\n    return false;\n  }\n\n  return true;\n};\n\n/* deletes `size` rules starting from `removalIndex` */\nvar deleteRules = function deleteRules(sheet, removalIndex, size) {\n  var lowerBound = removalIndex - size;\n  for (var i = removalIndex; i > lowerBound; i -= 1) {\n    sheet.deleteRule(i);\n  }\n};\n\n// \n\n/* this marker separates component styles and is important for rehydration */\nvar makeTextMarker = function makeTextMarker(id) {\n  return '\\n/* sc-component-id: ' + id + ' */\\n';\n};\n\n/* add up all numbers in array up until and including the index */\nvar addUpUntilIndex = function addUpUntilIndex(sizes, index) {\n  var totalUpToIndex = 0;\n  for (var i = 0; i <= index; i += 1) {\n    totalUpToIndex += sizes[i];\n  }\n\n  return totalUpToIndex;\n};\n\n/* create a new style tag after lastEl */\nvar makeStyleTag = function makeStyleTag(target, tagEl, insertBefore) {\n  var targetDocument = document;\n  if (target) targetDocument = target.ownerDocument;else if (tagEl) targetDocument = tagEl.ownerDocument;\n\n  var el = targetDocument.createElement('style');\n  el.setAttribute(SC_ATTR, '');\n  el.setAttribute(SC_VERSION_ATTR, \"4.4.1\");\n\n  var nonce = getNonce();\n  if (nonce) {\n    el.setAttribute('nonce', nonce);\n  }\n\n  /* Work around insertRule quirk in EdgeHTML */\n  el.appendChild(targetDocument.createTextNode(''));\n\n  if (target && !tagEl) {\n    /* Append to target when no previous element was passed */\n    target.appendChild(el);\n  } else {\n    if (!tagEl || !target || !tagEl.parentNode) {\n      throw new StyledComponentsError(6);\n    }\n\n    /* Insert new style tag after the previous one */\n    tagEl.parentNode.insertBefore(el, insertBefore ? tagEl : tagEl.nextSibling);\n  }\n\n  return el;\n};\n\n/* takes a css factory function and outputs an html styled tag factory */\nvar wrapAsHtmlTag = function wrapAsHtmlTag(css, names) {\n  return function (additionalAttrs) {\n    var nonce = getNonce();\n    var attrs = [nonce && 'nonce=\"' + nonce + '\"', SC_ATTR + '=\"' + stringifyNames(names) + '\"', SC_VERSION_ATTR + '=\"' + \"4.4.1\" + '\"', additionalAttrs];\n\n    var htmlAttr = attrs.filter(Boolean).join(' ');\n    return '<style ' + htmlAttr + '>' + css() + '</style>';\n  };\n};\n\n/* takes a css factory function and outputs an element factory */\nvar wrapAsElement = function wrapAsElement(css, names) {\n  return function () {\n    var _props;\n\n    var props = (_props = {}, _props[SC_ATTR] = stringifyNames(names), _props[SC_VERSION_ATTR] = \"4.4.1\", _props);\n\n    var nonce = getNonce();\n    if (nonce) {\n      // $FlowFixMe\n      props.nonce = nonce;\n    }\n\n    // eslint-disable-next-line react/no-danger\n    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement('style', _extends({}, props, { dangerouslySetInnerHTML: { __html: css() } }));\n  };\n};\n\nvar getIdsFromMarkersFactory = function getIdsFromMarkersFactory(markers) {\n  return function () {\n    return Object.keys(markers);\n  };\n};\n\n/* speedy tags utilise insertRule */\nvar makeSpeedyTag = function makeSpeedyTag(el, getImportRuleTag) {\n  var names = Object.create(null);\n  var markers = Object.create(null);\n  var sizes = [];\n\n  var extractImport = getImportRuleTag !== undefined;\n  /* indicates whether getImportRuleTag was called */\n  var usedImportRuleTag = false;\n\n  var insertMarker = function insertMarker(id) {\n    var prev = markers[id];\n    if (prev !== undefined) {\n      return prev;\n    }\n\n    markers[id] = sizes.length;\n    sizes.push(0);\n    resetIdNames(names, id);\n\n    return markers[id];\n  };\n\n  var insertRules = function insertRules(id, cssRules, name) {\n    var marker = insertMarker(id);\n    var sheet = sheetForTag(el);\n    var insertIndex = addUpUntilIndex(sizes, marker);\n\n    var injectedRules = 0;\n    var importRules = [];\n    var cssRulesSize = cssRules.length;\n\n    for (var i = 0; i < cssRulesSize; i += 1) {\n      var cssRule = cssRules[i];\n      var mayHaveImport = extractImport; /* @import rules are reordered to appear first */\n      if (mayHaveImport && cssRule.indexOf('@import') !== -1) {\n        importRules.push(cssRule);\n      } else if (safeInsertRule(sheet, cssRule, insertIndex + injectedRules)) {\n        mayHaveImport = false;\n        injectedRules += 1;\n      }\n    }\n\n    if (extractImport && importRules.length > 0) {\n      usedImportRuleTag = true;\n      // $FlowFixMe\n      getImportRuleTag().insertRules(id + '-import', importRules);\n    }\n\n    sizes[marker] += injectedRules; /* add up no of injected rules */\n    addNameForId(names, id, name);\n  };\n\n  var removeRules = function removeRules(id) {\n    var marker = markers[id];\n    if (marker === undefined) return;\n    // $FlowFixMe\n    if (el.isConnected === false) return;\n\n    var size = sizes[marker];\n    var sheet = sheetForTag(el);\n    var removalIndex = addUpUntilIndex(sizes, marker) - 1;\n    deleteRules(sheet, removalIndex, size);\n    sizes[marker] = 0;\n    resetIdNames(names, id);\n\n    if (extractImport && usedImportRuleTag) {\n      // $FlowFixMe\n      getImportRuleTag().removeRules(id + '-import');\n    }\n  };\n\n  var css = function css() {\n    var _sheetForTag = sheetForTag(el),\n        cssRules = _sheetForTag.cssRules;\n\n    var str = '';\n\n    // eslint-disable-next-line guard-for-in\n    for (var id in markers) {\n      str += makeTextMarker(id);\n      var marker = markers[id];\n      var end = addUpUntilIndex(sizes, marker);\n      var size = sizes[marker];\n      for (var i = end - size; i < end; i += 1) {\n        var rule = cssRules[i];\n        if (rule !== undefined) {\n          str += rule.cssText;\n        }\n      }\n    }\n\n    return str;\n  };\n\n  return {\n    clone: function clone() {\n      throw new StyledComponentsError(5);\n    },\n\n    css: css,\n    getIds: getIdsFromMarkersFactory(markers),\n    hasNameForId: hasNameForId(names),\n    insertMarker: insertMarker,\n    insertRules: insertRules,\n    removeRules: removeRules,\n    sealed: false,\n    styleTag: el,\n    toElement: wrapAsElement(css, names),\n    toHTML: wrapAsHtmlTag(css, names)\n  };\n};\n\nvar makeTextNode = function makeTextNode(targetDocument, id) {\n  return targetDocument.createTextNode(makeTextMarker(id));\n};\n\nvar makeBrowserTag = function makeBrowserTag(el, getImportRuleTag) {\n  var names = Object.create(null);\n  var markers = Object.create(null);\n\n  var extractImport = getImportRuleTag !== undefined;\n\n  /* indicates whether getImportRuleTag was called */\n  var usedImportRuleTag = false;\n\n  var insertMarker = function insertMarker(id) {\n    var prev = markers[id];\n    if (prev !== undefined) {\n      return prev;\n    }\n\n    markers[id] = makeTextNode(el.ownerDocument, id);\n    el.appendChild(markers[id]);\n    names[id] = Object.create(null);\n\n    return markers[id];\n  };\n\n  var insertRules = function insertRules(id, cssRules, name) {\n    var marker = insertMarker(id);\n    var importRules = [];\n    var cssRulesSize = cssRules.length;\n\n    for (var i = 0; i < cssRulesSize; i += 1) {\n      var rule = cssRules[i];\n      var mayHaveImport = extractImport;\n      if (mayHaveImport && rule.indexOf('@import') !== -1) {\n        importRules.push(rule);\n      } else {\n        mayHaveImport = false;\n        var separator = i === cssRulesSize - 1 ? '' : ' ';\n        marker.appendData('' + rule + separator);\n      }\n    }\n\n    addNameForId(names, id, name);\n\n    if (extractImport && importRules.length > 0) {\n      usedImportRuleTag = true;\n      // $FlowFixMe\n      getImportRuleTag().insertRules(id + '-import', importRules);\n    }\n  };\n\n  var removeRules = function removeRules(id) {\n    var marker = markers[id];\n    if (marker === undefined) return;\n\n    /* create new empty text node and replace the current one */\n    var newMarker = makeTextNode(el.ownerDocument, id);\n    el.replaceChild(newMarker, marker);\n    markers[id] = newMarker;\n    resetIdNames(names, id);\n\n    if (extractImport && usedImportRuleTag) {\n      // $FlowFixMe\n      getImportRuleTag().removeRules(id + '-import');\n    }\n  };\n\n  var css = function css() {\n    var str = '';\n\n    // eslint-disable-next-line guard-for-in\n    for (var id in markers) {\n      str += markers[id].data;\n    }\n\n    return str;\n  };\n\n  return {\n    clone: function clone() {\n      throw new StyledComponentsError(5);\n    },\n\n    css: css,\n    getIds: getIdsFromMarkersFactory(markers),\n    hasNameForId: hasNameForId(names),\n    insertMarker: insertMarker,\n    insertRules: insertRules,\n    removeRules: removeRules,\n    sealed: false,\n    styleTag: el,\n    toElement: wrapAsElement(css, names),\n    toHTML: wrapAsHtmlTag(css, names)\n  };\n};\n\nvar makeServerTag = function makeServerTag(namesArg, markersArg) {\n  var names = namesArg === undefined ? Object.create(null) : namesArg;\n  var markers = markersArg === undefined ? Object.create(null) : markersArg;\n\n  var insertMarker = function insertMarker(id) {\n    var prev = markers[id];\n    if (prev !== undefined) {\n      return prev;\n    }\n\n    return markers[id] = [''];\n  };\n\n  var insertRules = function insertRules(id, cssRules, name) {\n    var marker = insertMarker(id);\n    marker[0] += cssRules.join(' ');\n    addNameForId(names, id, name);\n  };\n\n  var removeRules = function removeRules(id) {\n    var marker = markers[id];\n    if (marker === undefined) return;\n    marker[0] = '';\n    resetIdNames(names, id);\n  };\n\n  var css = function css() {\n    var str = '';\n    // eslint-disable-next-line guard-for-in\n    for (var id in markers) {\n      var cssForId = markers[id][0];\n      if (cssForId) {\n        str += makeTextMarker(id) + cssForId;\n      }\n    }\n    return str;\n  };\n\n  var clone = function clone() {\n    var namesClone = cloneNames(names);\n    var markersClone = Object.create(null);\n\n    // eslint-disable-next-line guard-for-in\n    for (var id in markers) {\n      markersClone[id] = [markers[id][0]];\n    }\n\n    return makeServerTag(namesClone, markersClone);\n  };\n\n  var tag = {\n    clone: clone,\n    css: css,\n    getIds: getIdsFromMarkersFactory(markers),\n    hasNameForId: hasNameForId(names),\n    insertMarker: insertMarker,\n    insertRules: insertRules,\n    removeRules: removeRules,\n    sealed: false,\n    styleTag: null,\n    toElement: wrapAsElement(css, names),\n    toHTML: wrapAsHtmlTag(css, names)\n  };\n\n  return tag;\n};\n\nvar makeTag = function makeTag(target, tagEl, forceServer, insertBefore, getImportRuleTag) {\n  if (IS_BROWSER && !forceServer) {\n    var el = makeStyleTag(target, tagEl, insertBefore);\n\n    if (DISABLE_SPEEDY) {\n      return makeBrowserTag(el, getImportRuleTag);\n    } else {\n      return makeSpeedyTag(el, getImportRuleTag);\n    }\n  }\n\n  return makeServerTag();\n};\n\nvar rehydrate = function rehydrate(tag, els, extracted) {\n  /* add all extracted components to the new tag */\n  for (var i = 0, len = extracted.length; i < len; i += 1) {\n    var _extracted$i = extracted[i],\n        componentId = _extracted$i.componentId,\n        cssFromDOM = _extracted$i.cssFromDOM;\n\n    var cssRules = splitByRules(cssFromDOM);\n    tag.insertRules(componentId, cssRules);\n  }\n\n  /* remove old HTMLStyleElements, since they have been rehydrated */\n  for (var _i = 0, _len = els.length; _i < _len; _i += 1) {\n    var el = els[_i];\n    if (el.parentNode) {\n      el.parentNode.removeChild(el);\n    }\n  }\n};\n\n// \n\nvar SPLIT_REGEX = /\\s+/;\n\n/* determine the maximum number of components before tags are sharded */\nvar MAX_SIZE = void 0;\nif (IS_BROWSER) {\n  /* in speedy mode we can keep a lot more rules in a sheet before a slowdown can be expected */\n  MAX_SIZE = DISABLE_SPEEDY ? 40 : 1000;\n} else {\n  /* for servers we do not need to shard at all */\n  MAX_SIZE = -1;\n}\n\nvar sheetRunningId = 0;\nvar master = void 0;\n\nvar StyleSheet = function () {\n\n  /* a map from ids to tags */\n\n  /* deferred rules for a given id */\n\n  /* this is used for not reinjecting rules via hasNameForId() */\n\n  /* when rules for an id are removed using remove() we have to ignore rehydratedNames for it */\n\n  /* a list of tags belonging to this StyleSheet */\n\n  /* a tag for import rules */\n\n  /* current capacity until a new tag must be created */\n\n  /* children (aka clones) of this StyleSheet inheriting all and future injections */\n\n  function StyleSheet() {\n    var _this = this;\n\n    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : IS_BROWSER ? document.head : null;\n    var forceServer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    classCallCheck(this, StyleSheet);\n\n    this.getImportRuleTag = function () {\n      var importRuleTag = _this.importRuleTag;\n\n      if (importRuleTag !== undefined) {\n        return importRuleTag;\n      }\n\n      var firstTag = _this.tags[0];\n      var insertBefore = true;\n\n      return _this.importRuleTag = makeTag(_this.target, firstTag ? firstTag.styleTag : null, _this.forceServer, insertBefore);\n    };\n\n    sheetRunningId += 1;\n    this.id = sheetRunningId;\n    this.forceServer = forceServer;\n    this.target = forceServer ? null : target;\n    this.tagMap = {};\n    this.deferred = {};\n    this.rehydratedNames = {};\n    this.ignoreRehydratedNames = {};\n    this.tags = [];\n    this.capacity = 1;\n    this.clones = [];\n  }\n\n  /* rehydrate all SSR'd style tags */\n\n\n  StyleSheet.prototype.rehydrate = function rehydrate$$1() {\n    if (!IS_BROWSER || this.forceServer) return this;\n\n    var els = [];\n    var extracted = [];\n    var isStreamed = false;\n\n    /* retrieve all of our SSR style elements from the DOM */\n    var nodes = document.querySelectorAll('style[' + SC_ATTR + '][' + SC_VERSION_ATTR + '=\"' + \"4.4.1\" + '\"]');\n\n    var nodesSize = nodes.length;\n\n    /* abort rehydration if no previous style tags were found */\n    if (!nodesSize) return this;\n\n    for (var i = 0; i < nodesSize; i += 1) {\n      var el = nodes[i];\n\n      /* check if style tag is a streamed tag */\n      if (!isStreamed) isStreamed = !!el.getAttribute(SC_STREAM_ATTR);\n\n      /* retrieve all component names */\n      var elNames = (el.getAttribute(SC_ATTR) || '').trim().split(SPLIT_REGEX);\n      var elNamesSize = elNames.length;\n      for (var j = 0, name; j < elNamesSize; j += 1) {\n        name = elNames[j];\n        /* add rehydrated name to sheet to avoid re-adding styles */\n        this.rehydratedNames[name] = true;\n      }\n\n      /* extract all components and their CSS */\n      extracted.push.apply(extracted, extractComps(el.textContent));\n\n      /* store original HTMLStyleElement */\n      els.push(el);\n    }\n\n    /* abort rehydration if nothing was extracted */\n    var extractedSize = extracted.length;\n    if (!extractedSize) return this;\n\n    /* create a tag to be used for rehydration */\n    var tag = this.makeTag(null);\n\n    rehydrate(tag, els, extracted);\n\n    /* reset capacity and adjust MAX_SIZE by the initial size of the rehydration */\n    this.capacity = Math.max(1, MAX_SIZE - extractedSize);\n    this.tags.push(tag);\n\n    /* retrieve all component ids */\n    for (var _j = 0; _j < extractedSize; _j += 1) {\n      this.tagMap[extracted[_j].componentId] = tag;\n    }\n\n    return this;\n  };\n\n  /* retrieve a \"master\" instance of StyleSheet which is typically used when no other is available\n   * The master StyleSheet is targeted by createGlobalStyle, keyframes, and components outside of any\n    * StyleSheetManager's context */\n\n\n  /* reset the internal \"master\" instance */\n  StyleSheet.reset = function reset() {\n    var forceServer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    master = new StyleSheet(undefined, forceServer).rehydrate();\n  };\n\n  /* adds \"children\" to the StyleSheet that inherit all of the parents' rules\n   * while their own rules do not affect the parent */\n\n\n  StyleSheet.prototype.clone = function clone() {\n    var sheet = new StyleSheet(this.target, this.forceServer);\n\n    /* add to clone array */\n    this.clones.push(sheet);\n\n    /* clone all tags */\n    sheet.tags = this.tags.map(function (tag) {\n      var ids = tag.getIds();\n      var newTag = tag.clone();\n\n      /* reconstruct tagMap */\n      for (var i = 0; i < ids.length; i += 1) {\n        sheet.tagMap[ids[i]] = newTag;\n      }\n\n      return newTag;\n    });\n\n    /* clone other maps */\n    sheet.rehydratedNames = _extends({}, this.rehydratedNames);\n    sheet.deferred = _extends({}, this.deferred);\n\n    return sheet;\n  };\n\n  /* force StyleSheet to create a new tag on the next injection */\n\n\n  StyleSheet.prototype.sealAllTags = function sealAllTags() {\n    this.capacity = 1;\n\n    this.tags.forEach(function (tag) {\n      // eslint-disable-next-line no-param-reassign\n      tag.sealed = true;\n    });\n  };\n\n  StyleSheet.prototype.makeTag = function makeTag$$1(tag) {\n    var lastEl = tag ? tag.styleTag : null;\n    var insertBefore = false;\n\n    return makeTag(this.target, lastEl, this.forceServer, insertBefore, this.getImportRuleTag);\n  };\n\n  /* get a tag for a given componentId, assign the componentId to one, or shard */\n  StyleSheet.prototype.getTagForId = function getTagForId(id) {\n    /* simply return a tag, when the componentId was already assigned one */\n    var prev = this.tagMap[id];\n    if (prev !== undefined && !prev.sealed) {\n      return prev;\n    }\n\n    var tag = this.tags[this.tags.length - 1];\n\n    /* shard (create a new tag) if the tag is exhausted (See MAX_SIZE) */\n    this.capacity -= 1;\n\n    if (this.capacity === 0) {\n      this.capacity = MAX_SIZE;\n      tag = this.makeTag(tag);\n      this.tags.push(tag);\n    }\n\n    return this.tagMap[id] = tag;\n  };\n\n  /* mainly for createGlobalStyle to check for its id */\n\n\n  StyleSheet.prototype.hasId = function hasId(id) {\n    return this.tagMap[id] !== undefined;\n  };\n\n  /* caching layer checking id+name to already have a corresponding tag and injected rules */\n\n\n  StyleSheet.prototype.hasNameForId = function hasNameForId(id, name) {\n    /* exception for rehydrated names which are checked separately */\n    if (this.ignoreRehydratedNames[id] === undefined && this.rehydratedNames[name]) {\n      return true;\n    }\n\n    var tag = this.tagMap[id];\n    return tag !== undefined && tag.hasNameForId(id, name);\n  };\n\n  /* registers a componentId and registers it on its tag */\n\n\n  StyleSheet.prototype.deferredInject = function deferredInject(id, cssRules) {\n    /* don't inject when the id is already registered */\n    if (this.tagMap[id] !== undefined) return;\n\n    var clones = this.clones;\n\n    for (var i = 0; i < clones.length; i += 1) {\n      clones[i].deferredInject(id, cssRules);\n    }\n\n    this.getTagForId(id).insertMarker(id);\n    this.deferred[id] = cssRules;\n  };\n\n  /* injects rules for a given id with a name that will need to be cached */\n\n\n  StyleSheet.prototype.inject = function inject(id, cssRules, name) {\n    var clones = this.clones;\n\n\n    for (var i = 0; i < clones.length; i += 1) {\n      clones[i].inject(id, cssRules, name);\n    }\n\n    var tag = this.getTagForId(id);\n\n    /* add deferred rules for component */\n    if (this.deferred[id] !== undefined) {\n      // Combine passed cssRules with previously deferred CSS rules\n      // NOTE: We cannot mutate the deferred array itself as all clones\n      // do the same (see clones[i].inject)\n      var rules = this.deferred[id].concat(cssRules);\n      tag.insertRules(id, rules, name);\n\n      this.deferred[id] = undefined;\n    } else {\n      tag.insertRules(id, cssRules, name);\n    }\n  };\n\n  /* removes all rules for a given id, which doesn't remove its marker but resets it */\n\n\n  StyleSheet.prototype.remove = function remove(id) {\n    var tag = this.tagMap[id];\n    if (tag === undefined) return;\n\n    var clones = this.clones;\n\n    for (var i = 0; i < clones.length; i += 1) {\n      clones[i].remove(id);\n    }\n\n    /* remove all rules from the tag */\n    tag.removeRules(id);\n\n    /* ignore possible rehydrated names */\n    this.ignoreRehydratedNames[id] = true;\n\n    /* delete possible deferred rules */\n    this.deferred[id] = undefined;\n  };\n\n  StyleSheet.prototype.toHTML = function toHTML() {\n    return this.tags.map(function (tag) {\n      return tag.toHTML();\n    }).join('');\n  };\n\n  StyleSheet.prototype.toReactElements = function toReactElements() {\n    var id = this.id;\n\n\n    return this.tags.map(function (tag, i) {\n      var key = 'sc-' + id + '-' + i;\n      return Object(react__WEBPACK_IMPORTED_MODULE_2__[\"cloneElement\"])(tag.toElement(), { key: key });\n    });\n  };\n\n  createClass(StyleSheet, null, [{\n    key: 'master',\n    get: function get$$1() {\n      return master || (master = new StyleSheet().rehydrate());\n    }\n\n    /* NOTE: This is just for backwards-compatibility with jest-styled-components */\n\n  }, {\n    key: 'instance',\n    get: function get$$1() {\n      return StyleSheet.master;\n    }\n  }]);\n  return StyleSheet;\n}();\n\n// \n\nvar Keyframes = function () {\n  function Keyframes(name, rules) {\n    var _this = this;\n\n    classCallCheck(this, Keyframes);\n\n    this.inject = function (styleSheet) {\n      if (!styleSheet.hasNameForId(_this.id, _this.name)) {\n        styleSheet.inject(_this.id, _this.rules, _this.name);\n      }\n    };\n\n    this.toString = function () {\n      throw new StyledComponentsError(12, String(_this.name));\n    };\n\n    this.name = name;\n    this.rules = rules;\n\n    this.id = 'sc-keyframes-' + name;\n  }\n\n  Keyframes.prototype.getName = function getName() {\n    return this.name;\n  };\n\n  return Keyframes;\n}();\n\n// \n\n/**\n * inlined version of\n * https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/hyphenateStyleName.js\n */\n\nvar uppercasePattern = /([A-Z])/g;\nvar msPattern = /^ms-/;\n\n/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenateStyleName(string) {\n  return string.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');\n}\n\n// \n\n// Taken from https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-dom/src/shared/dangerousStyleValue.js\nfunction addUnitIfNeeded(name, value) {\n  // https://github.com/amilajack/eslint-plugin-flowtype-errors/issues/133\n  // $FlowFixMe\n  if (value == null || typeof value === 'boolean' || value === '') {\n    return '';\n  }\n\n  if (typeof value === 'number' && value !== 0 && !(name in _emotion_unitless__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])) {\n    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n  }\n\n  return String(value).trim();\n}\n\n// \n\n/**\n * It's falsish not falsy because 0 is allowed.\n */\nvar isFalsish = function isFalsish(chunk) {\n  return chunk === undefined || chunk === null || chunk === false || chunk === '';\n};\n\nvar objToCssArray = function objToCssArray(obj, prevKey) {\n  var rules = [];\n  var keys = Object.keys(obj);\n\n  keys.forEach(function (key) {\n    if (!isFalsish(obj[key])) {\n      if (isPlainObject(obj[key])) {\n        rules.push.apply(rules, objToCssArray(obj[key], key));\n\n        return rules;\n      } else if (isFunction(obj[key])) {\n        rules.push(hyphenateStyleName(key) + ':', obj[key], ';');\n\n        return rules;\n      }\n      rules.push(hyphenateStyleName(key) + ': ' + addUnitIfNeeded(key, obj[key]) + ';');\n    }\n    return rules;\n  });\n\n  return prevKey ? [prevKey + ' {'].concat(rules, ['}']) : rules;\n};\n\nfunction flatten(chunk, executionContext, styleSheet) {\n  if (Array.isArray(chunk)) {\n    var ruleSet = [];\n\n    for (var i = 0, len = chunk.length, result; i < len; i += 1) {\n      result = flatten(chunk[i], executionContext, styleSheet);\n\n      if (result === null) continue;else if (Array.isArray(result)) ruleSet.push.apply(ruleSet, result);else ruleSet.push(result);\n    }\n\n    return ruleSet;\n  }\n\n  if (isFalsish(chunk)) {\n    return null;\n  }\n\n  /* Handle other components */\n  if (isStyledComponent(chunk)) {\n    return '.' + chunk.styledComponentId;\n  }\n\n  /* Either execute or defer the function */\n  if (isFunction(chunk)) {\n    if (isStatelessFunction(chunk) && executionContext) {\n      var _result = chunk(executionContext);\n\n      if (false) {}\n\n      return flatten(_result, executionContext, styleSheet);\n    } else return chunk;\n  }\n\n  if (chunk instanceof Keyframes) {\n    if (styleSheet) {\n      chunk.inject(styleSheet);\n      return chunk.getName();\n    } else return chunk;\n  }\n\n  /* Handle objects */\n  return isPlainObject(chunk) ? objToCssArray(chunk) : chunk.toString();\n}\n\n// \n\nfunction css(styles) {\n  for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    interpolations[_key - 1] = arguments[_key];\n  }\n\n  if (isFunction(styles) || isPlainObject(styles)) {\n    // $FlowFixMe\n    return flatten(interleave(EMPTY_ARRAY, [styles].concat(interpolations)));\n  }\n\n  // $FlowFixMe\n  return flatten(interleave(styles, interpolations));\n}\n\n// \n\nfunction constructWithOptions(componentConstructor, tag) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT;\n\n  if (!Object(react_is__WEBPACK_IMPORTED_MODULE_4__[\"isValidElementType\"])(tag)) {\n    throw new StyledComponentsError(1, String(tag));\n  }\n\n  /* This is callable directly as a template function */\n  // $FlowFixMe: Not typed to avoid destructuring arguments\n  var templateFunction = function templateFunction() {\n    return componentConstructor(tag, options, css.apply(undefined, arguments));\n  };\n\n  /* If config methods are called, wrap up a new template function and merge options */\n  templateFunction.withConfig = function (config) {\n    return constructWithOptions(componentConstructor, tag, _extends({}, options, config));\n  };\n\n  /* Modify/inject new props at runtime */\n  templateFunction.attrs = function (attrs) {\n    return constructWithOptions(componentConstructor, tag, _extends({}, options, {\n      attrs: Array.prototype.concat(options.attrs, attrs).filter(Boolean)\n    }));\n  };\n\n  return templateFunction;\n}\n\n// \n// Source: https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js\nfunction murmurhash(c) {\n  for (var e = c.length | 0, a = e | 0, d = 0, b; e >= 4;) {\n    b = c.charCodeAt(d) & 255 | (c.charCodeAt(++d) & 255) << 8 | (c.charCodeAt(++d) & 255) << 16 | (c.charCodeAt(++d) & 255) << 24, b = 1540483477 * (b & 65535) + ((1540483477 * (b >>> 16) & 65535) << 16), b ^= b >>> 24, b = 1540483477 * (b & 65535) + ((1540483477 * (b >>> 16) & 65535) << 16), a = 1540483477 * (a & 65535) + ((1540483477 * (a >>> 16) & 65535) << 16) ^ b, e -= 4, ++d;\n  }\n  switch (e) {\n    case 3:\n      a ^= (c.charCodeAt(d + 2) & 255) << 16;\n    case 2:\n      a ^= (c.charCodeAt(d + 1) & 255) << 8;\n    case 1:\n      a ^= c.charCodeAt(d) & 255, a = 1540483477 * (a & 65535) + ((1540483477 * (a >>> 16) & 65535) << 16);\n  }\n  a ^= a >>> 13;\n  a = 1540483477 * (a & 65535) + ((1540483477 * (a >>> 16) & 65535) << 16);\n  return (a ^ a >>> 15) >>> 0;\n}\n\n// \n/* eslint-disable no-bitwise */\n\n/* This is the \"capacity\" of our alphabet i.e. 2x26 for all letters plus their capitalised\n * counterparts */\nvar charsLength = 52;\n\n/* start at 75 for 'a' until 'z' (25) and then start at 65 for capitalised letters */\nvar getAlphabeticChar = function getAlphabeticChar(code) {\n  return String.fromCharCode(code + (code > 25 ? 39 : 97));\n};\n\n/* input a number, usually a hash and convert it to base-52 */\nfunction generateAlphabeticName(code) {\n  var name = '';\n  var x = void 0;\n\n  /* get a char and divide by alphabet-length */\n  for (x = code; x > charsLength; x = Math.floor(x / charsLength)) {\n    name = getAlphabeticChar(x % charsLength) + name;\n  }\n\n  return getAlphabeticChar(x % charsLength) + name;\n}\n\n// \n\nfunction hasFunctionObjectKey(obj) {\n  // eslint-disable-next-line guard-for-in, no-restricted-syntax\n  for (var key in obj) {\n    if (isFunction(obj[key])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isStaticRules(rules, attrs) {\n  for (var i = 0; i < rules.length; i += 1) {\n    var rule = rules[i];\n\n    // recursive case\n    if (Array.isArray(rule) && !isStaticRules(rule, attrs)) {\n      return false;\n    } else if (isFunction(rule) && !isStyledComponent(rule)) {\n      // functions are allowed to be static if they're just being\n      // used to get the classname of a nested styled component\n      return false;\n    }\n  }\n\n  if (attrs.some(function (x) {\n    return isFunction(x) || hasFunctionObjectKey(x);\n  })) return false;\n\n  return true;\n}\n\n// \n\n/* combines hashStr (murmurhash) and nameGenerator for convenience */\nvar hasher = function hasher(str) {\n  return generateAlphabeticName(murmurhash(str));\n};\n\n/*\n ComponentStyle is all the CSS-specific stuff, not\n the React-specific stuff.\n */\n\nvar ComponentStyle = function () {\n  function ComponentStyle(rules, attrs, componentId) {\n    classCallCheck(this, ComponentStyle);\n\n    this.rules = rules;\n    this.isStatic =  true && isStaticRules(rules, attrs);\n    this.componentId = componentId;\n\n    if (!StyleSheet.master.hasId(componentId)) {\n      StyleSheet.master.deferredInject(componentId, []);\n    }\n  }\n\n  /*\n   * Flattens a rule set into valid CSS\n   * Hashes it, wraps the whole chunk in a .hash1234 {}\n   * Returns the hash to be injected on render()\n   * */\n\n\n  ComponentStyle.prototype.generateAndInjectStyles = function generateAndInjectStyles(executionContext, styleSheet) {\n    var isStatic = this.isStatic,\n        componentId = this.componentId,\n        lastClassName = this.lastClassName;\n\n    if (IS_BROWSER && isStatic && typeof lastClassName === 'string' && styleSheet.hasNameForId(componentId, lastClassName)) {\n      return lastClassName;\n    }\n\n    var flatCSS = flatten(this.rules, executionContext, styleSheet);\n    var name = hasher(this.componentId + flatCSS.join(''));\n    if (!styleSheet.hasNameForId(componentId, name)) {\n      styleSheet.inject(this.componentId, stringifyRules(flatCSS, '.' + name, undefined, componentId), name);\n    }\n\n    this.lastClassName = name;\n    return name;\n  };\n\n  ComponentStyle.generateName = function generateName(str) {\n    return hasher(str);\n  };\n\n  return ComponentStyle;\n}();\n\n// \n\nvar LIMIT = 200;\n\nvar createWarnTooManyClasses = (function (displayName) {\n  var generatedClasses = {};\n  var warningSeen = false;\n\n  return function (className) {\n    if (!warningSeen) {\n      generatedClasses[className] = true;\n      if (Object.keys(generatedClasses).length >= LIMIT) {\n        // Unable to find latestRule in test environment.\n        /* eslint-disable no-console, prefer-template */\n        console.warn('Over ' + LIMIT + ' classes were generated for component ' + displayName + '. \\n' + 'Consider using the attrs method, together with a style object for frequently changed styles.\\n' + 'Example:\\n' + '  const Component = styled.div.attrs(props => ({\\n' + '    style: {\\n' + '      background: props.background,\\n' + '    },\\n' + '  }))`width: 100%;`\\n\\n' + '  <Component />');\n        warningSeen = true;\n        generatedClasses = {};\n      }\n    }\n  };\n});\n\n// \n\nvar determineTheme = (function (props, fallbackTheme) {\n  var defaultProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT;\n\n  // Props should take precedence over ThemeProvider, which should take precedence over\n  // defaultProps, but React automatically puts defaultProps on props.\n\n  /* eslint-disable react/prop-types, flowtype-errors/show-errors */\n  var isDefaultTheme = defaultProps ? props.theme === defaultProps.theme : false;\n  var theme = props.theme && !isDefaultTheme ? props.theme : fallbackTheme || defaultProps.theme;\n  /* eslint-enable */\n\n  return theme;\n});\n\n// \nvar escapeRegex = /[[\\].#*$><+~=|^:(),\"'`-]+/g;\nvar dashesAtEnds = /(^-|-$)/g;\n\n/**\n * TODO: Explore using CSS.escape when it becomes more available\n * in evergreen browsers.\n */\nfunction escape(str) {\n  return str\n  // Replace all possible CSS selectors\n  .replace(escapeRegex, '-')\n\n  // Remove extraneous hyphens at the start and end\n  .replace(dashesAtEnds, '');\n}\n\n// \n\nfunction isTag(target) {\n  return typeof target === 'string' && ( false ? undefined : true);\n}\n\n// \n\nfunction generateDisplayName(target) {\n  // $FlowFixMe\n  return isTag(target) ? 'styled.' + target : 'Styled(' + getComponentName(target) + ')';\n}\n\nvar _TYPE_STATICS;\n\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDerivedStateFromProps: true,\n  propTypes: true,\n  type: true\n};\n\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\n\nvar TYPE_STATICS = (_TYPE_STATICS = {}, _TYPE_STATICS[react_is__WEBPACK_IMPORTED_MODULE_4__[\"ForwardRef\"]] = {\n  $$typeof: true,\n  render: true\n}, _TYPE_STATICS);\n\nvar defineProperty$1 = Object.defineProperty,\n    getOwnPropertyNames = Object.getOwnPropertyNames,\n    _Object$getOwnPropert = Object.getOwnPropertySymbols,\n    getOwnPropertySymbols = _Object$getOwnPropert === undefined ? function () {\n  return [];\n} : _Object$getOwnPropert,\n    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n    getPrototypeOf = Object.getPrototypeOf,\n    objectPrototype = Object.prototype;\nvar arrayPrototype = Array.prototype;\n\n\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n\n    var inheritedComponent = getPrototypeOf(sourceComponent);\n\n    if (inheritedComponent && inheritedComponent !== objectPrototype) {\n      hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n    }\n\n    var keys = arrayPrototype.concat(getOwnPropertyNames(sourceComponent),\n    // $FlowFixMe\n    getOwnPropertySymbols(sourceComponent));\n\n    var targetStatics = TYPE_STATICS[targetComponent.$$typeof] || REACT_STATICS;\n\n    var sourceStatics = TYPE_STATICS[sourceComponent.$$typeof] || REACT_STATICS;\n\n    var i = keys.length;\n    var descriptor = void 0;\n    var key = void 0;\n\n    // eslint-disable-next-line no-plusplus\n    while (i--) {\n      key = keys[i];\n\n      if (\n      // $FlowFixMe\n      !KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) &&\n      // $FlowFixMe\n      !(targetStatics && targetStatics[key])) {\n        descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n        if (descriptor) {\n          try {\n            // Avoid failures from read-only properties\n            defineProperty$1(targetComponent, key, descriptor);\n          } catch (e) {\n            /* fail silently */\n          }\n        }\n      }\n    }\n\n    return targetComponent;\n  }\n\n  return targetComponent;\n}\n\n// \nfunction isDerivedReactComponent(fn) {\n  return !!(fn && fn.prototype && fn.prototype.isReactComponent);\n}\n\n// \n// Helper to call a given function, only once\nvar once = (function (cb) {\n  var called = false;\n\n  return function () {\n    if (!called) {\n      called = true;\n      cb.apply(undefined, arguments);\n    }\n  };\n});\n\n// \n\nvar ThemeContext = Object(react__WEBPACK_IMPORTED_MODULE_2__[\"createContext\"])();\n\nvar ThemeConsumer = ThemeContext.Consumer;\n\n/**\n * Provide a theme to an entire react component tree via context\n */\n\nvar ThemeProvider = function (_Component) {\n  inherits(ThemeProvider, _Component);\n\n  function ThemeProvider(props) {\n    classCallCheck(this, ThemeProvider);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, props));\n\n    _this.getContext = Object(memoize_one__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"])(_this.getContext.bind(_this));\n    _this.renderInner = _this.renderInner.bind(_this);\n    return _this;\n  }\n\n  ThemeProvider.prototype.render = function render() {\n    if (!this.props.children) return null;\n\n    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(\n      ThemeContext.Consumer,\n      null,\n      this.renderInner\n    );\n  };\n\n  ThemeProvider.prototype.renderInner = function renderInner(outerTheme) {\n    var context = this.getContext(this.props.theme, outerTheme);\n\n    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(\n      ThemeContext.Provider,\n      { value: context },\n      this.props.children\n    );\n  };\n\n  /**\n   * Get the theme from the props, supporting both (outerTheme) => {}\n   * as well as object notation\n   */\n\n\n  ThemeProvider.prototype.getTheme = function getTheme(theme, outerTheme) {\n    if (isFunction(theme)) {\n      var mergedTheme = theme(outerTheme);\n\n      if (false) {}\n\n      return mergedTheme;\n    }\n\n    if (theme === null || Array.isArray(theme) || (typeof theme === 'undefined' ? 'undefined' : _typeof(theme)) !== 'object') {\n      throw new StyledComponentsError(8);\n    }\n\n    return _extends({}, outerTheme, theme);\n  };\n\n  ThemeProvider.prototype.getContext = function getContext(theme, outerTheme) {\n    return this.getTheme(theme, outerTheme);\n  };\n\n  return ThemeProvider;\n}(react__WEBPACK_IMPORTED_MODULE_2__[\"Component\"]);\n\n// \n\nvar CLOSING_TAG_R = /^\\s*<\\/[a-z]/i;\n\nvar ServerStyleSheet = function () {\n  function ServerStyleSheet() {\n    classCallCheck(this, ServerStyleSheet);\n\n    /* The master sheet might be reset, so keep a reference here */\n    this.masterSheet = StyleSheet.master;\n    this.instance = this.masterSheet.clone();\n    this.sealed = false;\n  }\n\n  /**\n   * Mark the ServerStyleSheet as being fully emitted and manually GC it from the\n   * StyleSheet singleton.\n   */\n\n\n  ServerStyleSheet.prototype.seal = function seal() {\n    if (!this.sealed) {\n      /* Remove sealed StyleSheets from the master sheet */\n      var index = this.masterSheet.clones.indexOf(this.instance);\n      this.masterSheet.clones.splice(index, 1);\n      this.sealed = true;\n    }\n  };\n\n  ServerStyleSheet.prototype.collectStyles = function collectStyles(children) {\n    if (this.sealed) {\n      throw new StyledComponentsError(2);\n    }\n\n    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(\n      StyleSheetManager,\n      { sheet: this.instance },\n      children\n    );\n  };\n\n  ServerStyleSheet.prototype.getStyleTags = function getStyleTags() {\n    this.seal();\n    return this.instance.toHTML();\n  };\n\n  ServerStyleSheet.prototype.getStyleElement = function getStyleElement() {\n    this.seal();\n    return this.instance.toReactElements();\n  };\n\n  ServerStyleSheet.prototype.interleaveWithNodeStream = function interleaveWithNodeStream(readableStream) {\n    var _this = this;\n\n    {\n      throw new StyledComponentsError(3);\n    }\n\n    /* the tag index keeps track of which tags have already been emitted */\n    var instance = this.instance;\n\n    var instanceTagIndex = 0;\n\n    var streamAttr = SC_STREAM_ATTR + '=\"true\"';\n\n    var transformer = new stream.Transform({\n      transform: function appendStyleChunks(chunk, /* encoding */_, callback) {\n        var tags = instance.tags;\n\n        var html = '';\n\n        /* retrieve html for each new style tag */\n        for (; instanceTagIndex < tags.length; instanceTagIndex += 1) {\n          var tag = tags[instanceTagIndex];\n          html += tag.toHTML(streamAttr);\n        }\n\n        /* force our StyleSheets to emit entirely new tags */\n        instance.sealAllTags();\n\n        var renderedHtml = chunk.toString();\n\n        /* prepend style html to chunk, unless the start of the chunk is a closing tag in which case append right after that */\n        if (CLOSING_TAG_R.test(renderedHtml)) {\n          var endOfClosingTag = renderedHtml.indexOf('>');\n\n          this.push(renderedHtml.slice(0, endOfClosingTag + 1) + html + renderedHtml.slice(endOfClosingTag + 1));\n        } else this.push(html + renderedHtml);\n\n        callback();\n      }\n    });\n\n    readableStream.on('end', function () {\n      return _this.seal();\n    });\n\n    readableStream.on('error', function (err) {\n      _this.seal();\n\n      // forward the error to the transform stream\n      transformer.emit('error', err);\n    });\n\n    return readableStream.pipe(transformer);\n  };\n\n  return ServerStyleSheet;\n}();\n\n// \n\nvar StyleSheetContext = Object(react__WEBPACK_IMPORTED_MODULE_2__[\"createContext\"])();\nvar StyleSheetConsumer = StyleSheetContext.Consumer;\n\nvar StyleSheetManager = function (_Component) {\n  inherits(StyleSheetManager, _Component);\n\n  function StyleSheetManager(props) {\n    classCallCheck(this, StyleSheetManager);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, props));\n\n    _this.getContext = Object(memoize_one__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"])(_this.getContext);\n    return _this;\n  }\n\n  StyleSheetManager.prototype.getContext = function getContext(sheet, target) {\n    if (sheet) {\n      return sheet;\n    } else if (target) {\n      return new StyleSheet(target);\n    } else {\n      throw new StyledComponentsError(4);\n    }\n  };\n\n  StyleSheetManager.prototype.render = function render() {\n    var _props = this.props,\n        children = _props.children,\n        sheet = _props.sheet,\n        target = _props.target;\n\n\n    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(\n      StyleSheetContext.Provider,\n      { value: this.getContext(sheet, target) },\n       false ? undefined : children\n    );\n  };\n\n  return StyleSheetManager;\n}(react__WEBPACK_IMPORTED_MODULE_2__[\"Component\"]);\n false ? undefined : void 0;\n\n// \n\nvar identifiers = {};\n\n/* We depend on components having unique IDs */\nfunction generateId(_ComponentStyle, _displayName, parentComponentId) {\n  var displayName = typeof _displayName !== 'string' ? 'sc' : escape(_displayName);\n\n  /**\n   * This ensures uniqueness if two components happen to share\n   * the same displayName.\n   */\n  var nr = (identifiers[displayName] || 0) + 1;\n  identifiers[displayName] = nr;\n\n  var componentId = displayName + '-' + _ComponentStyle.generateName(displayName + nr);\n\n  return parentComponentId ? parentComponentId + '-' + componentId : componentId;\n}\n\n// $FlowFixMe\n\nvar StyledComponent = function (_Component) {\n  inherits(StyledComponent, _Component);\n\n  function StyledComponent() {\n    classCallCheck(this, StyledComponent);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this));\n\n    _this.attrs = {};\n\n    _this.renderOuter = _this.renderOuter.bind(_this);\n    _this.renderInner = _this.renderInner.bind(_this);\n\n    if (false) {}\n    return _this;\n  }\n\n  StyledComponent.prototype.render = function render() {\n    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(\n      StyleSheetConsumer,\n      null,\n      this.renderOuter\n    );\n  };\n\n  StyledComponent.prototype.renderOuter = function renderOuter() {\n    var styleSheet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : StyleSheet.master;\n\n    this.styleSheet = styleSheet;\n\n    // No need to subscribe a static component to theme changes, it won't change anything\n    if (this.props.forwardedComponent.componentStyle.isStatic) return this.renderInner();\n\n    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(\n      ThemeConsumer,\n      null,\n      this.renderInner\n    );\n  };\n\n  StyledComponent.prototype.renderInner = function renderInner(theme) {\n    var _props$forwardedCompo = this.props.forwardedComponent,\n        componentStyle = _props$forwardedCompo.componentStyle,\n        defaultProps = _props$forwardedCompo.defaultProps,\n        displayName = _props$forwardedCompo.displayName,\n        foldedComponentIds = _props$forwardedCompo.foldedComponentIds,\n        styledComponentId = _props$forwardedCompo.styledComponentId,\n        target = _props$forwardedCompo.target;\n\n\n    var generatedClassName = void 0;\n    if (componentStyle.isStatic) {\n      generatedClassName = this.generateAndInjectStyles(EMPTY_OBJECT, this.props);\n    } else {\n      generatedClassName = this.generateAndInjectStyles(determineTheme(this.props, theme, defaultProps) || EMPTY_OBJECT, this.props);\n    }\n\n    var elementToBeCreated = this.props.as || this.attrs.as || target;\n    var isTargetTag = isTag(elementToBeCreated);\n\n    var propsForElement = {};\n    var computedProps = _extends({}, this.props, this.attrs);\n\n    var key = void 0;\n    // eslint-disable-next-line guard-for-in\n    for (key in computedProps) {\n      if (false) {}\n\n      if (key === 'forwardedComponent' || key === 'as') {\n        continue;\n      } else if (key === 'forwardedRef') propsForElement.ref = computedProps[key];else if (key === 'forwardedAs') propsForElement.as = computedProps[key];else if (!isTargetTag || Object(_emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"])(key)) {\n        // Don't pass through non HTML tags through to HTML elements\n        propsForElement[key] = computedProps[key];\n      }\n    }\n\n    if (this.props.style && this.attrs.style) {\n      propsForElement.style = _extends({}, this.attrs.style, this.props.style);\n    }\n\n    propsForElement.className = Array.prototype.concat(foldedComponentIds, styledComponentId, generatedClassName !== styledComponentId ? generatedClassName : null, this.props.className, this.attrs.className).filter(Boolean).join(' ');\n\n    return Object(react__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(elementToBeCreated, propsForElement);\n  };\n\n  StyledComponent.prototype.buildExecutionContext = function buildExecutionContext(theme, props, attrs) {\n    var _this2 = this;\n\n    var context = _extends({}, props, { theme: theme });\n\n    if (!attrs.length) return context;\n\n    this.attrs = {};\n\n    attrs.forEach(function (attrDef) {\n      var resolvedAttrDef = attrDef;\n      var attrDefWasFn = false;\n      var attr = void 0;\n      var key = void 0;\n\n      if (isFunction(resolvedAttrDef)) {\n        // $FlowFixMe\n        resolvedAttrDef = resolvedAttrDef(context);\n        attrDefWasFn = true;\n      }\n\n      /* eslint-disable guard-for-in */\n      // $FlowFixMe\n      for (key in resolvedAttrDef) {\n        attr = resolvedAttrDef[key];\n\n        if (!attrDefWasFn) {\n          if (isFunction(attr) && !isDerivedReactComponent(attr) && !isStyledComponent(attr)) {\n            if (false) {}\n\n            attr = attr(context);\n\n            if (false) {}\n          }\n        }\n\n        _this2.attrs[key] = attr;\n        context[key] = attr;\n      }\n      /* eslint-enable */\n    });\n\n    return context;\n  };\n\n  StyledComponent.prototype.generateAndInjectStyles = function generateAndInjectStyles(theme, props) {\n    var _props$forwardedCompo2 = props.forwardedComponent,\n        attrs = _props$forwardedCompo2.attrs,\n        componentStyle = _props$forwardedCompo2.componentStyle,\n        warnTooManyClasses = _props$forwardedCompo2.warnTooManyClasses;\n\n    // statically styled-components don't need to build an execution context object,\n    // and shouldn't be increasing the number of class names\n\n    if (componentStyle.isStatic && !attrs.length) {\n      return componentStyle.generateAndInjectStyles(EMPTY_OBJECT, this.styleSheet);\n    }\n\n    var className = componentStyle.generateAndInjectStyles(this.buildExecutionContext(theme, props, attrs), this.styleSheet);\n\n    if (false) {}\n\n    return className;\n  };\n\n  return StyledComponent;\n}(react__WEBPACK_IMPORTED_MODULE_2__[\"Component\"]);\n\nfunction createStyledComponent(target, options, rules) {\n  var isTargetStyledComp = isStyledComponent(target);\n  var isClass = !isTag(target);\n\n  var _options$displayName = options.displayName,\n      displayName = _options$displayName === undefined ? generateDisplayName(target) : _options$displayName,\n      _options$componentId = options.componentId,\n      componentId = _options$componentId === undefined ? generateId(ComponentStyle, options.displayName, options.parentComponentId) : _options$componentId,\n      _options$ParentCompon = options.ParentComponent,\n      ParentComponent = _options$ParentCompon === undefined ? StyledComponent : _options$ParentCompon,\n      _options$attrs = options.attrs,\n      attrs = _options$attrs === undefined ? EMPTY_ARRAY : _options$attrs;\n\n\n  var styledComponentId = options.displayName && options.componentId ? escape(options.displayName) + '-' + options.componentId : options.componentId || componentId;\n\n  // fold the underlying StyledComponent attrs up (implicit extend)\n  var finalAttrs =\n  // $FlowFixMe\n  isTargetStyledComp && target.attrs ? Array.prototype.concat(target.attrs, attrs).filter(Boolean) : attrs;\n\n  var componentStyle = new ComponentStyle(isTargetStyledComp ? // fold the underlying StyledComponent rules up (implicit extend)\n  // $FlowFixMe\n  target.componentStyle.rules.concat(rules) : rules, finalAttrs, styledComponentId);\n\n  /**\n   * forwardRef creates a new interim component, which we'll take advantage of\n   * instead of extending ParentComponent to create _another_ interim class\n   */\n  var WrappedStyledComponent = void 0;\n  var forwardRef = function forwardRef(props, ref) {\n    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(ParentComponent, _extends({}, props, { forwardedComponent: WrappedStyledComponent, forwardedRef: ref }));\n  };\n  forwardRef.displayName = displayName;\n  WrappedStyledComponent = react__WEBPACK_IMPORTED_MODULE_2___default.a.forwardRef(forwardRef);\n  WrappedStyledComponent.displayName = displayName;\n\n  // $FlowFixMe\n  WrappedStyledComponent.attrs = finalAttrs;\n  // $FlowFixMe\n  WrappedStyledComponent.componentStyle = componentStyle;\n\n  // $FlowFixMe\n  WrappedStyledComponent.foldedComponentIds = isTargetStyledComp ? // $FlowFixMe\n  Array.prototype.concat(target.foldedComponentIds, target.styledComponentId) : EMPTY_ARRAY;\n\n  // $FlowFixMe\n  WrappedStyledComponent.styledComponentId = styledComponentId;\n\n  // fold the underlying StyledComponent target up since we folded the styles\n  // $FlowFixMe\n  WrappedStyledComponent.target = isTargetStyledComp ? target.target : target;\n\n  // $FlowFixMe\n  WrappedStyledComponent.withComponent = function withComponent(tag) {\n    var previousComponentId = options.componentId,\n        optionsToCopy = objectWithoutProperties(options, ['componentId']);\n\n\n    var newComponentId = previousComponentId && previousComponentId + '-' + (isTag(tag) ? tag : escape(getComponentName(tag)));\n\n    var newOptions = _extends({}, optionsToCopy, {\n      attrs: finalAttrs,\n      componentId: newComponentId,\n      ParentComponent: ParentComponent\n    });\n\n    return createStyledComponent(tag, newOptions, rules);\n  };\n\n  // $FlowFixMe\n  Object.defineProperty(WrappedStyledComponent, 'defaultProps', {\n    get: function get$$1() {\n      return this._foldedDefaultProps;\n    },\n    set: function set$$1(obj) {\n      // $FlowFixMe\n      this._foldedDefaultProps = isTargetStyledComp ? Object(merge_anything__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"])(target.defaultProps, obj) : obj;\n    }\n  });\n\n  if (false) {}\n\n  // $FlowFixMe\n  WrappedStyledComponent.toString = function () {\n    return '.' + WrappedStyledComponent.styledComponentId;\n  };\n\n  if (isClass) {\n    hoistNonReactStatics(WrappedStyledComponent, target, {\n      // all SC-specific things should not be hoisted\n      attrs: true,\n      componentStyle: true,\n      displayName: true,\n      foldedComponentIds: true,\n      styledComponentId: true,\n      target: true,\n      withComponent: true\n    });\n  }\n\n  return WrappedStyledComponent;\n}\n\n// \n// Thanks to ReactDOMFactories for this handy list!\n\nvar domElements = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr',\n\n// SVG\n'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'marker', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];\n\n// \n\nvar styled = function styled(tag) {\n  return constructWithOptions(createStyledComponent, tag);\n};\n\n// Shorthands for all valid HTML Elements\ndomElements.forEach(function (domElement) {\n  styled[domElement] = styled(domElement);\n});\n\n// \n\nvar GlobalStyle = function () {\n  function GlobalStyle(rules, componentId) {\n    classCallCheck(this, GlobalStyle);\n\n    this.rules = rules;\n    this.componentId = componentId;\n    this.isStatic = isStaticRules(rules, EMPTY_ARRAY);\n\n    if (!StyleSheet.master.hasId(componentId)) {\n      StyleSheet.master.deferredInject(componentId, []);\n    }\n  }\n\n  GlobalStyle.prototype.createStyles = function createStyles(executionContext, styleSheet) {\n    var flatCSS = flatten(this.rules, executionContext, styleSheet);\n    var css = stringifyRules(flatCSS, '');\n\n    styleSheet.inject(this.componentId, css);\n  };\n\n  GlobalStyle.prototype.removeStyles = function removeStyles(styleSheet) {\n    var componentId = this.componentId;\n\n    if (styleSheet.hasId(componentId)) {\n      styleSheet.remove(componentId);\n    }\n  };\n\n  // TODO: overwrite in-place instead of remove+create?\n\n\n  GlobalStyle.prototype.renderStyles = function renderStyles(executionContext, styleSheet) {\n    this.removeStyles(styleSheet);\n    this.createStyles(executionContext, styleSheet);\n  };\n\n  return GlobalStyle;\n}();\n\n// \n\n// place our cache into shared context so it'll persist between HMRs\nif (IS_BROWSER) {\n  window.scCGSHMRCache = {};\n}\n\nfunction createGlobalStyle(strings) {\n  for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    interpolations[_key - 1] = arguments[_key];\n  }\n\n  var rules = css.apply(undefined, [strings].concat(interpolations));\n  var id = 'sc-global-' + murmurhash(JSON.stringify(rules));\n  var style = new GlobalStyle(rules, id);\n\n  var GlobalStyleComponent = function (_React$Component) {\n    inherits(GlobalStyleComponent, _React$Component);\n\n    function GlobalStyleComponent(props) {\n      classCallCheck(this, GlobalStyleComponent);\n\n      var _this = possibleConstructorReturn(this, _React$Component.call(this, props));\n\n      var _this$constructor = _this.constructor,\n          globalStyle = _this$constructor.globalStyle,\n          styledComponentId = _this$constructor.styledComponentId;\n\n\n      if (IS_BROWSER) {\n        window.scCGSHMRCache[styledComponentId] = (window.scCGSHMRCache[styledComponentId] || 0) + 1;\n      }\n\n      /**\n       * This fixes HMR compatibility. Don't ask me why, but this combination of\n       * caching the closure variables via statics and then persisting the statics in\n       * state works across HMR where no other combination did. ¯\\_(ツ)_/¯\n       */\n      _this.state = {\n        globalStyle: globalStyle,\n        styledComponentId: styledComponentId\n      };\n      return _this;\n    }\n\n    GlobalStyleComponent.prototype.componentWillUnmount = function componentWillUnmount() {\n      if (window.scCGSHMRCache[this.state.styledComponentId]) {\n        window.scCGSHMRCache[this.state.styledComponentId] -= 1;\n      }\n      /**\n       * Depending on the order \"render\" is called this can cause the styles to be lost\n       * until the next render pass of the remaining instance, which may\n       * not be immediate.\n       */\n      if (window.scCGSHMRCache[this.state.styledComponentId] === 0) {\n        this.state.globalStyle.removeStyles(this.styleSheet);\n      }\n    };\n\n    GlobalStyleComponent.prototype.render = function render() {\n      var _this2 = this;\n\n      if (false) {}\n\n      return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(\n        StyleSheetConsumer,\n        null,\n        function (styleSheet) {\n          _this2.styleSheet = styleSheet || StyleSheet.master;\n\n          var globalStyle = _this2.state.globalStyle;\n\n\n          if (globalStyle.isStatic) {\n            globalStyle.renderStyles(STATIC_EXECUTION_CONTEXT, _this2.styleSheet);\n\n            return null;\n          } else {\n            return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(\n              ThemeConsumer,\n              null,\n              function (theme) {\n                // $FlowFixMe\n                var defaultProps = _this2.constructor.defaultProps;\n\n\n                var context = _extends({}, _this2.props);\n\n                if (typeof theme !== 'undefined') {\n                  context.theme = determineTheme(_this2.props, theme, defaultProps);\n                }\n\n                globalStyle.renderStyles(context, _this2.styleSheet);\n\n                return null;\n              }\n            );\n          }\n        }\n      );\n    };\n\n    return GlobalStyleComponent;\n  }(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component);\n\n  GlobalStyleComponent.globalStyle = style;\n  GlobalStyleComponent.styledComponentId = id;\n\n\n  return GlobalStyleComponent;\n}\n\n// \n\nvar replaceWhitespace = function replaceWhitespace(str) {\n  return str.replace(/\\s|\\\\n/g, '');\n};\n\nfunction keyframes(strings) {\n  /* Warning if you've used keyframes on React Native */\n  if (false) {}\n\n  for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    interpolations[_key - 1] = arguments[_key];\n  }\n\n  var rules = css.apply(undefined, [strings].concat(interpolations));\n\n  var name = generateAlphabeticName(murmurhash(replaceWhitespace(JSON.stringify(rules))));\n\n  return new Keyframes(name, stringifyRules(rules, name, '@keyframes'));\n}\n\n// \n\nvar withTheme = (function (Component$$1) {\n  var WithTheme = react__WEBPACK_IMPORTED_MODULE_2___default.a.forwardRef(function (props, ref) {\n    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(\n      ThemeConsumer,\n      null,\n      function (theme) {\n        // $FlowFixMe\n        var defaultProps = Component$$1.defaultProps;\n\n        var themeProp = determineTheme(props, theme, defaultProps);\n\n        if (false) {}\n\n        return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(Component$$1, _extends({}, props, { theme: themeProp, ref: ref }));\n      }\n    );\n  });\n\n  hoistNonReactStatics(WithTheme, Component$$1);\n\n  WithTheme.displayName = 'WithTheme(' + getComponentName(Component$$1) + ')';\n\n  return WithTheme;\n});\n\n// \n\n/* eslint-disable */\nvar __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS = {\n  StyleSheet: StyleSheet\n};\n\n// \n\n/* Warning if you've imported this file on React Native */\nif (false) {}\n\n/* Warning if there are several instances of styled-components */\nif (false) {}\n\n//\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (styled);\n\n//# sourceMappingURL=styled-components.browser.esm.js.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(14)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlcml2LXAycC5bbmFtZV0vLi9ub2RlX21vZHVsZXMvc3R5bGVkLWNvbXBvbmVudHMvZGlzdC9zdHlsZWQtY29tcG9uZW50cy5icm93c2VyLmVzbS5qcz9iY2U5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTdHlsaXMgZnJvbSAnc3R5bGlzL3N0eWxpcy5taW4nO1xuaW1wb3J0IF9pbnNlcnRSdWxlUGx1Z2luIGZyb20gJ3N0eWxpcy1ydWxlLXNoZWV0JztcbmltcG9ydCBSZWFjdCwgeyBjbG9uZUVsZW1lbnQsIGNyZWF0ZUNvbnRleHQsIENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1bml0bGVzcyBmcm9tICdAZW1vdGlvbi91bml0bGVzcyc7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzVmFsaWRFbGVtZW50VHlwZSwgRm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0LWlzJztcbmltcG9ydCBtZW1vaXplIGZyb20gJ21lbW9pemUtb25lJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgdmFsaWRBdHRyIGZyb20gJ0BlbW90aW9uL2lzLXByb3AtdmFsaWQnO1xuaW1wb3J0IG1lcmdlIGZyb20gJ21lcmdlLWFueXRoaW5nJztcblxuLy8gXG5cbnZhciBpbnRlcmxlYXZlID0gKGZ1bmN0aW9uIChzdHJpbmdzLCBpbnRlcnBvbGF0aW9ucykge1xuICB2YXIgcmVzdWx0ID0gW3N0cmluZ3NbMF1dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpbnRlcnBvbGF0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIHJlc3VsdC5wdXNoKGludGVycG9sYXRpb25zW2ldLCBzdHJpbmdzW2kgKyAxXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xuICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlO1xuICAgIHRhcmdldFtpXSA9IG9ialtpXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxuLy8gXG52YXIgaXNQbGFpbk9iamVjdCA9IChmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gKHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih4KSkgPT09ICdvYmplY3QnICYmIHguY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn0pO1xuXG4vLyBcbnZhciBFTVBUWV9BUlJBWSA9IE9iamVjdC5mcmVlemUoW10pO1xudmFyIEVNUFRZX09CSkVDVCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vLyBcbmZ1bmN0aW9uIGlzRnVuY3Rpb24odGVzdCkge1xuICByZXR1cm4gdHlwZW9mIHRlc3QgPT09ICdmdW5jdGlvbic7XG59XG5cbi8vIFxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHRhcmdldCkge1xuICByZXR1cm4gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyAmJiB0YXJnZXQgOiBmYWxzZSkgfHwgdGFyZ2V0LmRpc3BsYXlOYW1lIHx8IHRhcmdldC5uYW1lIHx8ICdDb21wb25lbnQnO1xufVxuXG4vLyBcbmZ1bmN0aW9uIGlzU3RhdGVsZXNzRnVuY3Rpb24odGVzdCkge1xuICByZXR1cm4gdHlwZW9mIHRlc3QgPT09ICdmdW5jdGlvbicgJiYgISh0ZXN0LnByb3RvdHlwZSAmJiB0ZXN0LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuLy8gXG5mdW5jdGlvbiBpc1N0eWxlZENvbXBvbmVudCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0LnN0eWxlZENvbXBvbmVudElkID09PSAnc3RyaW5nJztcbn1cblxuLy8gXG5cbnZhciBTQ19BVFRSID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIChwcm9jZXNzLmVudi5SRUFDVF9BUFBfU0NfQVRUUiB8fCBwcm9jZXNzLmVudi5TQ19BVFRSKSB8fCAnZGF0YS1zdHlsZWQnO1xuXG52YXIgU0NfVkVSU0lPTl9BVFRSID0gJ2RhdGEtc3R5bGVkLXZlcnNpb24nO1xuXG52YXIgU0NfU1RSRUFNX0FUVFIgPSAnZGF0YS1zdHlsZWQtc3RyZWFtZWQnO1xuXG52YXIgSVNfQlJPV1NFUiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdIVE1MRWxlbWVudCcgaW4gd2luZG93O1xuXG52YXIgRElTQUJMRV9TUEVFRFkgPSB0eXBlb2YgU0NfRElTQUJMRV9TUEVFRFkgPT09ICdib29sZWFuJyAmJiBTQ19ESVNBQkxFX1NQRUVEWSB8fCB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHByb2Nlc3MuZW52LlJFQUNUX0FQUF9TQ19ESVNBQkxFX1NQRUVEWSB8fCBwcm9jZXNzLmVudi5TQ19ESVNBQkxFX1NQRUVEWSkgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJztcblxuLy8gU2hhcmVkIGVtcHR5IGV4ZWN1dGlvbiBjb250ZXh0IHdoZW4gZ2VuZXJhdGluZyBzdGF0aWMgc3R5bGVzXG52YXIgU1RBVElDX0VYRUNVVElPTl9DT05URVhUID0ge307XG5cbi8vIFxuXG5cbi8qKlxuICogUGFyc2UgZXJyb3JzLm1kIGFuZCB0dXJuIGl0IGludG8gYSBzaW1wbGUgaGFzaCBvZiBjb2RlOiBtZXNzYWdlXG4gKi9cbnZhciBFUlJPUlMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge1xuICBcIjFcIjogXCJDYW5ub3QgY3JlYXRlIHN0eWxlZC1jb21wb25lbnQgZm9yIGNvbXBvbmVudDogJXMuXFxuXFxuXCIsXG4gIFwiMlwiOiBcIkNhbid0IGNvbGxlY3Qgc3R5bGVzIG9uY2UgeW91J3ZlIGNvbnN1bWVkIGEgYFNlcnZlclN0eWxlU2hlZXRgJ3Mgc3R5bGVzISBgU2VydmVyU3R5bGVTaGVldGAgaXMgYSBvbmUgb2ZmIGluc3RhbmNlIGZvciBlYWNoIHNlcnZlci1zaWRlIHJlbmRlciBjeWNsZS5cXG5cXG4tIEFyZSB5b3UgdHJ5aW5nIHRvIHJldXNlIGl0IGFjcm9zcyByZW5kZXJzP1xcbi0gQXJlIHlvdSBhY2NpZGVudGFsbHkgY2FsbGluZyBjb2xsZWN0U3R5bGVzIHR3aWNlP1xcblxcblwiLFxuICBcIjNcIjogXCJTdHJlYW1pbmcgU1NSIGlzIG9ubHkgc3VwcG9ydGVkIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudDsgUGxlYXNlIGRvIG5vdCB0cnkgdG8gY2FsbCB0aGlzIG1ldGhvZCBpbiB0aGUgYnJvd3Nlci5cXG5cXG5cIixcbiAgXCI0XCI6IFwiVGhlIGBTdHlsZVNoZWV0TWFuYWdlcmAgZXhwZWN0cyBhIHZhbGlkIHRhcmdldCBvciBzaGVldCBwcm9wIVxcblxcbi0gRG9lcyB0aGlzIGVycm9yIG9jY3VyIG9uIHRoZSBjbGllbnQgYW5kIGlzIHlvdXIgdGFyZ2V0IGZhbHN5P1xcbi0gRG9lcyB0aGlzIGVycm9yIG9jY3VyIG9uIHRoZSBzZXJ2ZXIgYW5kIGlzIHRoZSBzaGVldCBmYWxzeT9cXG5cXG5cIixcbiAgXCI1XCI6IFwiVGhlIGNsb25lIG1ldGhvZCBjYW5ub3QgYmUgdXNlZCBvbiB0aGUgY2xpZW50IVxcblxcbi0gQXJlIHlvdSBydW5uaW5nIGluIGEgY2xpZW50LWxpa2UgZW52aXJvbm1lbnQgb24gdGhlIHNlcnZlcj9cXG4tIEFyZSB5b3UgdHJ5aW5nIHRvIHJ1biBTU1Igb24gdGhlIGNsaWVudD9cXG5cXG5cIixcbiAgXCI2XCI6IFwiVHJ5aW5nIHRvIGluc2VydCBhIG5ldyBzdHlsZSB0YWcsIGJ1dCB0aGUgZ2l2ZW4gTm9kZSBpcyB1bm1vdW50ZWQhXFxuXFxuLSBBcmUgeW91IHVzaW5nIGEgY3VzdG9tIHRhcmdldCB0aGF0IGlzbid0IG1vdW50ZWQ/XFxuLSBEb2VzIHlvdXIgZG9jdW1lbnQgbm90IGhhdmUgYSB2YWxpZCBoZWFkIGVsZW1lbnQ/XFxuLSBIYXZlIHlvdSBhY2NpZGVudGFsbHkgcmVtb3ZlZCBhIHN0eWxlIHRhZyBtYW51YWxseT9cXG5cXG5cIixcbiAgXCI3XCI6IFwiVGhlbWVQcm92aWRlcjogUGxlYXNlIHJldHVybiBhbiBvYmplY3QgZnJvbSB5b3VyIFxcXCJ0aGVtZVxcXCIgcHJvcCBmdW5jdGlvbiwgZS5nLlxcblxcbmBgYGpzXFxudGhlbWU9eygpID0+ICh7fSl9XFxuYGBgXFxuXFxuXCIsXG4gIFwiOFwiOiBcIlRoZW1lUHJvdmlkZXI6IFBsZWFzZSBtYWtlIHlvdXIgXFxcInRoZW1lXFxcIiBwcm9wIGFuIG9iamVjdC5cXG5cXG5cIixcbiAgXCI5XCI6IFwiTWlzc2luZyBkb2N1bWVudCBgPGhlYWQ+YFxcblxcblwiLFxuICBcIjEwXCI6IFwiQ2Fubm90IGZpbmQgYSBTdHlsZVNoZWV0IGluc3RhbmNlLiBVc3VhbGx5IHRoaXMgaGFwcGVucyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29waWVzIG9mIHN0eWxlZC1jb21wb25lbnRzIGxvYWRlZCBhdCBvbmNlLiBDaGVjayBvdXQgdGhpcyBpc3N1ZSBmb3IgaG93IHRvIHRyb3VibGVzaG9vdCBhbmQgZml4IHRoZSBjb21tb24gY2FzZXMgd2hlcmUgdGhpcyBzaXR1YXRpb24gY2FuIGhhcHBlbjogaHR0cHM6Ly9naXRodWIuY29tL3N0eWxlZC1jb21wb25lbnRzL3N0eWxlZC1jb21wb25lbnRzL2lzc3Vlcy8xOTQxI2lzc3VlY29tbWVudC00MTc4NjIwMjFcXG5cXG5cIixcbiAgXCIxMVwiOiBcIl9UaGlzIGVycm9yIHdhcyByZXBsYWNlZCB3aXRoIGEgZGV2LXRpbWUgd2FybmluZywgaXQgd2lsbCBiZSBkZWxldGVkIGZvciB2NCBmaW5hbC5fIFtjcmVhdGVHbG9iYWxTdHlsZV0gcmVjZWl2ZWQgY2hpbGRyZW4gd2hpY2ggd2lsbCBub3QgYmUgcmVuZGVyZWQuIFBsZWFzZSB1c2UgdGhlIGNvbXBvbmVudCB3aXRob3V0IHBhc3NpbmcgY2hpbGRyZW4gZWxlbWVudHMuXFxuXFxuXCIsXG4gIFwiMTJcIjogXCJJdCBzZWVtcyB5b3UgYXJlIGludGVycG9sYXRpbmcgYSBrZXlmcmFtZSBkZWNsYXJhdGlvbiAoJXMpIGludG8gYW4gdW50YWdnZWQgc3RyaW5nLiBUaGlzIHdhcyBzdXBwb3J0ZWQgaW4gc3R5bGVkLWNvbXBvbmVudHMgdjMsIGJ1dCBpcyBub3QgbG9uZ2VyIHN1cHBvcnRlZCBpbiB2NCBhcyBrZXlmcmFtZXMgYXJlIG5vdyBpbmplY3RlZCBvbi1kZW1hbmQuIFBsZWFzZSB3cmFwIHlvdXIgc3RyaW5nIGluIHRoZSBjc3NcXFxcYFxcXFxgIGhlbHBlciB3aGljaCBlbnN1cmVzIHRoZSBzdHlsZXMgYXJlIGluamVjdGVkIGNvcnJlY3RseS4gU2VlIGh0dHBzOi8vd3d3LnN0eWxlZC1jb21wb25lbnRzLmNvbS9kb2NzL2FwaSNjc3NcXG5cXG5cIixcbiAgXCIxM1wiOiBcIiVzIGlzIG5vdCBhIHN0eWxlZCBjb21wb25lbnQgYW5kIGNhbm5vdCBiZSByZWZlcnJlZCB0byB2aWEgY29tcG9uZW50IHNlbGVjdG9yLiBTZWUgaHR0cHM6Ly93d3cuc3R5bGVkLWNvbXBvbmVudHMuY29tL2RvY3MvYWR2YW5jZWQjcmVmZXJyaW5nLXRvLW90aGVyLWNvbXBvbmVudHMgZm9yIG1vcmUgZGV0YWlscy5cXG5cIlxufSA6IHt9O1xuXG4vKipcbiAqIHN1cGVyIGJhc2ljIHZlcnNpb24gb2Ygc3ByaW50ZlxuICovXG5mdW5jdGlvbiBmb3JtYXQoKSB7XG4gIHZhciBhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICB2YXIgYiA9IFtdO1xuXG4gIGZvciAodmFyIGMgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBjIDwgbGVuOyBjICs9IDEpIHtcbiAgICBiLnB1c2goYXJndW1lbnRzLmxlbmd0aCA8PSBjID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2NdKTtcbiAgfVxuXG4gIGIuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIGEgPSBhLnJlcGxhY2UoLyVbYS16XS8sIGQpO1xuICB9KTtcblxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXJyb3IgZmlsZSBvdXQgb2YgZXJyb3JzLm1kIGZvciBkZXZlbG9wbWVudCBhbmQgYSBzaW1wbGUgd2ViIGxpbmsgdG8gdGhlIGZ1bGwgZXJyb3JzXG4gKiBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gKi9cblxudmFyIFN0eWxlZENvbXBvbmVudHNFcnJvciA9IGZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgaW5oZXJpdHMoU3R5bGVkQ29tcG9uZW50c0Vycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIFN0eWxlZENvbXBvbmVudHNFcnJvcihjb2RlKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3R5bGVkQ29tcG9uZW50c0Vycm9yKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpbnRlcnBvbGF0aW9ucyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGludGVycG9sYXRpb25zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXJyb3IuY2FsbCh0aGlzLCAnQW4gZXJyb3Igb2NjdXJyZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3R5bGVkLWNvbXBvbmVudHMvc3R5bGVkLWNvbXBvbmVudHMvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc3R5bGVkLWNvbXBvbmVudHMvc3JjL3V0aWxzL2Vycm9ycy5tZCMnICsgY29kZSArICcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyArIChpbnRlcnBvbGF0aW9ucy5sZW5ndGggPiAwID8gJyBBZGRpdGlvbmFsIGFyZ3VtZW50czogJyArIGludGVycG9sYXRpb25zLmpvaW4oJywgJykgOiAnJykpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXJyb3IuY2FsbCh0aGlzLCBmb3JtYXQuYXBwbHkodW5kZWZpbmVkLCBbRVJST1JTW2NvZGVdXS5jb25jYXQoaW50ZXJwb2xhdGlvbnMpKS50cmltKCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICB9XG5cbiAgcmV0dXJuIFN0eWxlZENvbXBvbmVudHNFcnJvcjtcbn0oRXJyb3IpO1xuXG4vLyBcbnZhciBTQ19DT01QT05FTlRfSUQgPSAvXlteXFxTXFxuXSo/XFwvXFwqIHNjLWNvbXBvbmVudC1pZDpcXHMqKFxcUyspXFxzK1xcKlxcLy9nbTtcblxudmFyIGV4dHJhY3RDb21wcyA9IChmdW5jdGlvbiAobWF5YmVDU1MpIHtcbiAgdmFyIGNzcyA9ICcnICsgKG1heWJlQ1NTIHx8ICcnKTsgLy8gRGVmaW5pdGVseSBhIHN0cmluZywgYW5kIGEgY2xvbmVcbiAgdmFyIGV4aXN0aW5nQ29tcG9uZW50cyA9IFtdO1xuICBjc3MucmVwbGFjZShTQ19DT01QT05FTlRfSUQsIGZ1bmN0aW9uIChtYXRjaCwgY29tcG9uZW50SWQsIG1hdGNoSW5kZXgpIHtcbiAgICBleGlzdGluZ0NvbXBvbmVudHMucHVzaCh7IGNvbXBvbmVudElkOiBjb21wb25lbnRJZCwgbWF0Y2hJbmRleDogbWF0Y2hJbmRleCB9KTtcbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xuICByZXR1cm4gZXhpc3RpbmdDb21wb25lbnRzLm1hcChmdW5jdGlvbiAoX3JlZiwgaSkge1xuICAgIHZhciBjb21wb25lbnRJZCA9IF9yZWYuY29tcG9uZW50SWQsXG4gICAgICAgIG1hdGNoSW5kZXggPSBfcmVmLm1hdGNoSW5kZXg7XG5cbiAgICB2YXIgbmV4dENvbXAgPSBleGlzdGluZ0NvbXBvbmVudHNbaSArIDFdO1xuICAgIHZhciBjc3NGcm9tRE9NID0gbmV4dENvbXAgPyBjc3Muc2xpY2UobWF0Y2hJbmRleCwgbmV4dENvbXAubWF0Y2hJbmRleCkgOiBjc3Muc2xpY2UobWF0Y2hJbmRleCk7XG4gICAgcmV0dXJuIHsgY29tcG9uZW50SWQ6IGNvbXBvbmVudElkLCBjc3NGcm9tRE9NOiBjc3NGcm9tRE9NIH07XG4gIH0pO1xufSk7XG5cbi8vIFxuXG52YXIgQ09NTUVOVF9SRUdFWCA9IC9eXFxzKlxcL1xcLy4qJC9nbTtcblxuLy8gTk9URTogVGhpcyBzdHlsaXMgaW5zdGFuY2UgaXMgb25seSB1c2VkIHRvIHNwbGl0IHJ1bGVzIGZyb20gU1NSJ2Qgc3R5bGUgdGFnc1xudmFyIHN0eWxpc1NwbGl0dGVyID0gbmV3IFN0eWxpcyh7XG4gIGdsb2JhbDogZmFsc2UsXG4gIGNhc2NhZGU6IHRydWUsXG4gIGtleWZyYW1lOiBmYWxzZSxcbiAgcHJlZml4OiBmYWxzZSxcbiAgY29tcHJlc3M6IGZhbHNlLFxuICBzZW1pY29sb246IHRydWVcbn0pO1xuXG52YXIgc3R5bGlzID0gbmV3IFN0eWxpcyh7XG4gIGdsb2JhbDogZmFsc2UsXG4gIGNhc2NhZGU6IHRydWUsXG4gIGtleWZyYW1lOiBmYWxzZSxcbiAgcHJlZml4OiB0cnVlLFxuICBjb21wcmVzczogZmFsc2UsXG4gIHNlbWljb2xvbjogZmFsc2UgLy8gTk9URTogVGhpcyBtZWFucyBcImF1dG9jb21wbGV0ZSBtaXNzaW5nIHNlbWljb2xvbnNcIlxufSk7XG5cbi8vIFdyYXAgYGluc2VydFJ1bGVQbHVnaW4gdG8gYnVpbGQgYSBsaXN0IG9mIHJ1bGVzLFxuLy8gYW5kIHRoZW4gbWFrZSBvdXIgb3duIHBsdWdpbiB0byByZXR1cm4gdGhlIHJ1bGVzLiBUaGlzXG4vLyBtYWtlcyBpdCBlYXNpZXIgdG8gaG9vayBpbnRvIHRoZSBleGlzdGluZyBTU1IgYXJjaGl0ZWN0dXJlXG5cbnZhciBwYXJzaW5nUnVsZXMgPSBbXTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgcmV0dXJuUnVsZXNQbHVnaW4gPSBmdW5jdGlvbiByZXR1cm5SdWxlc1BsdWdpbihjb250ZXh0KSB7XG4gIGlmIChjb250ZXh0ID09PSAtMikge1xuICAgIHZhciBwYXJzZWRSdWxlcyA9IHBhcnNpbmdSdWxlcztcbiAgICBwYXJzaW5nUnVsZXMgPSBbXTtcbiAgICByZXR1cm4gcGFyc2VkUnVsZXM7XG4gIH1cbn07XG5cbnZhciBwYXJzZVJ1bGVzUGx1Z2luID0gX2luc2VydFJ1bGVQbHVnaW4oZnVuY3Rpb24gKHJ1bGUpIHtcbiAgcGFyc2luZ1J1bGVzLnB1c2gocnVsZSk7XG59KTtcblxudmFyIF9jb21wb25lbnRJZCA9IHZvaWQgMDtcbnZhciBfc2VsZWN0b3IgPSB2b2lkIDA7XG52YXIgX3NlbGVjdG9yUmVnZXhwID0gdm9pZCAwO1xuXG52YXIgc2VsZlJlZmVyZW5jZVJlcGxhY2VyID0gZnVuY3Rpb24gc2VsZlJlZmVyZW5jZVJlcGxhY2VyKG1hdGNoLCBvZmZzZXQsIHN0cmluZykge1xuICBpZiAoXG4gIC8vIHRoZSBmaXJzdCBzZWxmLXJlZiBpcyBhbHdheXMgdW50b3VjaGVkXG4gIG9mZnNldCA+IDAgJiZcbiAgLy8gdGhlcmUgc2hvdWxkIGJlIGF0IGxlYXN0IHR3byBzZWxmLXJlZnMgdG8gZG8gYSByZXBsYWNlbWVudCAoLmIgPiAuYilcbiAgc3RyaW5nLnNsaWNlKDAsIG9mZnNldCkuaW5kZXhPZihfc2VsZWN0b3IpICE9PSAtMSAmJlxuICAvLyBubyBjb25zZWN1dGl2ZSBzZWxmIHJlZnMgKC5iLmIpOyB0aGF0IGlzIGEgcHJlY2VkZW5jZSBib29zdCBhbmQgdHJlYXRlZCBkaWZmZXJlbnRseVxuICBzdHJpbmcuc2xpY2Uob2Zmc2V0IC0gX3NlbGVjdG9yLmxlbmd0aCwgb2Zmc2V0KSAhPT0gX3NlbGVjdG9yKSB7XG4gICAgcmV0dXJuICcuJyArIF9jb21wb25lbnRJZDtcbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn07XG5cbi8qKlxuICogV2hlbiB3cml0aW5nIGEgc3R5bGUgbGlrZVxuICpcbiAqICYgKyAmIHtcbiAqICAgY29sb3I6IHJlZDtcbiAqIH1cbiAqXG4gKiBUaGUgc2Vjb25kIGFtcGVyc2FuZCBzaG91bGQgYmUgYSByZWZlcmVuY2UgdG8gdGhlIHN0YXRpYyBjb21wb25lbnQgY2xhc3MuIHN0eWxpc1xuICogaGFzIG5vIGtub3dsZWRnZSBvZiBzdGF0aWMgY2xhc3Mgc28gd2UgaGF2ZSB0byBpbnRlbGxpZ2VudGx5IHJlcGxhY2UgdGhlIGJhc2Ugc2VsZWN0b3IuXG4gKi9cbnZhciBzZWxmUmVmZXJlbmNlUmVwbGFjZW1lbnRQbHVnaW4gPSBmdW5jdGlvbiBzZWxmUmVmZXJlbmNlUmVwbGFjZW1lbnRQbHVnaW4oY29udGV4dCwgXywgc2VsZWN0b3JzKSB7XG4gIGlmIChjb250ZXh0ID09PSAyICYmIHNlbGVjdG9ycy5sZW5ndGggJiYgc2VsZWN0b3JzWzBdLmxhc3RJbmRleE9mKF9zZWxlY3RvcikgPiAwKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgc2VsZWN0b3JzWzBdID0gc2VsZWN0b3JzWzBdLnJlcGxhY2UoX3NlbGVjdG9yUmVnZXhwLCBzZWxmUmVmZXJlbmNlUmVwbGFjZXIpO1xuICB9XG59O1xuXG5zdHlsaXMudXNlKFtzZWxmUmVmZXJlbmNlUmVwbGFjZW1lbnRQbHVnaW4sIHBhcnNlUnVsZXNQbHVnaW4sIHJldHVyblJ1bGVzUGx1Z2luXSk7XG5zdHlsaXNTcGxpdHRlci51c2UoW3BhcnNlUnVsZXNQbHVnaW4sIHJldHVyblJ1bGVzUGx1Z2luXSk7XG5cbnZhciBzcGxpdEJ5UnVsZXMgPSBmdW5jdGlvbiBzcGxpdEJ5UnVsZXMoY3NzKSB7XG4gIHJldHVybiBzdHlsaXNTcGxpdHRlcignJywgY3NzKTtcbn07XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVJ1bGVzKHJ1bGVzLCBzZWxlY3RvciwgcHJlZml4KSB7XG4gIHZhciBjb21wb25lbnRJZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogJyYnO1xuXG4gIHZhciBmbGF0Q1NTID0gcnVsZXMuam9pbignJykucmVwbGFjZShDT01NRU5UX1JFR0VYLCAnJyk7IC8vIHJlcGxhY2UgSlMgY29tbWVudHNcblxuICB2YXIgY3NzU3RyID0gc2VsZWN0b3IgJiYgcHJlZml4ID8gcHJlZml4ICsgJyAnICsgc2VsZWN0b3IgKyAnIHsgJyArIGZsYXRDU1MgKyAnIH0nIDogZmxhdENTUztcblxuICAvLyBzdHlsaXMgaGFzIG5vIGNvbmNlcHQgb2Ygc3RhdGUgdG8gYmUgcGFzc2VkIHRvIHBsdWdpbnNcbiAgLy8gYnV0IHNpbmNlIEpTIGlzIHNpbmdsZT10aHJlYWRlZCwgd2UgY2FuIHJlbHkgb24gdGhhdCB0byBlbnN1cmVcbiAgLy8gdGhlc2UgcHJvcGVydGllcyBzdGF5IGluIHN5bmMgd2l0aCB0aGUgY3VycmVudCBzdHlsaXMgcnVuXG4gIF9jb21wb25lbnRJZCA9IGNvbXBvbmVudElkO1xuICBfc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgX3NlbGVjdG9yUmVnZXhwID0gbmV3IFJlZ0V4cCgnXFxcXCcgKyBfc2VsZWN0b3IgKyAnXFxcXGInLCAnZycpO1xuXG4gIHJldHVybiBzdHlsaXMocHJlZml4IHx8ICFzZWxlY3RvciA/ICcnIDogc2VsZWN0b3IsIGNzc1N0cik7XG59XG5cbi8vIFxuLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlLCBuby11bmRlZiAqL1xuXG52YXIgZ2V0Tm9uY2UgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcbn0pO1xuXG4vLyBcbi8qIFRoZXNlIGFyZSBoZWxwZXJzIGZvciB0aGUgU3R5bGVUYWdzIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGluamVjdGVkXG4gKiBydWxlIG5hbWVzIGZvciBlYWNoIChjb21wb25lbnQpIElEIHRoYXQgdGhleSdyZSBrZWVwaW5nIHRyYWNrIG9mLlxuICogVGhleSdyZSBjcnVjaWFsIGZvciBkZXRlY3Rpbmcgd2hldGhlciBhIG5hbWUgaGFzIGFscmVhZHkgYmVlblxuICogaW5qZWN0ZWQuXG4gKiAoVGhpcyBleGNsdWRlcyByZWh5ZHJhdGVkIG5hbWVzKSAqL1xuXG4vKiBhZGRzIGEgbmV3IElEOm5hbWUgcGFpcmluZyB0byBhIG5hbWVzIGRpY3Rpb25hcnkgKi9cbnZhciBhZGROYW1lRm9ySWQgPSBmdW5jdGlvbiBhZGROYW1lRm9ySWQobmFtZXMsIGlkLCBuYW1lKSB7XG4gIGlmIChuYW1lKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdmFyIG5hbWVzRm9ySWQgPSBuYW1lc1tpZF0gfHwgKG5hbWVzW2lkXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIG5hbWVzRm9ySWRbbmFtZV0gPSB0cnVlO1xuICB9XG59O1xuXG4vKiByZXNldHMgYW4gSUQgZW50aXJlbHkgYnkgb3ZlcndyaXRpbmcgaXQgaW4gdGhlIGRpY3Rpb25hcnkgKi9cbnZhciByZXNldElkTmFtZXMgPSBmdW5jdGlvbiByZXNldElkTmFtZXMobmFtZXMsIGlkKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBuYW1lc1tpZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufTtcblxuLyogZmFjdG9yeSBmb3IgYSBuYW1lcyBkaWN0aW9uYXJ5IGNoZWNraW5nIHRoZSBleGlzdGFuY2Ugb2YgYW4gSUQ6bmFtZSBwYWlyaW5nICovXG52YXIgaGFzTmFtZUZvcklkID0gZnVuY3Rpb24gaGFzTmFtZUZvcklkKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaWQsIG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZXNbaWRdICE9PSB1bmRlZmluZWQgJiYgbmFtZXNbaWRdW25hbWVdO1xuICB9O1xufTtcblxuLyogc3RyaW5naWZpZXMgbmFtZXMgZm9yIHRoZSBodG1sL2VsZW1lbnQgb3V0cHV0ICovXG52YXIgc3RyaW5naWZ5TmFtZXMgPSBmdW5jdGlvbiBzdHJpbmdpZnlOYW1lcyhuYW1lcykge1xuICB2YXIgc3RyID0gJyc7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgZm9yICh2YXIgaWQgaW4gbmFtZXMpIHtcbiAgICBzdHIgKz0gT2JqZWN0LmtleXMobmFtZXNbaWRdKS5qb2luKCcgJykgKyAnICc7XG4gIH1cbiAgcmV0dXJuIHN0ci50cmltKCk7XG59O1xuXG4vKiBjbG9uZXMgdGhlIG5lc3RlZCBuYW1lcyBkaWN0aW9uYXJ5ICovXG52YXIgY2xvbmVOYW1lcyA9IGZ1bmN0aW9uIGNsb25lTmFtZXMobmFtZXMpIHtcbiAgdmFyIGNsb25lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICBmb3IgKHZhciBpZCBpbiBuYW1lcykge1xuICAgIGNsb25lW2lkXSA9IF9leHRlbmRzKHt9LCBuYW1lc1tpZF0pO1xuICB9XG4gIHJldHVybiBjbG9uZTtcbn07XG5cbi8vIFxuXG4vKiBUaGVzZSBhcmUgaGVscGVycyB0aGF0IGRlYWwgd2l0aCB0aGUgaW5zZXJ0UnVsZSAoYWthIHNwZWVkeSkgQVBJXG4gKiBUaGV5IGFyZSB1c2VkIGluIHRoZSBTdHlsZVRhZ3MgYW5kIHNwZWNpZmljYWxseSB0aGUgc3BlZWR5IHRhZ1xuICovXG5cbi8qIHJldHJpZXZlIGEgc2hlZXQgZm9yIGEgZ2l2ZW4gc3R5bGUgdGFnICovXG52YXIgc2hlZXRGb3JUYWcgPSBmdW5jdGlvbiBzaGVldEZvclRhZyh0YWcpIHtcbiAgLy8gJEZsb3dGaXhNZVxuICBpZiAodGFnLnNoZWV0KSByZXR1cm4gdGFnLnNoZWV0O1xuXG4gIC8qIEZpcmVmb3ggcXVpcmsgcmVxdWlyZXMgdXMgdG8gc3RlcCB0aHJvdWdoIGFsbCBzdHlsZXNoZWV0cyB0byBmaW5kIG9uZSBvd25lZCBieSB0aGUgZ2l2ZW4gdGFnICovXG4gIHZhciBzaXplID0gdGFnLm93bmVyRG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkgKz0gMSkge1xuICAgIHZhciBzaGVldCA9IHRhZy5vd25lckRvY3VtZW50LnN0eWxlU2hlZXRzW2ldO1xuICAgIC8vICRGbG93Rml4TWVcbiAgICBpZiAoc2hlZXQub3duZXJOb2RlID09PSB0YWcpIHJldHVybiBzaGVldDtcbiAgfVxuXG4gIC8qIHdlIHNob3VsZCBhbHdheXMgYmUgYWJsZSB0byBmaW5kIGEgdGFnICovXG4gIHRocm93IG5ldyBTdHlsZWRDb21wb25lbnRzRXJyb3IoMTApO1xufTtcblxuLyogaW5zZXJ0IGEgcnVsZSBzYWZlbHkgYW5kIHJldHVybiB3aGV0aGVyIGl0IHdhcyBhY3R1YWxseSBpbmplY3RlZCAqL1xudmFyIHNhZmVJbnNlcnRSdWxlID0gZnVuY3Rpb24gc2FmZUluc2VydFJ1bGUoc2hlZXQsIGNzc1J1bGUsIGluZGV4KSB7XG4gIC8qIGFib3J0IGVhcmx5IGlmIGNzc1J1bGUgc3RyaW5nIGlzIGZhbHN5ICovXG4gIGlmICghY3NzUnVsZSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXhJbmRleCA9IHNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcblxuICB0cnkge1xuICAgIC8qIHVzZSBpbnNlcnRSdWxlIGFuZCBjYXAgcGFzc2VkIGluZGV4IHdpdGggbWF4SW5kZXggKG5vIG9mIGNzc1J1bGVzKSAqL1xuICAgIHNoZWV0Lmluc2VydFJ1bGUoY3NzUnVsZSwgaW5kZXggPD0gbWF4SW5kZXggPyBpbmRleCA6IG1heEluZGV4KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLyogYW55IGVycm9yIGluZGljYXRlcyBhbiBpbnZhbGlkIHJ1bGUgKi9cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qIGRlbGV0ZXMgYHNpemVgIHJ1bGVzIHN0YXJ0aW5nIGZyb20gYHJlbW92YWxJbmRleGAgKi9cbnZhciBkZWxldGVSdWxlcyA9IGZ1bmN0aW9uIGRlbGV0ZVJ1bGVzKHNoZWV0LCByZW1vdmFsSW5kZXgsIHNpemUpIHtcbiAgdmFyIGxvd2VyQm91bmQgPSByZW1vdmFsSW5kZXggLSBzaXplO1xuICBmb3IgKHZhciBpID0gcmVtb3ZhbEluZGV4OyBpID4gbG93ZXJCb3VuZDsgaSAtPSAxKSB7XG4gICAgc2hlZXQuZGVsZXRlUnVsZShpKTtcbiAgfVxufTtcblxuLy8gXG5cbi8qIHRoaXMgbWFya2VyIHNlcGFyYXRlcyBjb21wb25lbnQgc3R5bGVzIGFuZCBpcyBpbXBvcnRhbnQgZm9yIHJlaHlkcmF0aW9uICovXG52YXIgbWFrZVRleHRNYXJrZXIgPSBmdW5jdGlvbiBtYWtlVGV4dE1hcmtlcihpZCkge1xuICByZXR1cm4gJ1xcbi8qIHNjLWNvbXBvbmVudC1pZDogJyArIGlkICsgJyAqL1xcbic7XG59O1xuXG4vKiBhZGQgdXAgYWxsIG51bWJlcnMgaW4gYXJyYXkgdXAgdW50aWwgYW5kIGluY2x1ZGluZyB0aGUgaW5kZXggKi9cbnZhciBhZGRVcFVudGlsSW5kZXggPSBmdW5jdGlvbiBhZGRVcFVudGlsSW5kZXgoc2l6ZXMsIGluZGV4KSB7XG4gIHZhciB0b3RhbFVwVG9JbmRleCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IGluZGV4OyBpICs9IDEpIHtcbiAgICB0b3RhbFVwVG9JbmRleCArPSBzaXplc1tpXTtcbiAgfVxuXG4gIHJldHVybiB0b3RhbFVwVG9JbmRleDtcbn07XG5cbi8qIGNyZWF0ZSBhIG5ldyBzdHlsZSB0YWcgYWZ0ZXIgbGFzdEVsICovXG52YXIgbWFrZVN0eWxlVGFnID0gZnVuY3Rpb24gbWFrZVN0eWxlVGFnKHRhcmdldCwgdGFnRWwsIGluc2VydEJlZm9yZSkge1xuICB2YXIgdGFyZ2V0RG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgaWYgKHRhcmdldCkgdGFyZ2V0RG9jdW1lbnQgPSB0YXJnZXQub3duZXJEb2N1bWVudDtlbHNlIGlmICh0YWdFbCkgdGFyZ2V0RG9jdW1lbnQgPSB0YWdFbC5vd25lckRvY3VtZW50O1xuXG4gIHZhciBlbCA9IHRhcmdldERvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIGVsLnNldEF0dHJpYnV0ZShTQ19BVFRSLCAnJyk7XG4gIGVsLnNldEF0dHJpYnV0ZShTQ19WRVJTSU9OX0FUVFIsIFwiNC40LjFcIik7XG5cbiAgdmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcbiAgaWYgKG5vbmNlKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgfVxuXG4gIC8qIFdvcmsgYXJvdW5kIGluc2VydFJ1bGUgcXVpcmsgaW4gRWRnZUhUTUwgKi9cbiAgZWwuYXBwZW5kQ2hpbGQodGFyZ2V0RG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpKTtcblxuICBpZiAodGFyZ2V0ICYmICF0YWdFbCkge1xuICAgIC8qIEFwcGVuZCB0byB0YXJnZXQgd2hlbiBubyBwcmV2aW91cyBlbGVtZW50IHdhcyBwYXNzZWQgKi9cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWwpO1xuICB9IGVsc2Uge1xuICAgIGlmICghdGFnRWwgfHwgIXRhcmdldCB8fCAhdGFnRWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhyb3cgbmV3IFN0eWxlZENvbXBvbmVudHNFcnJvcig2KTtcbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgbmV3IHN0eWxlIHRhZyBhZnRlciB0aGUgcHJldmlvdXMgb25lICovXG4gICAgdGFnRWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIGluc2VydEJlZm9yZSA/IHRhZ0VsIDogdGFnRWwubmV4dFNpYmxpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGVsO1xufTtcblxuLyogdGFrZXMgYSBjc3MgZmFjdG9yeSBmdW5jdGlvbiBhbmQgb3V0cHV0cyBhbiBodG1sIHN0eWxlZCB0YWcgZmFjdG9yeSAqL1xudmFyIHdyYXBBc0h0bWxUYWcgPSBmdW5jdGlvbiB3cmFwQXNIdG1sVGFnKGNzcywgbmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhZGRpdGlvbmFsQXR0cnMpIHtcbiAgICB2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuICAgIHZhciBhdHRycyA9IFtub25jZSAmJiAnbm9uY2U9XCInICsgbm9uY2UgKyAnXCInLCBTQ19BVFRSICsgJz1cIicgKyBzdHJpbmdpZnlOYW1lcyhuYW1lcykgKyAnXCInLCBTQ19WRVJTSU9OX0FUVFIgKyAnPVwiJyArIFwiNC40LjFcIiArICdcIicsIGFkZGl0aW9uYWxBdHRyc107XG5cbiAgICB2YXIgaHRtbEF0dHIgPSBhdHRycy5maWx0ZXIoQm9vbGVhbikuam9pbignICcpO1xuICAgIHJldHVybiAnPHN0eWxlICcgKyBodG1sQXR0ciArICc+JyArIGNzcygpICsgJzwvc3R5bGU+JztcbiAgfTtcbn07XG5cbi8qIHRha2VzIGEgY3NzIGZhY3RvcnkgZnVuY3Rpb24gYW5kIG91dHB1dHMgYW4gZWxlbWVudCBmYWN0b3J5ICovXG52YXIgd3JhcEFzRWxlbWVudCA9IGZ1bmN0aW9uIHdyYXBBc0VsZW1lbnQoY3NzLCBuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcHJvcHM7XG5cbiAgICB2YXIgcHJvcHMgPSAoX3Byb3BzID0ge30sIF9wcm9wc1tTQ19BVFRSXSA9IHN0cmluZ2lmeU5hbWVzKG5hbWVzKSwgX3Byb3BzW1NDX1ZFUlNJT05fQVRUUl0gPSBcIjQuNC4xXCIsIF9wcm9wcyk7XG5cbiAgICB2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuICAgIGlmIChub25jZSkge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgcHJvcHMubm9uY2UgPSBub25jZTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZGFuZ2VyXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJywgX2V4dGVuZHMoe30sIHByb3BzLCB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogY3NzKCkgfSB9KSk7XG4gIH07XG59O1xuXG52YXIgZ2V0SWRzRnJvbU1hcmtlcnNGYWN0b3J5ID0gZnVuY3Rpb24gZ2V0SWRzRnJvbU1hcmtlcnNGYWN0b3J5KG1hcmtlcnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobWFya2Vycyk7XG4gIH07XG59O1xuXG4vKiBzcGVlZHkgdGFncyB1dGlsaXNlIGluc2VydFJ1bGUgKi9cbnZhciBtYWtlU3BlZWR5VGFnID0gZnVuY3Rpb24gbWFrZVNwZWVkeVRhZyhlbCwgZ2V0SW1wb3J0UnVsZVRhZykge1xuICB2YXIgbmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbWFya2VycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBzaXplcyA9IFtdO1xuXG4gIHZhciBleHRyYWN0SW1wb3J0ID0gZ2V0SW1wb3J0UnVsZVRhZyAhPT0gdW5kZWZpbmVkO1xuICAvKiBpbmRpY2F0ZXMgd2hldGhlciBnZXRJbXBvcnRSdWxlVGFnIHdhcyBjYWxsZWQgKi9cbiAgdmFyIHVzZWRJbXBvcnRSdWxlVGFnID0gZmFsc2U7XG5cbiAgdmFyIGluc2VydE1hcmtlciA9IGZ1bmN0aW9uIGluc2VydE1hcmtlcihpZCkge1xuICAgIHZhciBwcmV2ID0gbWFya2Vyc1tpZF07XG4gICAgaWYgKHByZXYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfVxuXG4gICAgbWFya2Vyc1tpZF0gPSBzaXplcy5sZW5ndGg7XG4gICAgc2l6ZXMucHVzaCgwKTtcbiAgICByZXNldElkTmFtZXMobmFtZXMsIGlkKTtcblxuICAgIHJldHVybiBtYXJrZXJzW2lkXTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0UnVsZXMgPSBmdW5jdGlvbiBpbnNlcnRSdWxlcyhpZCwgY3NzUnVsZXMsIG5hbWUpIHtcbiAgICB2YXIgbWFya2VyID0gaW5zZXJ0TWFya2VyKGlkKTtcbiAgICB2YXIgc2hlZXQgPSBzaGVldEZvclRhZyhlbCk7XG4gICAgdmFyIGluc2VydEluZGV4ID0gYWRkVXBVbnRpbEluZGV4KHNpemVzLCBtYXJrZXIpO1xuXG4gICAgdmFyIGluamVjdGVkUnVsZXMgPSAwO1xuICAgIHZhciBpbXBvcnRSdWxlcyA9IFtdO1xuICAgIHZhciBjc3NSdWxlc1NpemUgPSBjc3NSdWxlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNzc1J1bGVzU2l6ZTsgaSArPSAxKSB7XG4gICAgICB2YXIgY3NzUnVsZSA9IGNzc1J1bGVzW2ldO1xuICAgICAgdmFyIG1heUhhdmVJbXBvcnQgPSBleHRyYWN0SW1wb3J0OyAvKiBAaW1wb3J0IHJ1bGVzIGFyZSByZW9yZGVyZWQgdG8gYXBwZWFyIGZpcnN0ICovXG4gICAgICBpZiAobWF5SGF2ZUltcG9ydCAmJiBjc3NSdWxlLmluZGV4T2YoJ0BpbXBvcnQnKSAhPT0gLTEpIHtcbiAgICAgICAgaW1wb3J0UnVsZXMucHVzaChjc3NSdWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2FmZUluc2VydFJ1bGUoc2hlZXQsIGNzc1J1bGUsIGluc2VydEluZGV4ICsgaW5qZWN0ZWRSdWxlcykpIHtcbiAgICAgICAgbWF5SGF2ZUltcG9ydCA9IGZhbHNlO1xuICAgICAgICBpbmplY3RlZFJ1bGVzICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4dHJhY3RJbXBvcnQgJiYgaW1wb3J0UnVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgdXNlZEltcG9ydFJ1bGVUYWcgPSB0cnVlO1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgZ2V0SW1wb3J0UnVsZVRhZygpLmluc2VydFJ1bGVzKGlkICsgJy1pbXBvcnQnLCBpbXBvcnRSdWxlcyk7XG4gICAgfVxuXG4gICAgc2l6ZXNbbWFya2VyXSArPSBpbmplY3RlZFJ1bGVzOyAvKiBhZGQgdXAgbm8gb2YgaW5qZWN0ZWQgcnVsZXMgKi9cbiAgICBhZGROYW1lRm9ySWQobmFtZXMsIGlkLCBuYW1lKTtcbiAgfTtcblxuICB2YXIgcmVtb3ZlUnVsZXMgPSBmdW5jdGlvbiByZW1vdmVSdWxlcyhpZCkge1xuICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2lkXTtcbiAgICBpZiAobWFya2VyID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgaWYgKGVsLmlzQ29ubmVjdGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgdmFyIHNpemUgPSBzaXplc1ttYXJrZXJdO1xuICAgIHZhciBzaGVldCA9IHNoZWV0Rm9yVGFnKGVsKTtcbiAgICB2YXIgcmVtb3ZhbEluZGV4ID0gYWRkVXBVbnRpbEluZGV4KHNpemVzLCBtYXJrZXIpIC0gMTtcbiAgICBkZWxldGVSdWxlcyhzaGVldCwgcmVtb3ZhbEluZGV4LCBzaXplKTtcbiAgICBzaXplc1ttYXJrZXJdID0gMDtcbiAgICByZXNldElkTmFtZXMobmFtZXMsIGlkKTtcblxuICAgIGlmIChleHRyYWN0SW1wb3J0ICYmIHVzZWRJbXBvcnRSdWxlVGFnKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBnZXRJbXBvcnRSdWxlVGFnKCkucmVtb3ZlUnVsZXMoaWQgKyAnLWltcG9ydCcpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY3NzID0gZnVuY3Rpb24gY3NzKCkge1xuICAgIHZhciBfc2hlZXRGb3JUYWcgPSBzaGVldEZvclRhZyhlbCksXG4gICAgICAgIGNzc1J1bGVzID0gX3NoZWV0Rm9yVGFnLmNzc1J1bGVzO1xuXG4gICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAodmFyIGlkIGluIG1hcmtlcnMpIHtcbiAgICAgIHN0ciArPSBtYWtlVGV4dE1hcmtlcihpZCk7XG4gICAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpZF07XG4gICAgICB2YXIgZW5kID0gYWRkVXBVbnRpbEluZGV4KHNpemVzLCBtYXJrZXIpO1xuICAgICAgdmFyIHNpemUgPSBzaXplc1ttYXJrZXJdO1xuICAgICAgZm9yICh2YXIgaSA9IGVuZCAtIHNpemU7IGkgPCBlbmQ7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcnVsZSA9IGNzc1J1bGVzW2ldO1xuICAgICAgICBpZiAocnVsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3RyICs9IHJ1bGUuY3NzVGV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICB0aHJvdyBuZXcgU3R5bGVkQ29tcG9uZW50c0Vycm9yKDUpO1xuICAgIH0sXG5cbiAgICBjc3M6IGNzcyxcbiAgICBnZXRJZHM6IGdldElkc0Zyb21NYXJrZXJzRmFjdG9yeShtYXJrZXJzKSxcbiAgICBoYXNOYW1lRm9ySWQ6IGhhc05hbWVGb3JJZChuYW1lcyksXG4gICAgaW5zZXJ0TWFya2VyOiBpbnNlcnRNYXJrZXIsXG4gICAgaW5zZXJ0UnVsZXM6IGluc2VydFJ1bGVzLFxuICAgIHJlbW92ZVJ1bGVzOiByZW1vdmVSdWxlcyxcbiAgICBzZWFsZWQ6IGZhbHNlLFxuICAgIHN0eWxlVGFnOiBlbCxcbiAgICB0b0VsZW1lbnQ6IHdyYXBBc0VsZW1lbnQoY3NzLCBuYW1lcyksXG4gICAgdG9IVE1MOiB3cmFwQXNIdG1sVGFnKGNzcywgbmFtZXMpXG4gIH07XG59O1xuXG52YXIgbWFrZVRleHROb2RlID0gZnVuY3Rpb24gbWFrZVRleHROb2RlKHRhcmdldERvY3VtZW50LCBpZCkge1xuICByZXR1cm4gdGFyZ2V0RG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobWFrZVRleHRNYXJrZXIoaWQpKTtcbn07XG5cbnZhciBtYWtlQnJvd3NlclRhZyA9IGZ1bmN0aW9uIG1ha2VCcm93c2VyVGFnKGVsLCBnZXRJbXBvcnRSdWxlVGFnKSB7XG4gIHZhciBuYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBtYXJrZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB2YXIgZXh0cmFjdEltcG9ydCA9IGdldEltcG9ydFJ1bGVUYWcgIT09IHVuZGVmaW5lZDtcblxuICAvKiBpbmRpY2F0ZXMgd2hldGhlciBnZXRJbXBvcnRSdWxlVGFnIHdhcyBjYWxsZWQgKi9cbiAgdmFyIHVzZWRJbXBvcnRSdWxlVGFnID0gZmFsc2U7XG5cbiAgdmFyIGluc2VydE1hcmtlciA9IGZ1bmN0aW9uIGluc2VydE1hcmtlcihpZCkge1xuICAgIHZhciBwcmV2ID0gbWFya2Vyc1tpZF07XG4gICAgaWYgKHByZXYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfVxuXG4gICAgbWFya2Vyc1tpZF0gPSBtYWtlVGV4dE5vZGUoZWwub3duZXJEb2N1bWVudCwgaWQpO1xuICAgIGVsLmFwcGVuZENoaWxkKG1hcmtlcnNbaWRdKTtcbiAgICBuYW1lc1tpZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgcmV0dXJuIG1hcmtlcnNbaWRdO1xuICB9O1xuXG4gIHZhciBpbnNlcnRSdWxlcyA9IGZ1bmN0aW9uIGluc2VydFJ1bGVzKGlkLCBjc3NSdWxlcywgbmFtZSkge1xuICAgIHZhciBtYXJrZXIgPSBpbnNlcnRNYXJrZXIoaWQpO1xuICAgIHZhciBpbXBvcnRSdWxlcyA9IFtdO1xuICAgIHZhciBjc3NSdWxlc1NpemUgPSBjc3NSdWxlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNzc1J1bGVzU2l6ZTsgaSArPSAxKSB7XG4gICAgICB2YXIgcnVsZSA9IGNzc1J1bGVzW2ldO1xuICAgICAgdmFyIG1heUhhdmVJbXBvcnQgPSBleHRyYWN0SW1wb3J0O1xuICAgICAgaWYgKG1heUhhdmVJbXBvcnQgJiYgcnVsZS5pbmRleE9mKCdAaW1wb3J0JykgIT09IC0xKSB7XG4gICAgICAgIGltcG9ydFJ1bGVzLnB1c2gocnVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXlIYXZlSW1wb3J0ID0gZmFsc2U7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBpID09PSBjc3NSdWxlc1NpemUgLSAxID8gJycgOiAnICc7XG4gICAgICAgIG1hcmtlci5hcHBlbmREYXRhKCcnICsgcnVsZSArIHNlcGFyYXRvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWRkTmFtZUZvcklkKG5hbWVzLCBpZCwgbmFtZSk7XG5cbiAgICBpZiAoZXh0cmFjdEltcG9ydCAmJiBpbXBvcnRSdWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICB1c2VkSW1wb3J0UnVsZVRhZyA9IHRydWU7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBnZXRJbXBvcnRSdWxlVGFnKCkuaW5zZXJ0UnVsZXMoaWQgKyAnLWltcG9ydCcsIGltcG9ydFJ1bGVzKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJlbW92ZVJ1bGVzID0gZnVuY3Rpb24gcmVtb3ZlUnVsZXMoaWQpIHtcbiAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpZF07XG4gICAgaWYgKG1hcmtlciA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAvKiBjcmVhdGUgbmV3IGVtcHR5IHRleHQgbm9kZSBhbmQgcmVwbGFjZSB0aGUgY3VycmVudCBvbmUgKi9cbiAgICB2YXIgbmV3TWFya2VyID0gbWFrZVRleHROb2RlKGVsLm93bmVyRG9jdW1lbnQsIGlkKTtcbiAgICBlbC5yZXBsYWNlQ2hpbGQobmV3TWFya2VyLCBtYXJrZXIpO1xuICAgIG1hcmtlcnNbaWRdID0gbmV3TWFya2VyO1xuICAgIHJlc2V0SWROYW1lcyhuYW1lcywgaWQpO1xuXG4gICAgaWYgKGV4dHJhY3RJbXBvcnQgJiYgdXNlZEltcG9ydFJ1bGVUYWcpIHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIGdldEltcG9ydFJ1bGVUYWcoKS5yZW1vdmVSdWxlcyhpZCArICctaW1wb3J0Jyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjc3MgPSBmdW5jdGlvbiBjc3MoKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAodmFyIGlkIGluIG1hcmtlcnMpIHtcbiAgICAgIHN0ciArPSBtYXJrZXJzW2lkXS5kYXRhO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICB0aHJvdyBuZXcgU3R5bGVkQ29tcG9uZW50c0Vycm9yKDUpO1xuICAgIH0sXG5cbiAgICBjc3M6IGNzcyxcbiAgICBnZXRJZHM6IGdldElkc0Zyb21NYXJrZXJzRmFjdG9yeShtYXJrZXJzKSxcbiAgICBoYXNOYW1lRm9ySWQ6IGhhc05hbWVGb3JJZChuYW1lcyksXG4gICAgaW5zZXJ0TWFya2VyOiBpbnNlcnRNYXJrZXIsXG4gICAgaW5zZXJ0UnVsZXM6IGluc2VydFJ1bGVzLFxuICAgIHJlbW92ZVJ1bGVzOiByZW1vdmVSdWxlcyxcbiAgICBzZWFsZWQ6IGZhbHNlLFxuICAgIHN0eWxlVGFnOiBlbCxcbiAgICB0b0VsZW1lbnQ6IHdyYXBBc0VsZW1lbnQoY3NzLCBuYW1lcyksXG4gICAgdG9IVE1MOiB3cmFwQXNIdG1sVGFnKGNzcywgbmFtZXMpXG4gIH07XG59O1xuXG52YXIgbWFrZVNlcnZlclRhZyA9IGZ1bmN0aW9uIG1ha2VTZXJ2ZXJUYWcobmFtZXNBcmcsIG1hcmtlcnNBcmcpIHtcbiAgdmFyIG5hbWVzID0gbmFtZXNBcmcgPT09IHVuZGVmaW5lZCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBuYW1lc0FyZztcbiAgdmFyIG1hcmtlcnMgPSBtYXJrZXJzQXJnID09PSB1bmRlZmluZWQgPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbWFya2Vyc0FyZztcblxuICB2YXIgaW5zZXJ0TWFya2VyID0gZnVuY3Rpb24gaW5zZXJ0TWFya2VyKGlkKSB7XG4gICAgdmFyIHByZXYgPSBtYXJrZXJzW2lkXTtcbiAgICBpZiAocHJldiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFya2Vyc1tpZF0gPSBbJyddO1xuICB9O1xuXG4gIHZhciBpbnNlcnRSdWxlcyA9IGZ1bmN0aW9uIGluc2VydFJ1bGVzKGlkLCBjc3NSdWxlcywgbmFtZSkge1xuICAgIHZhciBtYXJrZXIgPSBpbnNlcnRNYXJrZXIoaWQpO1xuICAgIG1hcmtlclswXSArPSBjc3NSdWxlcy5qb2luKCcgJyk7XG4gICAgYWRkTmFtZUZvcklkKG5hbWVzLCBpZCwgbmFtZSk7XG4gIH07XG5cbiAgdmFyIHJlbW92ZVJ1bGVzID0gZnVuY3Rpb24gcmVtb3ZlUnVsZXMoaWQpIHtcbiAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpZF07XG4gICAgaWYgKG1hcmtlciA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgbWFya2VyWzBdID0gJyc7XG4gICAgcmVzZXRJZE5hbWVzKG5hbWVzLCBpZCk7XG4gIH07XG5cbiAgdmFyIGNzcyA9IGZ1bmN0aW9uIGNzcygpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAodmFyIGlkIGluIG1hcmtlcnMpIHtcbiAgICAgIHZhciBjc3NGb3JJZCA9IG1hcmtlcnNbaWRdWzBdO1xuICAgICAgaWYgKGNzc0ZvcklkKSB7XG4gICAgICAgIHN0ciArPSBtYWtlVGV4dE1hcmtlcihpZCkgKyBjc3NGb3JJZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICB2YXIgY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICB2YXIgbmFtZXNDbG9uZSA9IGNsb25lTmFtZXMobmFtZXMpO1xuICAgIHZhciBtYXJrZXJzQ2xvbmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAodmFyIGlkIGluIG1hcmtlcnMpIHtcbiAgICAgIG1hcmtlcnNDbG9uZVtpZF0gPSBbbWFya2Vyc1tpZF1bMF1dO1xuICAgIH1cblxuICAgIHJldHVybiBtYWtlU2VydmVyVGFnKG5hbWVzQ2xvbmUsIG1hcmtlcnNDbG9uZSk7XG4gIH07XG5cbiAgdmFyIHRhZyA9IHtcbiAgICBjbG9uZTogY2xvbmUsXG4gICAgY3NzOiBjc3MsXG4gICAgZ2V0SWRzOiBnZXRJZHNGcm9tTWFya2Vyc0ZhY3RvcnkobWFya2VycyksXG4gICAgaGFzTmFtZUZvcklkOiBoYXNOYW1lRm9ySWQobmFtZXMpLFxuICAgIGluc2VydE1hcmtlcjogaW5zZXJ0TWFya2VyLFxuICAgIGluc2VydFJ1bGVzOiBpbnNlcnRSdWxlcyxcbiAgICByZW1vdmVSdWxlczogcmVtb3ZlUnVsZXMsXG4gICAgc2VhbGVkOiBmYWxzZSxcbiAgICBzdHlsZVRhZzogbnVsbCxcbiAgICB0b0VsZW1lbnQ6IHdyYXBBc0VsZW1lbnQoY3NzLCBuYW1lcyksXG4gICAgdG9IVE1MOiB3cmFwQXNIdG1sVGFnKGNzcywgbmFtZXMpXG4gIH07XG5cbiAgcmV0dXJuIHRhZztcbn07XG5cbnZhciBtYWtlVGFnID0gZnVuY3Rpb24gbWFrZVRhZyh0YXJnZXQsIHRhZ0VsLCBmb3JjZVNlcnZlciwgaW5zZXJ0QmVmb3JlLCBnZXRJbXBvcnRSdWxlVGFnKSB7XG4gIGlmIChJU19CUk9XU0VSICYmICFmb3JjZVNlcnZlcikge1xuICAgIHZhciBlbCA9IG1ha2VTdHlsZVRhZyh0YXJnZXQsIHRhZ0VsLCBpbnNlcnRCZWZvcmUpO1xuXG4gICAgaWYgKERJU0FCTEVfU1BFRURZKSB7XG4gICAgICByZXR1cm4gbWFrZUJyb3dzZXJUYWcoZWwsIGdldEltcG9ydFJ1bGVUYWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWFrZVNwZWVkeVRhZyhlbCwgZ2V0SW1wb3J0UnVsZVRhZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1ha2VTZXJ2ZXJUYWcoKTtcbn07XG5cbnZhciByZWh5ZHJhdGUgPSBmdW5jdGlvbiByZWh5ZHJhdGUodGFnLCBlbHMsIGV4dHJhY3RlZCkge1xuICAvKiBhZGQgYWxsIGV4dHJhY3RlZCBjb21wb25lbnRzIHRvIHRoZSBuZXcgdGFnICovXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHRyYWN0ZWQubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICB2YXIgX2V4dHJhY3RlZCRpID0gZXh0cmFjdGVkW2ldLFxuICAgICAgICBjb21wb25lbnRJZCA9IF9leHRyYWN0ZWQkaS5jb21wb25lbnRJZCxcbiAgICAgICAgY3NzRnJvbURPTSA9IF9leHRyYWN0ZWQkaS5jc3NGcm9tRE9NO1xuXG4gICAgdmFyIGNzc1J1bGVzID0gc3BsaXRCeVJ1bGVzKGNzc0Zyb21ET00pO1xuICAgIHRhZy5pbnNlcnRSdWxlcyhjb21wb25lbnRJZCwgY3NzUnVsZXMpO1xuICB9XG5cbiAgLyogcmVtb3ZlIG9sZCBIVE1MU3R5bGVFbGVtZW50cywgc2luY2UgdGhleSBoYXZlIGJlZW4gcmVoeWRyYXRlZCAqL1xuICBmb3IgKHZhciBfaSA9IDAsIF9sZW4gPSBlbHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pICs9IDEpIHtcbiAgICB2YXIgZWwgPSBlbHNbX2ldO1xuICAgIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIFxuXG52YXIgU1BMSVRfUkVHRVggPSAvXFxzKy87XG5cbi8qIGRldGVybWluZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgY29tcG9uZW50cyBiZWZvcmUgdGFncyBhcmUgc2hhcmRlZCAqL1xudmFyIE1BWF9TSVpFID0gdm9pZCAwO1xuaWYgKElTX0JST1dTRVIpIHtcbiAgLyogaW4gc3BlZWR5IG1vZGUgd2UgY2FuIGtlZXAgYSBsb3QgbW9yZSBydWxlcyBpbiBhIHNoZWV0IGJlZm9yZSBhIHNsb3dkb3duIGNhbiBiZSBleHBlY3RlZCAqL1xuICBNQVhfU0laRSA9IERJU0FCTEVfU1BFRURZID8gNDAgOiAxMDAwO1xufSBlbHNlIHtcbiAgLyogZm9yIHNlcnZlcnMgd2UgZG8gbm90IG5lZWQgdG8gc2hhcmQgYXQgYWxsICovXG4gIE1BWF9TSVpFID0gLTE7XG59XG5cbnZhciBzaGVldFJ1bm5pbmdJZCA9IDA7XG52YXIgbWFzdGVyID0gdm9pZCAwO1xuXG52YXIgU3R5bGVTaGVldCA9IGZ1bmN0aW9uICgpIHtcblxuICAvKiBhIG1hcCBmcm9tIGlkcyB0byB0YWdzICovXG5cbiAgLyogZGVmZXJyZWQgcnVsZXMgZm9yIGEgZ2l2ZW4gaWQgKi9cblxuICAvKiB0aGlzIGlzIHVzZWQgZm9yIG5vdCByZWluamVjdGluZyBydWxlcyB2aWEgaGFzTmFtZUZvcklkKCkgKi9cblxuICAvKiB3aGVuIHJ1bGVzIGZvciBhbiBpZCBhcmUgcmVtb3ZlZCB1c2luZyByZW1vdmUoKSB3ZSBoYXZlIHRvIGlnbm9yZSByZWh5ZHJhdGVkTmFtZXMgZm9yIGl0ICovXG5cbiAgLyogYSBsaXN0IG9mIHRhZ3MgYmVsb25naW5nIHRvIHRoaXMgU3R5bGVTaGVldCAqL1xuXG4gIC8qIGEgdGFnIGZvciBpbXBvcnQgcnVsZXMgKi9cblxuICAvKiBjdXJyZW50IGNhcGFjaXR5IHVudGlsIGEgbmV3IHRhZyBtdXN0IGJlIGNyZWF0ZWQgKi9cblxuICAvKiBjaGlsZHJlbiAoYWthIGNsb25lcykgb2YgdGhpcyBTdHlsZVNoZWV0IGluaGVyaXRpbmcgYWxsIGFuZCBmdXR1cmUgaW5qZWN0aW9ucyAqL1xuXG4gIGZ1bmN0aW9uIFN0eWxlU2hlZXQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciB0YXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IElTX0JST1dTRVIgPyBkb2N1bWVudC5oZWFkIDogbnVsbDtcbiAgICB2YXIgZm9yY2VTZXJ2ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlU2hlZXQpO1xuXG4gICAgdGhpcy5nZXRJbXBvcnRSdWxlVGFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGltcG9ydFJ1bGVUYWcgPSBfdGhpcy5pbXBvcnRSdWxlVGFnO1xuXG4gICAgICBpZiAoaW1wb3J0UnVsZVRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBpbXBvcnRSdWxlVGFnO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlyc3RUYWcgPSBfdGhpcy50YWdzWzBdO1xuICAgICAgdmFyIGluc2VydEJlZm9yZSA9IHRydWU7XG5cbiAgICAgIHJldHVybiBfdGhpcy5pbXBvcnRSdWxlVGFnID0gbWFrZVRhZyhfdGhpcy50YXJnZXQsIGZpcnN0VGFnID8gZmlyc3RUYWcuc3R5bGVUYWcgOiBudWxsLCBfdGhpcy5mb3JjZVNlcnZlciwgaW5zZXJ0QmVmb3JlKTtcbiAgICB9O1xuXG4gICAgc2hlZXRSdW5uaW5nSWQgKz0gMTtcbiAgICB0aGlzLmlkID0gc2hlZXRSdW5uaW5nSWQ7XG4gICAgdGhpcy5mb3JjZVNlcnZlciA9IGZvcmNlU2VydmVyO1xuICAgIHRoaXMudGFyZ2V0ID0gZm9yY2VTZXJ2ZXIgPyBudWxsIDogdGFyZ2V0O1xuICAgIHRoaXMudGFnTWFwID0ge307XG4gICAgdGhpcy5kZWZlcnJlZCA9IHt9O1xuICAgIHRoaXMucmVoeWRyYXRlZE5hbWVzID0ge307XG4gICAgdGhpcy5pZ25vcmVSZWh5ZHJhdGVkTmFtZXMgPSB7fTtcbiAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICB0aGlzLmNhcGFjaXR5ID0gMTtcbiAgICB0aGlzLmNsb25lcyA9IFtdO1xuICB9XG5cbiAgLyogcmVoeWRyYXRlIGFsbCBTU1InZCBzdHlsZSB0YWdzICovXG5cblxuICBTdHlsZVNoZWV0LnByb3RvdHlwZS5yZWh5ZHJhdGUgPSBmdW5jdGlvbiByZWh5ZHJhdGUkJDEoKSB7XG4gICAgaWYgKCFJU19CUk9XU0VSIHx8IHRoaXMuZm9yY2VTZXJ2ZXIpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGVscyA9IFtdO1xuICAgIHZhciBleHRyYWN0ZWQgPSBbXTtcbiAgICB2YXIgaXNTdHJlYW1lZCA9IGZhbHNlO1xuXG4gICAgLyogcmV0cmlldmUgYWxsIG9mIG91ciBTU1Igc3R5bGUgZWxlbWVudHMgZnJvbSB0aGUgRE9NICovXG4gICAgdmFyIG5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbJyArIFNDX0FUVFIgKyAnXVsnICsgU0NfVkVSU0lPTl9BVFRSICsgJz1cIicgKyBcIjQuNC4xXCIgKyAnXCJdJyk7XG5cbiAgICB2YXIgbm9kZXNTaXplID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgLyogYWJvcnQgcmVoeWRyYXRpb24gaWYgbm8gcHJldmlvdXMgc3R5bGUgdGFncyB3ZXJlIGZvdW5kICovXG4gICAgaWYgKCFub2Rlc1NpemUpIHJldHVybiB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlc1NpemU7IGkgKz0gMSkge1xuICAgICAgdmFyIGVsID0gbm9kZXNbaV07XG5cbiAgICAgIC8qIGNoZWNrIGlmIHN0eWxlIHRhZyBpcyBhIHN0cmVhbWVkIHRhZyAqL1xuICAgICAgaWYgKCFpc1N0cmVhbWVkKSBpc1N0cmVhbWVkID0gISFlbC5nZXRBdHRyaWJ1dGUoU0NfU1RSRUFNX0FUVFIpO1xuXG4gICAgICAvKiByZXRyaWV2ZSBhbGwgY29tcG9uZW50IG5hbWVzICovXG4gICAgICB2YXIgZWxOYW1lcyA9IChlbC5nZXRBdHRyaWJ1dGUoU0NfQVRUUikgfHwgJycpLnRyaW0oKS5zcGxpdChTUExJVF9SRUdFWCk7XG4gICAgICB2YXIgZWxOYW1lc1NpemUgPSBlbE5hbWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGogPSAwLCBuYW1lOyBqIDwgZWxOYW1lc1NpemU7IGogKz0gMSkge1xuICAgICAgICBuYW1lID0gZWxOYW1lc1tqXTtcbiAgICAgICAgLyogYWRkIHJlaHlkcmF0ZWQgbmFtZSB0byBzaGVldCB0byBhdm9pZCByZS1hZGRpbmcgc3R5bGVzICovXG4gICAgICAgIHRoaXMucmVoeWRyYXRlZE5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogZXh0cmFjdCBhbGwgY29tcG9uZW50cyBhbmQgdGhlaXIgQ1NTICovXG4gICAgICBleHRyYWN0ZWQucHVzaC5hcHBseShleHRyYWN0ZWQsIGV4dHJhY3RDb21wcyhlbC50ZXh0Q29udGVudCkpO1xuXG4gICAgICAvKiBzdG9yZSBvcmlnaW5hbCBIVE1MU3R5bGVFbGVtZW50ICovXG4gICAgICBlbHMucHVzaChlbCk7XG4gICAgfVxuXG4gICAgLyogYWJvcnQgcmVoeWRyYXRpb24gaWYgbm90aGluZyB3YXMgZXh0cmFjdGVkICovXG4gICAgdmFyIGV4dHJhY3RlZFNpemUgPSBleHRyYWN0ZWQubGVuZ3RoO1xuICAgIGlmICghZXh0cmFjdGVkU2l6ZSkgcmV0dXJuIHRoaXM7XG5cbiAgICAvKiBjcmVhdGUgYSB0YWcgdG8gYmUgdXNlZCBmb3IgcmVoeWRyYXRpb24gKi9cbiAgICB2YXIgdGFnID0gdGhpcy5tYWtlVGFnKG51bGwpO1xuXG4gICAgcmVoeWRyYXRlKHRhZywgZWxzLCBleHRyYWN0ZWQpO1xuXG4gICAgLyogcmVzZXQgY2FwYWNpdHkgYW5kIGFkanVzdCBNQVhfU0laRSBieSB0aGUgaW5pdGlhbCBzaXplIG9mIHRoZSByZWh5ZHJhdGlvbiAqL1xuICAgIHRoaXMuY2FwYWNpdHkgPSBNYXRoLm1heCgxLCBNQVhfU0laRSAtIGV4dHJhY3RlZFNpemUpO1xuICAgIHRoaXMudGFncy5wdXNoKHRhZyk7XG5cbiAgICAvKiByZXRyaWV2ZSBhbGwgY29tcG9uZW50IGlkcyAqL1xuICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBleHRyYWN0ZWRTaXplOyBfaiArPSAxKSB7XG4gICAgICB0aGlzLnRhZ01hcFtleHRyYWN0ZWRbX2pdLmNvbXBvbmVudElkXSA9IHRhZztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKiByZXRyaWV2ZSBhIFwibWFzdGVyXCIgaW5zdGFuY2Ugb2YgU3R5bGVTaGVldCB3aGljaCBpcyB0eXBpY2FsbHkgdXNlZCB3aGVuIG5vIG90aGVyIGlzIGF2YWlsYWJsZVxuICAgKiBUaGUgbWFzdGVyIFN0eWxlU2hlZXQgaXMgdGFyZ2V0ZWQgYnkgY3JlYXRlR2xvYmFsU3R5bGUsIGtleWZyYW1lcywgYW5kIGNvbXBvbmVudHMgb3V0c2lkZSBvZiBhbnlcbiAgICAqIFN0eWxlU2hlZXRNYW5hZ2VyJ3MgY29udGV4dCAqL1xuXG5cbiAgLyogcmVzZXQgdGhlIGludGVybmFsIFwibWFzdGVyXCIgaW5zdGFuY2UgKi9cbiAgU3R5bGVTaGVldC5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHZhciBmb3JjZVNlcnZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICBtYXN0ZXIgPSBuZXcgU3R5bGVTaGVldCh1bmRlZmluZWQsIGZvcmNlU2VydmVyKS5yZWh5ZHJhdGUoKTtcbiAgfTtcblxuICAvKiBhZGRzIFwiY2hpbGRyZW5cIiB0byB0aGUgU3R5bGVTaGVldCB0aGF0IGluaGVyaXQgYWxsIG9mIHRoZSBwYXJlbnRzJyBydWxlc1xuICAgKiB3aGlsZSB0aGVpciBvd24gcnVsZXMgZG8gbm90IGFmZmVjdCB0aGUgcGFyZW50ICovXG5cblxuICBTdHlsZVNoZWV0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHZhciBzaGVldCA9IG5ldyBTdHlsZVNoZWV0KHRoaXMudGFyZ2V0LCB0aGlzLmZvcmNlU2VydmVyKTtcblxuICAgIC8qIGFkZCB0byBjbG9uZSBhcnJheSAqL1xuICAgIHRoaXMuY2xvbmVzLnB1c2goc2hlZXQpO1xuXG4gICAgLyogY2xvbmUgYWxsIHRhZ3MgKi9cbiAgICBzaGVldC50YWdzID0gdGhpcy50YWdzLm1hcChmdW5jdGlvbiAodGFnKSB7XG4gICAgICB2YXIgaWRzID0gdGFnLmdldElkcygpO1xuICAgICAgdmFyIG5ld1RhZyA9IHRhZy5jbG9uZSgpO1xuXG4gICAgICAvKiByZWNvbnN0cnVjdCB0YWdNYXAgKi9cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHNoZWV0LnRhZ01hcFtpZHNbaV1dID0gbmV3VGFnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3VGFnO1xuICAgIH0pO1xuXG4gICAgLyogY2xvbmUgb3RoZXIgbWFwcyAqL1xuICAgIHNoZWV0LnJlaHlkcmF0ZWROYW1lcyA9IF9leHRlbmRzKHt9LCB0aGlzLnJlaHlkcmF0ZWROYW1lcyk7XG4gICAgc2hlZXQuZGVmZXJyZWQgPSBfZXh0ZW5kcyh7fSwgdGhpcy5kZWZlcnJlZCk7XG5cbiAgICByZXR1cm4gc2hlZXQ7XG4gIH07XG5cbiAgLyogZm9yY2UgU3R5bGVTaGVldCB0byBjcmVhdGUgYSBuZXcgdGFnIG9uIHRoZSBuZXh0IGluamVjdGlvbiAqL1xuXG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUuc2VhbEFsbFRhZ3MgPSBmdW5jdGlvbiBzZWFsQWxsVGFncygpIHtcbiAgICB0aGlzLmNhcGFjaXR5ID0gMTtcblxuICAgIHRoaXMudGFncy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgdGFnLnNlYWxlZCA9IHRydWU7XG4gICAgfSk7XG4gIH07XG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUubWFrZVRhZyA9IGZ1bmN0aW9uIG1ha2VUYWckJDEodGFnKSB7XG4gICAgdmFyIGxhc3RFbCA9IHRhZyA/IHRhZy5zdHlsZVRhZyA6IG51bGw7XG4gICAgdmFyIGluc2VydEJlZm9yZSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIG1ha2VUYWcodGhpcy50YXJnZXQsIGxhc3RFbCwgdGhpcy5mb3JjZVNlcnZlciwgaW5zZXJ0QmVmb3JlLCB0aGlzLmdldEltcG9ydFJ1bGVUYWcpO1xuICB9O1xuXG4gIC8qIGdldCBhIHRhZyBmb3IgYSBnaXZlbiBjb21wb25lbnRJZCwgYXNzaWduIHRoZSBjb21wb25lbnRJZCB0byBvbmUsIG9yIHNoYXJkICovXG4gIFN0eWxlU2hlZXQucHJvdG90eXBlLmdldFRhZ0ZvcklkID0gZnVuY3Rpb24gZ2V0VGFnRm9ySWQoaWQpIHtcbiAgICAvKiBzaW1wbHkgcmV0dXJuIGEgdGFnLCB3aGVuIHRoZSBjb21wb25lbnRJZCB3YXMgYWxyZWFkeSBhc3NpZ25lZCBvbmUgKi9cbiAgICB2YXIgcHJldiA9IHRoaXMudGFnTWFwW2lkXTtcbiAgICBpZiAocHJldiAhPT0gdW5kZWZpbmVkICYmICFwcmV2LnNlYWxlZCkge1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfVxuXG4gICAgdmFyIHRhZyA9IHRoaXMudGFnc1t0aGlzLnRhZ3MubGVuZ3RoIC0gMV07XG5cbiAgICAvKiBzaGFyZCAoY3JlYXRlIGEgbmV3IHRhZykgaWYgdGhlIHRhZyBpcyBleGhhdXN0ZWQgKFNlZSBNQVhfU0laRSkgKi9cbiAgICB0aGlzLmNhcGFjaXR5IC09IDE7XG5cbiAgICBpZiAodGhpcy5jYXBhY2l0eSA9PT0gMCkge1xuICAgICAgdGhpcy5jYXBhY2l0eSA9IE1BWF9TSVpFO1xuICAgICAgdGFnID0gdGhpcy5tYWtlVGFnKHRhZyk7XG4gICAgICB0aGlzLnRhZ3MucHVzaCh0YWcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRhZ01hcFtpZF0gPSB0YWc7XG4gIH07XG5cbiAgLyogbWFpbmx5IGZvciBjcmVhdGVHbG9iYWxTdHlsZSB0byBjaGVjayBmb3IgaXRzIGlkICovXG5cblxuICBTdHlsZVNoZWV0LnByb3RvdHlwZS5oYXNJZCA9IGZ1bmN0aW9uIGhhc0lkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnTWFwW2lkXSAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qIGNhY2hpbmcgbGF5ZXIgY2hlY2tpbmcgaWQrbmFtZSB0byBhbHJlYWR5IGhhdmUgYSBjb3JyZXNwb25kaW5nIHRhZyBhbmQgaW5qZWN0ZWQgcnVsZXMgKi9cblxuXG4gIFN0eWxlU2hlZXQucHJvdG90eXBlLmhhc05hbWVGb3JJZCA9IGZ1bmN0aW9uIGhhc05hbWVGb3JJZChpZCwgbmFtZSkge1xuICAgIC8qIGV4Y2VwdGlvbiBmb3IgcmVoeWRyYXRlZCBuYW1lcyB3aGljaCBhcmUgY2hlY2tlZCBzZXBhcmF0ZWx5ICovXG4gICAgaWYgKHRoaXMuaWdub3JlUmVoeWRyYXRlZE5hbWVzW2lkXSA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmVoeWRyYXRlZE5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgdGFnID0gdGhpcy50YWdNYXBbaWRdO1xuICAgIHJldHVybiB0YWcgIT09IHVuZGVmaW5lZCAmJiB0YWcuaGFzTmFtZUZvcklkKGlkLCBuYW1lKTtcbiAgfTtcblxuICAvKiByZWdpc3RlcnMgYSBjb21wb25lbnRJZCBhbmQgcmVnaXN0ZXJzIGl0IG9uIGl0cyB0YWcgKi9cblxuXG4gIFN0eWxlU2hlZXQucHJvdG90eXBlLmRlZmVycmVkSW5qZWN0ID0gZnVuY3Rpb24gZGVmZXJyZWRJbmplY3QoaWQsIGNzc1J1bGVzKSB7XG4gICAgLyogZG9uJ3QgaW5qZWN0IHdoZW4gdGhlIGlkIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCAqL1xuICAgIGlmICh0aGlzLnRhZ01hcFtpZF0gIT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgdmFyIGNsb25lcyA9IHRoaXMuY2xvbmVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNsb25lc1tpXS5kZWZlcnJlZEluamVjdChpZCwgY3NzUnVsZXMpO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0VGFnRm9ySWQoaWQpLmluc2VydE1hcmtlcihpZCk7XG4gICAgdGhpcy5kZWZlcnJlZFtpZF0gPSBjc3NSdWxlcztcbiAgfTtcblxuICAvKiBpbmplY3RzIHJ1bGVzIGZvciBhIGdpdmVuIGlkIHdpdGggYSBuYW1lIHRoYXQgd2lsbCBuZWVkIHRvIGJlIGNhY2hlZCAqL1xuXG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUuaW5qZWN0ID0gZnVuY3Rpb24gaW5qZWN0KGlkLCBjc3NSdWxlcywgbmFtZSkge1xuICAgIHZhciBjbG9uZXMgPSB0aGlzLmNsb25lcztcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNsb25lc1tpXS5pbmplY3QoaWQsIGNzc1J1bGVzLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgdGFnID0gdGhpcy5nZXRUYWdGb3JJZChpZCk7XG5cbiAgICAvKiBhZGQgZGVmZXJyZWQgcnVsZXMgZm9yIGNvbXBvbmVudCAqL1xuICAgIGlmICh0aGlzLmRlZmVycmVkW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBDb21iaW5lIHBhc3NlZCBjc3NSdWxlcyB3aXRoIHByZXZpb3VzbHkgZGVmZXJyZWQgQ1NTIHJ1bGVzXG4gICAgICAvLyBOT1RFOiBXZSBjYW5ub3QgbXV0YXRlIHRoZSBkZWZlcnJlZCBhcnJheSBpdHNlbGYgYXMgYWxsIGNsb25lc1xuICAgICAgLy8gZG8gdGhlIHNhbWUgKHNlZSBjbG9uZXNbaV0uaW5qZWN0KVxuICAgICAgdmFyIHJ1bGVzID0gdGhpcy5kZWZlcnJlZFtpZF0uY29uY2F0KGNzc1J1bGVzKTtcbiAgICAgIHRhZy5pbnNlcnRSdWxlcyhpZCwgcnVsZXMsIG5hbWUpO1xuXG4gICAgICB0aGlzLmRlZmVycmVkW2lkXSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFnLmluc2VydFJ1bGVzKGlkLCBjc3NSdWxlcywgbmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qIHJlbW92ZXMgYWxsIHJ1bGVzIGZvciBhIGdpdmVuIGlkLCB3aGljaCBkb2Vzbid0IHJlbW92ZSBpdHMgbWFya2VyIGJ1dCByZXNldHMgaXQgKi9cblxuXG4gIFN0eWxlU2hlZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShpZCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZ01hcFtpZF07XG4gICAgaWYgKHRhZyA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICB2YXIgY2xvbmVzID0gdGhpcy5jbG9uZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2xvbmVzW2ldLnJlbW92ZShpZCk7XG4gICAgfVxuXG4gICAgLyogcmVtb3ZlIGFsbCBydWxlcyBmcm9tIHRoZSB0YWcgKi9cbiAgICB0YWcucmVtb3ZlUnVsZXMoaWQpO1xuXG4gICAgLyogaWdub3JlIHBvc3NpYmxlIHJlaHlkcmF0ZWQgbmFtZXMgKi9cbiAgICB0aGlzLmlnbm9yZVJlaHlkcmF0ZWROYW1lc1tpZF0gPSB0cnVlO1xuXG4gICAgLyogZGVsZXRlIHBvc3NpYmxlIGRlZmVycmVkIHJ1bGVzICovXG4gICAgdGhpcy5kZWZlcnJlZFtpZF0gPSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUudG9IVE1MID0gZnVuY3Rpb24gdG9IVE1MKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MubWFwKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgIHJldHVybiB0YWcudG9IVE1MKCk7XG4gICAgfSkuam9pbignJyk7XG4gIH07XG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUudG9SZWFjdEVsZW1lbnRzID0gZnVuY3Rpb24gdG9SZWFjdEVsZW1lbnRzKCkge1xuICAgIHZhciBpZCA9IHRoaXMuaWQ7XG5cblxuICAgIHJldHVybiB0aGlzLnRhZ3MubWFwKGZ1bmN0aW9uICh0YWcsIGkpIHtcbiAgICAgIHZhciBrZXkgPSAnc2MtJyArIGlkICsgJy0nICsgaTtcbiAgICAgIHJldHVybiBjbG9uZUVsZW1lbnQodGFnLnRvRWxlbWVudCgpLCB7IGtleToga2V5IH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGNyZWF0ZUNsYXNzKFN0eWxlU2hlZXQsIG51bGwsIFt7XG4gICAga2V5OiAnbWFzdGVyJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiBtYXN0ZXIgfHwgKG1hc3RlciA9IG5ldyBTdHlsZVNoZWV0KCkucmVoeWRyYXRlKCkpO1xuICAgIH1cblxuICAgIC8qIE5PVEU6IFRoaXMgaXMganVzdCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2l0aCBqZXN0LXN0eWxlZC1jb21wb25lbnRzICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luc3RhbmNlJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiBTdHlsZVNoZWV0Lm1hc3RlcjtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5cbi8vIFxuXG52YXIgS2V5ZnJhbWVzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBLZXlmcmFtZXMobmFtZSwgcnVsZXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgS2V5ZnJhbWVzKTtcblxuICAgIHRoaXMuaW5qZWN0ID0gZnVuY3Rpb24gKHN0eWxlU2hlZXQpIHtcbiAgICAgIGlmICghc3R5bGVTaGVldC5oYXNOYW1lRm9ySWQoX3RoaXMuaWQsIF90aGlzLm5hbWUpKSB7XG4gICAgICAgIHN0eWxlU2hlZXQuaW5qZWN0KF90aGlzLmlkLCBfdGhpcy5ydWxlcywgX3RoaXMubmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgU3R5bGVkQ29tcG9uZW50c0Vycm9yKDEyLCBTdHJpbmcoX3RoaXMubmFtZSkpO1xuICAgIH07XG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucnVsZXMgPSBydWxlcztcblxuICAgIHRoaXMuaWQgPSAnc2Mta2V5ZnJhbWVzLScgKyBuYW1lO1xuICB9XG5cbiAgS2V5ZnJhbWVzLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9O1xuXG4gIHJldHVybiBLZXlmcmFtZXM7XG59KCk7XG5cbi8vIFxuXG4vKipcbiAqIGlubGluZWQgdmVyc2lvbiBvZlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9tYXN0ZXIvcGFja2FnZXMvZmJqcy9zcmMvY29yZS9oeXBoZW5hdGVTdHlsZU5hbWUuanNcbiAqL1xuXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG4vLyBcblxuLy8gVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iODdhYWJkZmUxYjc0NjFlNzMzMWFiYjM2MDFkOWU2YmIyNzU0NGJjL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL2Rhbmdlcm91c1N0eWxlVmFsdWUuanNcbmZ1bmN0aW9uIGFkZFVuaXRJZk5lZWRlZChuYW1lLCB2YWx1ZSkge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW1pbGFqYWNrL2VzbGludC1wbHVnaW4tZmxvd3R5cGUtZXJyb3JzL2lzc3Vlcy8xMzNcbiAgLy8gJEZsb3dGaXhNZVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gMCAmJiAhKG5hbWUgaW4gdW5pdGxlc3MpKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnRyaW0oKTtcbn1cblxuLy8gXG5cbi8qKlxuICogSXQncyBmYWxzaXNoIG5vdCBmYWxzeSBiZWNhdXNlIDAgaXMgYWxsb3dlZC5cbiAqL1xudmFyIGlzRmFsc2lzaCA9IGZ1bmN0aW9uIGlzRmFsc2lzaChjaHVuaykge1xuICByZXR1cm4gY2h1bmsgPT09IHVuZGVmaW5lZCB8fCBjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gZmFsc2UgfHwgY2h1bmsgPT09ICcnO1xufTtcblxudmFyIG9ialRvQ3NzQXJyYXkgPSBmdW5jdGlvbiBvYmpUb0Nzc0FycmF5KG9iaiwgcHJldktleSkge1xuICB2YXIgcnVsZXMgPSBbXTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFpc0ZhbHNpc2gob2JqW2tleV0pKSB7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChvYmpba2V5XSkpIHtcbiAgICAgICAgcnVsZXMucHVzaC5hcHBseShydWxlcywgb2JqVG9Dc3NBcnJheShvYmpba2V5XSwga2V5KSk7XG5cbiAgICAgICAgcmV0dXJuIHJ1bGVzO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKG9ialtrZXldKSkge1xuICAgICAgICBydWxlcy5wdXNoKGh5cGhlbmF0ZVN0eWxlTmFtZShrZXkpICsgJzonLCBvYmpba2V5XSwgJzsnKTtcblxuICAgICAgICByZXR1cm4gcnVsZXM7XG4gICAgICB9XG4gICAgICBydWxlcy5wdXNoKGh5cGhlbmF0ZVN0eWxlTmFtZShrZXkpICsgJzogJyArIGFkZFVuaXRJZk5lZWRlZChrZXksIG9ialtrZXldKSArICc7Jyk7XG4gICAgfVxuICAgIHJldHVybiBydWxlcztcbiAgfSk7XG5cbiAgcmV0dXJuIHByZXZLZXkgPyBbcHJldktleSArICcgeyddLmNvbmNhdChydWxlcywgWyd9J10pIDogcnVsZXM7XG59O1xuXG5mdW5jdGlvbiBmbGF0dGVuKGNodW5rLCBleGVjdXRpb25Db250ZXh0LCBzdHlsZVNoZWV0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNodW5rKSkge1xuICAgIHZhciBydWxlU2V0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2h1bmsubGVuZ3RoLCByZXN1bHQ7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgcmVzdWx0ID0gZmxhdHRlbihjaHVua1tpXSwgZXhlY3V0aW9uQ29udGV4dCwgc3R5bGVTaGVldCk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGNvbnRpbnVlO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkgcnVsZVNldC5wdXNoLmFwcGx5KHJ1bGVTZXQsIHJlc3VsdCk7ZWxzZSBydWxlU2V0LnB1c2gocmVzdWx0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnVsZVNldDtcbiAgfVxuXG4gIGlmIChpc0ZhbHNpc2goY2h1bmspKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKiBIYW5kbGUgb3RoZXIgY29tcG9uZW50cyAqL1xuICBpZiAoaXNTdHlsZWRDb21wb25lbnQoY2h1bmspKSB7XG4gICAgcmV0dXJuICcuJyArIGNodW5rLnN0eWxlZENvbXBvbmVudElkO1xuICB9XG5cbiAgLyogRWl0aGVyIGV4ZWN1dGUgb3IgZGVmZXIgdGhlIGZ1bmN0aW9uICovXG4gIGlmIChpc0Z1bmN0aW9uKGNodW5rKSkge1xuICAgIGlmIChpc1N0YXRlbGVzc0Z1bmN0aW9uKGNodW5rKSAmJiBleGVjdXRpb25Db250ZXh0KSB7XG4gICAgICB2YXIgX3Jlc3VsdCA9IGNodW5rKGV4ZWN1dGlvbkNvbnRleHQpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0VsZW1lbnQoX3Jlc3VsdCkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKGdldENvbXBvbmVudE5hbWUoY2h1bmspICsgJyBpcyBub3QgYSBzdHlsZWQgY29tcG9uZW50IGFuZCBjYW5ub3QgYmUgcmVmZXJyZWQgdG8gdmlhIGNvbXBvbmVudCBzZWxlY3Rvci4gU2VlIGh0dHBzOi8vd3d3LnN0eWxlZC1jb21wb25lbnRzLmNvbS9kb2NzL2FkdmFuY2VkI3JlZmVycmluZy10by1vdGhlci1jb21wb25lbnRzIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbGF0dGVuKF9yZXN1bHQsIGV4ZWN1dGlvbkNvbnRleHQsIHN0eWxlU2hlZXQpO1xuICAgIH0gZWxzZSByZXR1cm4gY2h1bms7XG4gIH1cblxuICBpZiAoY2h1bmsgaW5zdGFuY2VvZiBLZXlmcmFtZXMpIHtcbiAgICBpZiAoc3R5bGVTaGVldCkge1xuICAgICAgY2h1bmsuaW5qZWN0KHN0eWxlU2hlZXQpO1xuICAgICAgcmV0dXJuIGNodW5rLmdldE5hbWUoKTtcbiAgICB9IGVsc2UgcmV0dXJuIGNodW5rO1xuICB9XG5cbiAgLyogSGFuZGxlIG9iamVjdHMgKi9cbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoY2h1bmspID8gb2JqVG9Dc3NBcnJheShjaHVuaykgOiBjaHVuay50b1N0cmluZygpO1xufVxuXG4vLyBcblxuZnVuY3Rpb24gY3NzKHN0eWxlcykge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaW50ZXJwb2xhdGlvbnMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgaW50ZXJwb2xhdGlvbnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGlzRnVuY3Rpb24oc3R5bGVzKSB8fCBpc1BsYWluT2JqZWN0KHN0eWxlcykpIHtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgcmV0dXJuIGZsYXR0ZW4oaW50ZXJsZWF2ZShFTVBUWV9BUlJBWSwgW3N0eWxlc10uY29uY2F0KGludGVycG9sYXRpb25zKSkpO1xuICB9XG5cbiAgLy8gJEZsb3dGaXhNZVxuICByZXR1cm4gZmxhdHRlbihpbnRlcmxlYXZlKHN0eWxlcywgaW50ZXJwb2xhdGlvbnMpKTtcbn1cblxuLy8gXG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFdpdGhPcHRpb25zKGNvbXBvbmVudENvbnN0cnVjdG9yLCB0YWcpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IEVNUFRZX09CSkVDVDtcblxuICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0YWcpKSB7XG4gICAgdGhyb3cgbmV3IFN0eWxlZENvbXBvbmVudHNFcnJvcigxLCBTdHJpbmcodGFnKSk7XG4gIH1cblxuICAvKiBUaGlzIGlzIGNhbGxhYmxlIGRpcmVjdGx5IGFzIGEgdGVtcGxhdGUgZnVuY3Rpb24gKi9cbiAgLy8gJEZsb3dGaXhNZTogTm90IHR5cGVkIHRvIGF2b2lkIGRlc3RydWN0dXJpbmcgYXJndW1lbnRzXG4gIHZhciB0ZW1wbGF0ZUZ1bmN0aW9uID0gZnVuY3Rpb24gdGVtcGxhdGVGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29tcG9uZW50Q29uc3RydWN0b3IodGFnLCBvcHRpb25zLCBjc3MuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcblxuICAvKiBJZiBjb25maWcgbWV0aG9kcyBhcmUgY2FsbGVkLCB3cmFwIHVwIGEgbmV3IHRlbXBsYXRlIGZ1bmN0aW9uIGFuZCBtZXJnZSBvcHRpb25zICovXG4gIHRlbXBsYXRlRnVuY3Rpb24ud2l0aENvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICByZXR1cm4gY29uc3RydWN0V2l0aE9wdGlvbnMoY29tcG9uZW50Q29uc3RydWN0b3IsIHRhZywgX2V4dGVuZHMoe30sIG9wdGlvbnMsIGNvbmZpZykpO1xuICB9O1xuXG4gIC8qIE1vZGlmeS9pbmplY3QgbmV3IHByb3BzIGF0IHJ1bnRpbWUgKi9cbiAgdGVtcGxhdGVGdW5jdGlvbi5hdHRycyA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgIHJldHVybiBjb25zdHJ1Y3RXaXRoT3B0aW9ucyhjb21wb25lbnRDb25zdHJ1Y3RvciwgdGFnLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgYXR0cnM6IEFycmF5LnByb3RvdHlwZS5jb25jYXQob3B0aW9ucy5hdHRycywgYXR0cnMpLmZpbHRlcihCb29sZWFuKVxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gdGVtcGxhdGVGdW5jdGlvbjtcbn1cblxuLy8gXG4vLyBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvbXVybXVyaGFzaC1qcy9ibG9iL21hc3Rlci9tdXJtdXJoYXNoMl9nYy5qc1xuZnVuY3Rpb24gbXVybXVyaGFzaChjKSB7XG4gIGZvciAodmFyIGUgPSBjLmxlbmd0aCB8IDAsIGEgPSBlIHwgMCwgZCA9IDAsIGI7IGUgPj0gNDspIHtcbiAgICBiID0gYy5jaGFyQ29kZUF0KGQpICYgMjU1IHwgKGMuY2hhckNvZGVBdCgrK2QpICYgMjU1KSA8PCA4IHwgKGMuY2hhckNvZGVBdCgrK2QpICYgMjU1KSA8PCAxNiB8IChjLmNoYXJDb2RlQXQoKytkKSAmIDI1NSkgPDwgMjQsIGIgPSAxNTQwNDgzNDc3ICogKGIgJiA2NTUzNSkgKyAoKDE1NDA0ODM0NzcgKiAoYiA+Pj4gMTYpICYgNjU1MzUpIDw8IDE2KSwgYiBePSBiID4+PiAyNCwgYiA9IDE1NDA0ODM0NzcgKiAoYiAmIDY1NTM1KSArICgoMTU0MDQ4MzQ3NyAqIChiID4+PiAxNikgJiA2NTUzNSkgPDwgMTYpLCBhID0gMTU0MDQ4MzQ3NyAqIChhICYgNjU1MzUpICsgKCgxNTQwNDgzNDc3ICogKGEgPj4+IDE2KSAmIDY1NTM1KSA8PCAxNikgXiBiLCBlIC09IDQsICsrZDtcbiAgfVxuICBzd2l0Y2ggKGUpIHtcbiAgICBjYXNlIDM6XG4gICAgICBhIF49IChjLmNoYXJDb2RlQXQoZCArIDIpICYgMjU1KSA8PCAxNjtcbiAgICBjYXNlIDI6XG4gICAgICBhIF49IChjLmNoYXJDb2RlQXQoZCArIDEpICYgMjU1KSA8PCA4O1xuICAgIGNhc2UgMTpcbiAgICAgIGEgXj0gYy5jaGFyQ29kZUF0KGQpICYgMjU1LCBhID0gMTU0MDQ4MzQ3NyAqIChhICYgNjU1MzUpICsgKCgxNTQwNDgzNDc3ICogKGEgPj4+IDE2KSAmIDY1NTM1KSA8PCAxNik7XG4gIH1cbiAgYSBePSBhID4+PiAxMztcbiAgYSA9IDE1NDA0ODM0NzcgKiAoYSAmIDY1NTM1KSArICgoMTU0MDQ4MzQ3NyAqIChhID4+PiAxNikgJiA2NTUzNSkgPDwgMTYpO1xuICByZXR1cm4gKGEgXiBhID4+PiAxNSkgPj4+IDA7XG59XG5cbi8vIFxuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG4vKiBUaGlzIGlzIHRoZSBcImNhcGFjaXR5XCIgb2Ygb3VyIGFscGhhYmV0IGkuZS4gMngyNiBmb3IgYWxsIGxldHRlcnMgcGx1cyB0aGVpciBjYXBpdGFsaXNlZFxuICogY291bnRlcnBhcnRzICovXG52YXIgY2hhcnNMZW5ndGggPSA1MjtcblxuLyogc3RhcnQgYXQgNzUgZm9yICdhJyB1bnRpbCAneicgKDI1KSBhbmQgdGhlbiBzdGFydCBhdCA2NSBmb3IgY2FwaXRhbGlzZWQgbGV0dGVycyAqL1xudmFyIGdldEFscGhhYmV0aWNDaGFyID0gZnVuY3Rpb24gZ2V0QWxwaGFiZXRpY0NoYXIoY29kZSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlICsgKGNvZGUgPiAyNSA/IDM5IDogOTcpKTtcbn07XG5cbi8qIGlucHV0IGEgbnVtYmVyLCB1c3VhbGx5IGEgaGFzaCBhbmQgY29udmVydCBpdCB0byBiYXNlLTUyICovXG5mdW5jdGlvbiBnZW5lcmF0ZUFscGhhYmV0aWNOYW1lKGNvZGUpIHtcbiAgdmFyIG5hbWUgPSAnJztcbiAgdmFyIHggPSB2b2lkIDA7XG5cbiAgLyogZ2V0IGEgY2hhciBhbmQgZGl2aWRlIGJ5IGFscGhhYmV0LWxlbmd0aCAqL1xuICBmb3IgKHggPSBjb2RlOyB4ID4gY2hhcnNMZW5ndGg7IHggPSBNYXRoLmZsb29yKHggLyBjaGFyc0xlbmd0aCkpIHtcbiAgICBuYW1lID0gZ2V0QWxwaGFiZXRpY0NoYXIoeCAlIGNoYXJzTGVuZ3RoKSArIG5hbWU7XG4gIH1cblxuICByZXR1cm4gZ2V0QWxwaGFiZXRpY0NoYXIoeCAlIGNoYXJzTGVuZ3RoKSArIG5hbWU7XG59XG5cbi8vIFxuXG5mdW5jdGlvbiBoYXNGdW5jdGlvbk9iamVjdEtleShvYmopIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pbiwgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChpc0Z1bmN0aW9uKG9ialtrZXldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1N0YXRpY1J1bGVzKHJ1bGVzLCBhdHRycykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIHJ1bGUgPSBydWxlc1tpXTtcblxuICAgIC8vIHJlY3Vyc2l2ZSBjYXNlXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocnVsZSkgJiYgIWlzU3RhdGljUnVsZXMocnVsZSwgYXR0cnMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHJ1bGUpICYmICFpc1N0eWxlZENvbXBvbmVudChydWxlKSkge1xuICAgICAgLy8gZnVuY3Rpb25zIGFyZSBhbGxvd2VkIHRvIGJlIHN0YXRpYyBpZiB0aGV5J3JlIGp1c3QgYmVpbmdcbiAgICAgIC8vIHVzZWQgdG8gZ2V0IHRoZSBjbGFzc25hbWUgb2YgYSBuZXN0ZWQgc3R5bGVkIGNvbXBvbmVudFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhdHRycy5zb21lKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oeCkgfHwgaGFzRnVuY3Rpb25PYmplY3RLZXkoeCk7XG4gIH0pKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIFxuXG4vKiBjb21iaW5lcyBoYXNoU3RyIChtdXJtdXJoYXNoKSBhbmQgbmFtZUdlbmVyYXRvciBmb3IgY29udmVuaWVuY2UgKi9cbnZhciBoYXNoZXIgPSBmdW5jdGlvbiBoYXNoZXIoc3RyKSB7XG4gIHJldHVybiBnZW5lcmF0ZUFscGhhYmV0aWNOYW1lKG11cm11cmhhc2goc3RyKSk7XG59O1xuXG4vKlxuIENvbXBvbmVudFN0eWxlIGlzIGFsbCB0aGUgQ1NTLXNwZWNpZmljIHN0dWZmLCBub3RcbiB0aGUgUmVhY3Qtc3BlY2lmaWMgc3R1ZmYuXG4gKi9cblxudmFyIENvbXBvbmVudFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb21wb25lbnRTdHlsZShydWxlcywgYXR0cnMsIGNvbXBvbmVudElkKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcG9uZW50U3R5bGUpO1xuXG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgIHRoaXMuaXNTdGF0aWMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmIGlzU3RhdGljUnVsZXMocnVsZXMsIGF0dHJzKTtcbiAgICB0aGlzLmNvbXBvbmVudElkID0gY29tcG9uZW50SWQ7XG5cbiAgICBpZiAoIVN0eWxlU2hlZXQubWFzdGVyLmhhc0lkKGNvbXBvbmVudElkKSkge1xuICAgICAgU3R5bGVTaGVldC5tYXN0ZXIuZGVmZXJyZWRJbmplY3QoY29tcG9uZW50SWQsIFtdKTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiBGbGF0dGVucyBhIHJ1bGUgc2V0IGludG8gdmFsaWQgQ1NTXG4gICAqIEhhc2hlcyBpdCwgd3JhcHMgdGhlIHdob2xlIGNodW5rIGluIGEgLmhhc2gxMjM0IHt9XG4gICAqIFJldHVybnMgdGhlIGhhc2ggdG8gYmUgaW5qZWN0ZWQgb24gcmVuZGVyKClcbiAgICogKi9cblxuXG4gIENvbXBvbmVudFN0eWxlLnByb3RvdHlwZS5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcyA9IGZ1bmN0aW9uIGdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzKGV4ZWN1dGlvbkNvbnRleHQsIHN0eWxlU2hlZXQpIHtcbiAgICB2YXIgaXNTdGF0aWMgPSB0aGlzLmlzU3RhdGljLFxuICAgICAgICBjb21wb25lbnRJZCA9IHRoaXMuY29tcG9uZW50SWQsXG4gICAgICAgIGxhc3RDbGFzc05hbWUgPSB0aGlzLmxhc3RDbGFzc05hbWU7XG5cbiAgICBpZiAoSVNfQlJPV1NFUiAmJiBpc1N0YXRpYyAmJiB0eXBlb2YgbGFzdENsYXNzTmFtZSA9PT0gJ3N0cmluZycgJiYgc3R5bGVTaGVldC5oYXNOYW1lRm9ySWQoY29tcG9uZW50SWQsIGxhc3RDbGFzc05hbWUpKSB7XG4gICAgICByZXR1cm4gbGFzdENsYXNzTmFtZTtcbiAgICB9XG5cbiAgICB2YXIgZmxhdENTUyA9IGZsYXR0ZW4odGhpcy5ydWxlcywgZXhlY3V0aW9uQ29udGV4dCwgc3R5bGVTaGVldCk7XG4gICAgdmFyIG5hbWUgPSBoYXNoZXIodGhpcy5jb21wb25lbnRJZCArIGZsYXRDU1Muam9pbignJykpO1xuICAgIGlmICghc3R5bGVTaGVldC5oYXNOYW1lRm9ySWQoY29tcG9uZW50SWQsIG5hbWUpKSB7XG4gICAgICBzdHlsZVNoZWV0LmluamVjdCh0aGlzLmNvbXBvbmVudElkLCBzdHJpbmdpZnlSdWxlcyhmbGF0Q1NTLCAnLicgKyBuYW1lLCB1bmRlZmluZWQsIGNvbXBvbmVudElkKSwgbmFtZSk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0Q2xhc3NOYW1lID0gbmFtZTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcblxuICBDb21wb25lbnRTdHlsZS5nZW5lcmF0ZU5hbWUgPSBmdW5jdGlvbiBnZW5lcmF0ZU5hbWUoc3RyKSB7XG4gICAgcmV0dXJuIGhhc2hlcihzdHIpO1xuICB9O1xuXG4gIHJldHVybiBDb21wb25lbnRTdHlsZTtcbn0oKTtcblxuLy8gXG5cbnZhciBMSU1JVCA9IDIwMDtcblxudmFyIGNyZWF0ZVdhcm5Ub29NYW55Q2xhc3NlcyA9IChmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgdmFyIGdlbmVyYXRlZENsYXNzZXMgPSB7fTtcbiAgdmFyIHdhcm5pbmdTZWVuID0gZmFsc2U7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICBpZiAoIXdhcm5pbmdTZWVuKSB7XG4gICAgICBnZW5lcmF0ZWRDbGFzc2VzW2NsYXNzTmFtZV0gPSB0cnVlO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGdlbmVyYXRlZENsYXNzZXMpLmxlbmd0aCA+PSBMSU1JVCkge1xuICAgICAgICAvLyBVbmFibGUgdG8gZmluZCBsYXRlc3RSdWxlIGluIHRlc3QgZW52aXJvbm1lbnQuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUsIHByZWZlci10ZW1wbGF0ZSAqL1xuICAgICAgICBjb25zb2xlLndhcm4oJ092ZXIgJyArIExJTUlUICsgJyBjbGFzc2VzIHdlcmUgZ2VuZXJhdGVkIGZvciBjb21wb25lbnQgJyArIGRpc3BsYXlOYW1lICsgJy4gXFxuJyArICdDb25zaWRlciB1c2luZyB0aGUgYXR0cnMgbWV0aG9kLCB0b2dldGhlciB3aXRoIGEgc3R5bGUgb2JqZWN0IGZvciBmcmVxdWVudGx5IGNoYW5nZWQgc3R5bGVzLlxcbicgKyAnRXhhbXBsZTpcXG4nICsgJyAgY29uc3QgQ29tcG9uZW50ID0gc3R5bGVkLmRpdi5hdHRycyhwcm9wcyA9PiAoe1xcbicgKyAnICAgIHN0eWxlOiB7XFxuJyArICcgICAgICBiYWNrZ3JvdW5kOiBwcm9wcy5iYWNrZ3JvdW5kLFxcbicgKyAnICAgIH0sXFxuJyArICcgIH0pKWB3aWR0aDogMTAwJTtgXFxuXFxuJyArICcgIDxDb21wb25lbnQgLz4nKTtcbiAgICAgICAgd2FybmluZ1NlZW4gPSB0cnVlO1xuICAgICAgICBnZW5lcmF0ZWRDbGFzc2VzID0ge307XG4gICAgICB9XG4gICAgfVxuICB9O1xufSk7XG5cbi8vIFxuXG52YXIgZGV0ZXJtaW5lVGhlbWUgPSAoZnVuY3Rpb24gKHByb3BzLCBmYWxsYmFja1RoZW1lKSB7XG4gIHZhciBkZWZhdWx0UHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IEVNUFRZX09CSkVDVDtcblxuICAvLyBQcm9wcyBzaG91bGQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgVGhlbWVQcm92aWRlciwgd2hpY2ggc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyXG4gIC8vIGRlZmF1bHRQcm9wcywgYnV0IFJlYWN0IGF1dG9tYXRpY2FsbHkgcHV0cyBkZWZhdWx0UHJvcHMgb24gcHJvcHMuXG5cbiAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJvcC10eXBlcywgZmxvd3R5cGUtZXJyb3JzL3Nob3ctZXJyb3JzICovXG4gIHZhciBpc0RlZmF1bHRUaGVtZSA9IGRlZmF1bHRQcm9wcyA/IHByb3BzLnRoZW1lID09PSBkZWZhdWx0UHJvcHMudGhlbWUgOiBmYWxzZTtcbiAgdmFyIHRoZW1lID0gcHJvcHMudGhlbWUgJiYgIWlzRGVmYXVsdFRoZW1lID8gcHJvcHMudGhlbWUgOiBmYWxsYmFja1RoZW1lIHx8IGRlZmF1bHRQcm9wcy50aGVtZTtcbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gIHJldHVybiB0aGVtZTtcbn0pO1xuXG4vLyBcbnZhciBlc2NhcGVSZWdleCA9IC9bW1xcXS4jKiQ+PCt+PXxeOigpLFwiJ2AtXSsvZztcbnZhciBkYXNoZXNBdEVuZHMgPSAvKF4tfC0kKS9nO1xuXG4vKipcbiAqIFRPRE86IEV4cGxvcmUgdXNpbmcgQ1NTLmVzY2FwZSB3aGVuIGl0IGJlY29tZXMgbW9yZSBhdmFpbGFibGVcbiAqIGluIGV2ZXJncmVlbiBicm93c2Vycy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlKHN0cikge1xuICByZXR1cm4gc3RyXG4gIC8vIFJlcGxhY2UgYWxsIHBvc3NpYmxlIENTUyBzZWxlY3RvcnNcbiAgLnJlcGxhY2UoZXNjYXBlUmVnZXgsICctJylcblxuICAvLyBSZW1vdmUgZXh0cmFuZW91cyBoeXBoZW5zIGF0IHRoZSBzdGFydCBhbmQgZW5kXG4gIC5yZXBsYWNlKGRhc2hlc0F0RW5kcywgJycpO1xufVxuXG4vLyBcblxuZnVuY3Rpb24gaXNUYWcodGFyZ2V0KSB7XG4gIHJldHVybiB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyAmJiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHRhcmdldC5jaGFyQXQoMCkgPT09IHRhcmdldC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSA6IHRydWUpO1xufVxuXG4vLyBcblxuZnVuY3Rpb24gZ2VuZXJhdGVEaXNwbGF5TmFtZSh0YXJnZXQpIHtcbiAgLy8gJEZsb3dGaXhNZVxuICByZXR1cm4gaXNUYWcodGFyZ2V0KSA/ICdzdHlsZWQuJyArIHRhcmdldCA6ICdTdHlsZWQoJyArIGdldENvbXBvbmVudE5hbWUodGFyZ2V0KSArICcpJztcbn1cblxudmFyIF9UWVBFX1NUQVRJQ1M7XG5cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgY29udGV4dFR5cGVzOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gIG5hbWU6IHRydWUsXG4gIGxlbmd0aDogdHJ1ZSxcbiAgcHJvdG90eXBlOiB0cnVlLFxuICBjYWxsZXI6IHRydWUsXG4gIGNhbGxlZTogdHJ1ZSxcbiAgYXJndW1lbnRzOiB0cnVlLFxuICBhcml0eTogdHJ1ZVxufTtcblxudmFyIFRZUEVfU1RBVElDUyA9IChfVFlQRV9TVEFUSUNTID0ge30sIF9UWVBFX1NUQVRJQ1NbRm9yd2FyZFJlZl0gPSB7XG4gICQkdHlwZW9mOiB0cnVlLFxuICByZW5kZXI6IHRydWVcbn0sIF9UWVBFX1NUQVRJQ1MpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsXG4gICAgX09iamVjdCRnZXRPd25Qcm9wZXJ0ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBfT2JqZWN0JGdldE93blByb3BlcnQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFtdO1xufSA6IF9PYmplY3QkZ2V0T3duUHJvcGVydCxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgIG9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgYXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cblxuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuXG4gICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCwgYmxhY2tsaXN0KTtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IGFycmF5UHJvdG90eXBlLmNvbmNhdChnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCksXG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcblxuICAgIHZhciB0YXJnZXRTdGF0aWNzID0gVFlQRV9TVEFUSUNTW3RhcmdldENvbXBvbmVudC4kJHR5cGVvZl0gfHwgUkVBQ1RfU1RBVElDUztcblxuICAgIHZhciBzb3VyY2VTdGF0aWNzID0gVFlQRV9TVEFUSUNTW3NvdXJjZUNvbXBvbmVudC4kJHR5cGVvZl0gfHwgUkVBQ1RfU1RBVElDUztcblxuICAgIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSB2b2lkIDA7XG4gICAgdmFyIGtleSA9IHZvaWQgMDtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wbHVzcGx1c1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICFLTk9XTl9TVEFUSUNTW2tleV0gJiYgIShibGFja2xpc3QgJiYgYmxhY2tsaXN0W2tleV0pICYmICEoc291cmNlU3RhdGljcyAmJiBzb3VyY2VTdGF0aWNzW2tleV0pICYmXG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcblxuICAgICAgICBpZiAoZGVzY3JpcHRvcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSQxKHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiBmYWlsIHNpbGVudGx5ICovXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59XG5cbi8vIFxuZnVuY3Rpb24gaXNEZXJpdmVkUmVhY3RDb21wb25lbnQoZm4pIHtcbiAgcmV0dXJuICEhKGZuICYmIGZuLnByb3RvdHlwZSAmJiBmbi5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbi8vIFxuLy8gSGVscGVyIHRvIGNhbGwgYSBnaXZlbiBmdW5jdGlvbiwgb25seSBvbmNlXG52YXIgb25jZSA9IChmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBjYi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xufSk7XG5cbi8vIFxuXG52YXIgVGhlbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgpO1xuXG52YXIgVGhlbWVDb25zdW1lciA9IFRoZW1lQ29udGV4dC5Db25zdW1lcjtcblxuLyoqXG4gKiBQcm92aWRlIGEgdGhlbWUgdG8gYW4gZW50aXJlIHJlYWN0IGNvbXBvbmVudCB0cmVlIHZpYSBjb250ZXh0XG4gKi9cblxudmFyIFRoZW1lUHJvdmlkZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhUaGVtZVByb3ZpZGVyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUaGVtZVByb3ZpZGVyKHByb3BzKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGhlbWVQcm92aWRlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgX3RoaXMuZ2V0Q29udGV4dCA9IG1lbW9pemUoX3RoaXMuZ2V0Q29udGV4dC5iaW5kKF90aGlzKSk7XG4gICAgX3RoaXMucmVuZGVySW5uZXIgPSBfdGhpcy5yZW5kZXJJbm5lci5iaW5kKF90aGlzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUaGVtZVByb3ZpZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLnByb3BzLmNoaWxkcmVuKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgVGhlbWVDb250ZXh0LkNvbnN1bWVyLFxuICAgICAgbnVsbCxcbiAgICAgIHRoaXMucmVuZGVySW5uZXJcbiAgICApO1xuICB9O1xuXG4gIFRoZW1lUHJvdmlkZXIucHJvdG90eXBlLnJlbmRlcklubmVyID0gZnVuY3Rpb24gcmVuZGVySW5uZXIob3V0ZXJUaGVtZSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KHRoaXMucHJvcHMudGhlbWUsIG91dGVyVGhlbWUpO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBUaGVtZUNvbnRleHQuUHJvdmlkZXIsXG4gICAgICB7IHZhbHVlOiBjb250ZXh0IH0sXG4gICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB0aGVtZSBmcm9tIHRoZSBwcm9wcywgc3VwcG9ydGluZyBib3RoIChvdXRlclRoZW1lKSA9PiB7fVxuICAgKiBhcyB3ZWxsIGFzIG9iamVjdCBub3RhdGlvblxuICAgKi9cblxuXG4gIFRoZW1lUHJvdmlkZXIucHJvdG90eXBlLmdldFRoZW1lID0gZnVuY3Rpb24gZ2V0VGhlbWUodGhlbWUsIG91dGVyVGhlbWUpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih0aGVtZSkpIHtcbiAgICAgIHZhciBtZXJnZWRUaGVtZSA9IHRoZW1lKG91dGVyVGhlbWUpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAobWVyZ2VkVGhlbWUgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShtZXJnZWRUaGVtZSkgfHwgKHR5cGVvZiBtZXJnZWRUaGVtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobWVyZ2VkVGhlbWUpKSAhPT0gJ29iamVjdCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBTdHlsZWRDb21wb25lbnRzRXJyb3IoNyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXJnZWRUaGVtZTtcbiAgICB9XG5cbiAgICBpZiAodGhlbWUgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheSh0aGVtZSkgfHwgKHR5cGVvZiB0aGVtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodGhlbWUpKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBTdHlsZWRDb21wb25lbnRzRXJyb3IoOCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBvdXRlclRoZW1lLCB0aGVtZSk7XG4gIH07XG5cbiAgVGhlbWVQcm92aWRlci5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIGdldENvbnRleHQodGhlbWUsIG91dGVyVGhlbWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaGVtZSh0aGVtZSwgb3V0ZXJUaGVtZSk7XG4gIH07XG5cbiAgcmV0dXJuIFRoZW1lUHJvdmlkZXI7XG59KENvbXBvbmVudCk7XG5cbi8vIFxuXG52YXIgQ0xPU0lOR19UQUdfUiA9IC9eXFxzKjxcXC9bYS16XS9pO1xuXG52YXIgU2VydmVyU3R5bGVTaGVldCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2VydmVyU3R5bGVTaGVldCgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTZXJ2ZXJTdHlsZVNoZWV0KTtcblxuICAgIC8qIFRoZSBtYXN0ZXIgc2hlZXQgbWlnaHQgYmUgcmVzZXQsIHNvIGtlZXAgYSByZWZlcmVuY2UgaGVyZSAqL1xuICAgIHRoaXMubWFzdGVyU2hlZXQgPSBTdHlsZVNoZWV0Lm1hc3RlcjtcbiAgICB0aGlzLmluc3RhbmNlID0gdGhpcy5tYXN0ZXJTaGVldC5jbG9uZSgpO1xuICAgIHRoaXMuc2VhbGVkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogTWFyayB0aGUgU2VydmVyU3R5bGVTaGVldCBhcyBiZWluZyBmdWxseSBlbWl0dGVkIGFuZCBtYW51YWxseSBHQyBpdCBmcm9tIHRoZVxuICAgKiBTdHlsZVNoZWV0IHNpbmdsZXRvbi5cbiAgICovXG5cblxuICBTZXJ2ZXJTdHlsZVNoZWV0LnByb3RvdHlwZS5zZWFsID0gZnVuY3Rpb24gc2VhbCgpIHtcbiAgICBpZiAoIXRoaXMuc2VhbGVkKSB7XG4gICAgICAvKiBSZW1vdmUgc2VhbGVkIFN0eWxlU2hlZXRzIGZyb20gdGhlIG1hc3RlciBzaGVldCAqL1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5tYXN0ZXJTaGVldC5jbG9uZXMuaW5kZXhPZih0aGlzLmluc3RhbmNlKTtcbiAgICAgIHRoaXMubWFzdGVyU2hlZXQuY2xvbmVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB0aGlzLnNlYWxlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIFNlcnZlclN0eWxlU2hlZXQucHJvdG90eXBlLmNvbGxlY3RTdHlsZXMgPSBmdW5jdGlvbiBjb2xsZWN0U3R5bGVzKGNoaWxkcmVuKSB7XG4gICAgaWYgKHRoaXMuc2VhbGVkKSB7XG4gICAgICB0aHJvdyBuZXcgU3R5bGVkQ29tcG9uZW50c0Vycm9yKDIpO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgU3R5bGVTaGVldE1hbmFnZXIsXG4gICAgICB7IHNoZWV0OiB0aGlzLmluc3RhbmNlIH0sXG4gICAgICBjaGlsZHJlblxuICAgICk7XG4gIH07XG5cbiAgU2VydmVyU3R5bGVTaGVldC5wcm90b3R5cGUuZ2V0U3R5bGVUYWdzID0gZnVuY3Rpb24gZ2V0U3R5bGVUYWdzKCkge1xuICAgIHRoaXMuc2VhbCgpO1xuICAgIHJldHVybiB0aGlzLmluc3RhbmNlLnRvSFRNTCgpO1xuICB9O1xuXG4gIFNlcnZlclN0eWxlU2hlZXQucHJvdG90eXBlLmdldFN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uIGdldFN0eWxlRWxlbWVudCgpIHtcbiAgICB0aGlzLnNlYWwoKTtcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS50b1JlYWN0RWxlbWVudHMoKTtcbiAgfTtcblxuICBTZXJ2ZXJTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnRlcmxlYXZlV2l0aE5vZGVTdHJlYW0gPSBmdW5jdGlvbiBpbnRlcmxlYXZlV2l0aE5vZGVTdHJlYW0ocmVhZGFibGVTdHJlYW0pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAge1xuICAgICAgdGhyb3cgbmV3IFN0eWxlZENvbXBvbmVudHNFcnJvcigzKTtcbiAgICB9XG5cbiAgICAvKiB0aGUgdGFnIGluZGV4IGtlZXBzIHRyYWNrIG9mIHdoaWNoIHRhZ3MgaGF2ZSBhbHJlYWR5IGJlZW4gZW1pdHRlZCAqL1xuICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2U7XG5cbiAgICB2YXIgaW5zdGFuY2VUYWdJbmRleCA9IDA7XG5cbiAgICB2YXIgc3RyZWFtQXR0ciA9IFNDX1NUUkVBTV9BVFRSICsgJz1cInRydWVcIic7XG5cbiAgICB2YXIgdHJhbnNmb3JtZXIgPSBuZXcgc3RyZWFtLlRyYW5zZm9ybSh7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIGFwcGVuZFN0eWxlQ2h1bmtzKGNodW5rLCAvKiBlbmNvZGluZyAqL18sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0YWdzID0gaW5zdGFuY2UudGFncztcblxuICAgICAgICB2YXIgaHRtbCA9ICcnO1xuXG4gICAgICAgIC8qIHJldHJpZXZlIGh0bWwgZm9yIGVhY2ggbmV3IHN0eWxlIHRhZyAqL1xuICAgICAgICBmb3IgKDsgaW5zdGFuY2VUYWdJbmRleCA8IHRhZ3MubGVuZ3RoOyBpbnN0YW5jZVRhZ0luZGV4ICs9IDEpIHtcbiAgICAgICAgICB2YXIgdGFnID0gdGFnc1tpbnN0YW5jZVRhZ0luZGV4XTtcbiAgICAgICAgICBodG1sICs9IHRhZy50b0hUTUwoc3RyZWFtQXR0cik7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBmb3JjZSBvdXIgU3R5bGVTaGVldHMgdG8gZW1pdCBlbnRpcmVseSBuZXcgdGFncyAqL1xuICAgICAgICBpbnN0YW5jZS5zZWFsQWxsVGFncygpO1xuXG4gICAgICAgIHZhciByZW5kZXJlZEh0bWwgPSBjaHVuay50b1N0cmluZygpO1xuXG4gICAgICAgIC8qIHByZXBlbmQgc3R5bGUgaHRtbCB0byBjaHVuaywgdW5sZXNzIHRoZSBzdGFydCBvZiB0aGUgY2h1bmsgaXMgYSBjbG9zaW5nIHRhZyBpbiB3aGljaCBjYXNlIGFwcGVuZCByaWdodCBhZnRlciB0aGF0ICovXG4gICAgICAgIGlmIChDTE9TSU5HX1RBR19SLnRlc3QocmVuZGVyZWRIdG1sKSkge1xuICAgICAgICAgIHZhciBlbmRPZkNsb3NpbmdUYWcgPSByZW5kZXJlZEh0bWwuaW5kZXhPZignPicpO1xuXG4gICAgICAgICAgdGhpcy5wdXNoKHJlbmRlcmVkSHRtbC5zbGljZSgwLCBlbmRPZkNsb3NpbmdUYWcgKyAxKSArIGh0bWwgKyByZW5kZXJlZEh0bWwuc2xpY2UoZW5kT2ZDbG9zaW5nVGFnICsgMSkpO1xuICAgICAgICB9IGVsc2UgdGhpcy5wdXNoKGh0bWwgKyByZW5kZXJlZEh0bWwpO1xuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFkYWJsZVN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnNlYWwoKTtcbiAgICB9KTtcblxuICAgIHJlYWRhYmxlU3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIF90aGlzLnNlYWwoKTtcblxuICAgICAgLy8gZm9yd2FyZCB0aGUgZXJyb3IgdG8gdGhlIHRyYW5zZm9ybSBzdHJlYW1cbiAgICAgIHRyYW5zZm9ybWVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZWFkYWJsZVN0cmVhbS5waXBlKHRyYW5zZm9ybWVyKTtcbiAgfTtcblxuICByZXR1cm4gU2VydmVyU3R5bGVTaGVldDtcbn0oKTtcblxuLy8gXG5cbnZhciBTdHlsZVNoZWV0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoKTtcbnZhciBTdHlsZVNoZWV0Q29uc3VtZXIgPSBTdHlsZVNoZWV0Q29udGV4dC5Db25zdW1lcjtcblxudmFyIFN0eWxlU2hlZXRNYW5hZ2VyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoU3R5bGVTaGVldE1hbmFnZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN0eWxlU2hlZXRNYW5hZ2VyKHByb3BzKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3R5bGVTaGVldE1hbmFnZXIpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLmdldENvbnRleHQgPSBtZW1vaXplKF90aGlzLmdldENvbnRleHQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFN0eWxlU2hlZXRNYW5hZ2VyLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q29udGV4dChzaGVldCwgdGFyZ2V0KSB7XG4gICAgaWYgKHNoZWV0KSB7XG4gICAgICByZXR1cm4gc2hlZXQ7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBuZXcgU3R5bGVTaGVldCh0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgU3R5bGVkQ29tcG9uZW50c0Vycm9yKDQpO1xuICAgIH1cbiAgfTtcblxuICBTdHlsZVNoZWV0TWFuYWdlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgc2hlZXQgPSBfcHJvcHMuc2hlZXQsXG4gICAgICAgIHRhcmdldCA9IF9wcm9wcy50YXJnZXQ7XG5cblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgU3R5bGVTaGVldENvbnRleHQuUHJvdmlkZXIsXG4gICAgICB7IHZhbHVlOiB0aGlzLmdldENvbnRleHQoc2hlZXQsIHRhcmdldCkgfSxcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSA6IGNoaWxkcmVuXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gU3R5bGVTaGVldE1hbmFnZXI7XG59KENvbXBvbmVudCk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBTdHlsZVNoZWV0TWFuYWdlci5wcm9wVHlwZXMgPSB7XG4gIHNoZWV0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuaW5zdGFuY2VPZihTdHlsZVNoZWV0KSwgUHJvcFR5cGVzLmluc3RhbmNlT2YoU2VydmVyU3R5bGVTaGVldCldKSxcblxuICB0YXJnZXQ6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgYXBwZW5kQ2hpbGQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfSlcbn0gOiB2b2lkIDA7XG5cbi8vIFxuXG52YXIgaWRlbnRpZmllcnMgPSB7fTtcblxuLyogV2UgZGVwZW5kIG9uIGNvbXBvbmVudHMgaGF2aW5nIHVuaXF1ZSBJRHMgKi9cbmZ1bmN0aW9uIGdlbmVyYXRlSWQoX0NvbXBvbmVudFN0eWxlLCBfZGlzcGxheU5hbWUsIHBhcmVudENvbXBvbmVudElkKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiBfZGlzcGxheU5hbWUgIT09ICdzdHJpbmcnID8gJ3NjJyA6IGVzY2FwZShfZGlzcGxheU5hbWUpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGVuc3VyZXMgdW5pcXVlbmVzcyBpZiB0d28gY29tcG9uZW50cyBoYXBwZW4gdG8gc2hhcmVcbiAgICogdGhlIHNhbWUgZGlzcGxheU5hbWUuXG4gICAqL1xuICB2YXIgbnIgPSAoaWRlbnRpZmllcnNbZGlzcGxheU5hbWVdIHx8IDApICsgMTtcbiAgaWRlbnRpZmllcnNbZGlzcGxheU5hbWVdID0gbnI7XG5cbiAgdmFyIGNvbXBvbmVudElkID0gZGlzcGxheU5hbWUgKyAnLScgKyBfQ29tcG9uZW50U3R5bGUuZ2VuZXJhdGVOYW1lKGRpc3BsYXlOYW1lICsgbnIpO1xuXG4gIHJldHVybiBwYXJlbnRDb21wb25lbnRJZCA/IHBhcmVudENvbXBvbmVudElkICsgJy0nICsgY29tcG9uZW50SWQgOiBjb21wb25lbnRJZDtcbn1cblxuLy8gJEZsb3dGaXhNZVxuXG52YXIgU3R5bGVkQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoU3R5bGVkQ29tcG9uZW50LCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTdHlsZWRDb21wb25lbnQoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3R5bGVkQ29tcG9uZW50KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLmF0dHJzID0ge307XG5cbiAgICBfdGhpcy5yZW5kZXJPdXRlciA9IF90aGlzLnJlbmRlck91dGVyLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLnJlbmRlcklubmVyID0gX3RoaXMucmVuZGVySW5uZXIuYmluZChfdGhpcyk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgX3RoaXMud2FybklubmVyUmVmID0gb25jZShmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIFwiaW5uZXJSZWZcIiBBUEkgaGFzIGJlZW4gcmVtb3ZlZCBpbiBzdHlsZWQtY29tcG9uZW50cyB2NCBpbiBmYXZvciBvZiBSZWFjdCAxNiByZWYgZm9yd2FyZGluZywgdXNlIFwicmVmXCIgaW5zdGVhZCBsaWtlIGEgdHlwaWNhbCBjb21wb25lbnQuIFwiaW5uZXJSZWZcIiB3YXMgZGV0ZWN0ZWQgb24gY29tcG9uZW50IFwiJyArIGRpc3BsYXlOYW1lICsgJ1wiLicpXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgX3RoaXMud2FybkF0dHJzRm5PYmplY3RLZXlEZXByZWNhdGVkID0gb25jZShmdW5jdGlvbiAoa2V5LCBkaXNwbGF5TmFtZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS53YXJuKCdGdW5jdGlvbnMgYXMgb2JqZWN0LWZvcm0gYXR0cnMoe30pIGtleXMgYXJlIG5vdyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBzdHlsZWQtY29tcG9uZW50cy4gU3dpdGNoIHRvIHRoZSBuZXcgYXR0cnMocHJvcHMgPT4gKHt9KSkgc3ludGF4IGluc3RlYWQgZm9yIGVhc2llciBhbmQgbW9yZSBwb3dlcmZ1bCBjb21wb3NpdGlvbi4gVGhlIGF0dHJzIGtleSBpbiBxdWVzdGlvbiBpcyBcIicgKyBrZXkgKyAnXCIgb24gY29tcG9uZW50IFwiJyArIGRpc3BsYXlOYW1lICsgJ1wiLicsICdcXG4gJyArIG5ldyBFcnJvcigpLnN0YWNrKVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLndhcm5Ob25TdHlsZWRDb21wb25lbnRBdHRyc09iamVjdEtleSA9IG9uY2UoZnVuY3Rpb24gKGtleSwgZGlzcGxheU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIGNvbnNvbGUud2FybignSXQgbG9va3MgbGlrZSB5b3VcXCd2ZSB1c2VkIGEgbm9uIHN0eWxlZC1jb21wb25lbnQgYXMgdGhlIHZhbHVlIGZvciB0aGUgXCInICsga2V5ICsgJ1wiIHByb3AgaW4gYW4gb2JqZWN0LWZvcm0gYXR0cnMgY29uc3RydWN0b3Igb2YgXCInICsgZGlzcGxheU5hbWUgKyAnXCIuXFxuJyArICdZb3Ugc2hvdWxkIHVzZSB0aGUgbmV3IGZ1bmN0aW9uLWZvcm0gYXR0cnMgY29uc3RydWN0b3Igd2hpY2ggYXZvaWRzIHRoaXMgaXNzdWU6IGF0dHJzKHByb3BzID0+ICh7IHlvdXJTdHVmZiB9KSlcXG4nICsgXCJUbyBjb250aW51ZSB1c2luZyB0aGUgZGVwcmVjYXRlZCBvYmplY3Qgc3ludGF4LCB5b3UnbGwgbmVlZCB0byB3cmFwIHlvdXIgY29tcG9uZW50IHByb3AgaW4gYSBmdW5jdGlvbiB0byBtYWtlIGl0IGF2YWlsYWJsZSBpbnNpZGUgdGhlIHN0eWxlZCBjb21wb25lbnQgKHlvdSdsbCBzdGlsbCBnZXQgdGhlIGRlcHJlY2F0aW9uIHdhcm5pbmcgdGhvdWdoLilcXG5cIiArICgnRm9yIGV4YW1wbGUsIHsgJyArIGtleSArICc6ICgpID0+IElubmVyQ29tcG9uZW50IH0gaW5zdGVhZCBvZiB7ICcgKyBrZXkgKyAnOiBJbm5lckNvbXBvbmVudCB9JykpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU3R5bGVkQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBTdHlsZVNoZWV0Q29uc3VtZXIsXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5yZW5kZXJPdXRlclxuICAgICk7XG4gIH07XG5cbiAgU3R5bGVkQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJPdXRlciA9IGZ1bmN0aW9uIHJlbmRlck91dGVyKCkge1xuICAgIHZhciBzdHlsZVNoZWV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBTdHlsZVNoZWV0Lm1hc3RlcjtcblxuICAgIHRoaXMuc3R5bGVTaGVldCA9IHN0eWxlU2hlZXQ7XG5cbiAgICAvLyBObyBuZWVkIHRvIHN1YnNjcmliZSBhIHN0YXRpYyBjb21wb25lbnQgdG8gdGhlbWUgY2hhbmdlcywgaXQgd29uJ3QgY2hhbmdlIGFueXRoaW5nXG4gICAgaWYgKHRoaXMucHJvcHMuZm9yd2FyZGVkQ29tcG9uZW50LmNvbXBvbmVudFN0eWxlLmlzU3RhdGljKSByZXR1cm4gdGhpcy5yZW5kZXJJbm5lcigpO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBUaGVtZUNvbnN1bWVyLFxuICAgICAgbnVsbCxcbiAgICAgIHRoaXMucmVuZGVySW5uZXJcbiAgICApO1xuICB9O1xuXG4gIFN0eWxlZENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVySW5uZXIgPSBmdW5jdGlvbiByZW5kZXJJbm5lcih0aGVtZSkge1xuICAgIHZhciBfcHJvcHMkZm9yd2FyZGVkQ29tcG8gPSB0aGlzLnByb3BzLmZvcndhcmRlZENvbXBvbmVudCxcbiAgICAgICAgY29tcG9uZW50U3R5bGUgPSBfcHJvcHMkZm9yd2FyZGVkQ29tcG8uY29tcG9uZW50U3R5bGUsXG4gICAgICAgIGRlZmF1bHRQcm9wcyA9IF9wcm9wcyRmb3J3YXJkZWRDb21wby5kZWZhdWx0UHJvcHMsXG4gICAgICAgIGRpc3BsYXlOYW1lID0gX3Byb3BzJGZvcndhcmRlZENvbXBvLmRpc3BsYXlOYW1lLFxuICAgICAgICBmb2xkZWRDb21wb25lbnRJZHMgPSBfcHJvcHMkZm9yd2FyZGVkQ29tcG8uZm9sZGVkQ29tcG9uZW50SWRzLFxuICAgICAgICBzdHlsZWRDb21wb25lbnRJZCA9IF9wcm9wcyRmb3J3YXJkZWRDb21wby5zdHlsZWRDb21wb25lbnRJZCxcbiAgICAgICAgdGFyZ2V0ID0gX3Byb3BzJGZvcndhcmRlZENvbXBvLnRhcmdldDtcblxuXG4gICAgdmFyIGdlbmVyYXRlZENsYXNzTmFtZSA9IHZvaWQgMDtcbiAgICBpZiAoY29tcG9uZW50U3R5bGUuaXNTdGF0aWMpIHtcbiAgICAgIGdlbmVyYXRlZENsYXNzTmFtZSA9IHRoaXMuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMoRU1QVFlfT0JKRUNULCB0aGlzLnByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuZXJhdGVkQ2xhc3NOYW1lID0gdGhpcy5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcyhkZXRlcm1pbmVUaGVtZSh0aGlzLnByb3BzLCB0aGVtZSwgZGVmYXVsdFByb3BzKSB8fCBFTVBUWV9PQkpFQ1QsIHRoaXMucHJvcHMpO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50VG9CZUNyZWF0ZWQgPSB0aGlzLnByb3BzLmFzIHx8IHRoaXMuYXR0cnMuYXMgfHwgdGFyZ2V0O1xuICAgIHZhciBpc1RhcmdldFRhZyA9IGlzVGFnKGVsZW1lbnRUb0JlQ3JlYXRlZCk7XG5cbiAgICB2YXIgcHJvcHNGb3JFbGVtZW50ID0ge307XG4gICAgdmFyIGNvbXB1dGVkUHJvcHMgPSBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywgdGhpcy5hdHRycyk7XG5cbiAgICB2YXIga2V5ID0gdm9pZCAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgICBmb3IgKGtleSBpbiBjb21wdXRlZFByb3BzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBrZXkgPT09ICdpbm5lclJlZicgJiYgaXNUYXJnZXRUYWcpIHtcbiAgICAgICAgdGhpcy53YXJuSW5uZXJSZWYoZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ID09PSAnZm9yd2FyZGVkQ29tcG9uZW50JyB8fCBrZXkgPT09ICdhcycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2ZvcndhcmRlZFJlZicpIHByb3BzRm9yRWxlbWVudC5yZWYgPSBjb21wdXRlZFByb3BzW2tleV07ZWxzZSBpZiAoa2V5ID09PSAnZm9yd2FyZGVkQXMnKSBwcm9wc0ZvckVsZW1lbnQuYXMgPSBjb21wdXRlZFByb3BzW2tleV07ZWxzZSBpZiAoIWlzVGFyZ2V0VGFnIHx8IHZhbGlkQXR0cihrZXkpKSB7XG4gICAgICAgIC8vIERvbid0IHBhc3MgdGhyb3VnaCBub24gSFRNTCB0YWdzIHRocm91Z2ggdG8gSFRNTCBlbGVtZW50c1xuICAgICAgICBwcm9wc0ZvckVsZW1lbnRba2V5XSA9IGNvbXB1dGVkUHJvcHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wcy5zdHlsZSAmJiB0aGlzLmF0dHJzLnN0eWxlKSB7XG4gICAgICBwcm9wc0ZvckVsZW1lbnQuc3R5bGUgPSBfZXh0ZW5kcyh7fSwgdGhpcy5hdHRycy5zdHlsZSwgdGhpcy5wcm9wcy5zdHlsZSk7XG4gICAgfVxuXG4gICAgcHJvcHNGb3JFbGVtZW50LmNsYXNzTmFtZSA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQoZm9sZGVkQ29tcG9uZW50SWRzLCBzdHlsZWRDb21wb25lbnRJZCwgZ2VuZXJhdGVkQ2xhc3NOYW1lICE9PSBzdHlsZWRDb21wb25lbnRJZCA/IGdlbmVyYXRlZENsYXNzTmFtZSA6IG51bGwsIHRoaXMucHJvcHMuY2xhc3NOYW1lLCB0aGlzLmF0dHJzLmNsYXNzTmFtZSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKTtcblxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KGVsZW1lbnRUb0JlQ3JlYXRlZCwgcHJvcHNGb3JFbGVtZW50KTtcbiAgfTtcblxuICBTdHlsZWRDb21wb25lbnQucHJvdG90eXBlLmJ1aWxkRXhlY3V0aW9uQ29udGV4dCA9IGZ1bmN0aW9uIGJ1aWxkRXhlY3V0aW9uQ29udGV4dCh0aGVtZSwgcHJvcHMsIGF0dHJzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgY29udGV4dCA9IF9leHRlbmRzKHt9LCBwcm9wcywgeyB0aGVtZTogdGhlbWUgfSk7XG5cbiAgICBpZiAoIWF0dHJzLmxlbmd0aCkgcmV0dXJuIGNvbnRleHQ7XG5cbiAgICB0aGlzLmF0dHJzID0ge307XG5cbiAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyRGVmKSB7XG4gICAgICB2YXIgcmVzb2x2ZWRBdHRyRGVmID0gYXR0ckRlZjtcbiAgICAgIHZhciBhdHRyRGVmV2FzRm4gPSBmYWxzZTtcbiAgICAgIHZhciBhdHRyID0gdm9pZCAwO1xuICAgICAgdmFyIGtleSA9IHZvaWQgMDtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24ocmVzb2x2ZWRBdHRyRGVmKSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIHJlc29sdmVkQXR0ckRlZiA9IHJlc29sdmVkQXR0ckRlZihjb250ZXh0KTtcbiAgICAgICAgYXR0ckRlZldhc0ZuID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBmb3IgKGtleSBpbiByZXNvbHZlZEF0dHJEZWYpIHtcbiAgICAgICAgYXR0ciA9IHJlc29sdmVkQXR0ckRlZltrZXldO1xuXG4gICAgICAgIGlmICghYXR0ckRlZldhc0ZuKSB7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24oYXR0cikgJiYgIWlzRGVyaXZlZFJlYWN0Q29tcG9uZW50KGF0dHIpICYmICFpc1N0eWxlZENvbXBvbmVudChhdHRyKSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLndhcm5BdHRyc0ZuT2JqZWN0S2V5RGVwcmVjYXRlZChrZXksIHByb3BzLmZvcndhcmRlZENvbXBvbmVudC5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF0dHIgPSBhdHRyKGNvbnRleHQpO1xuXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBSZWFjdC5pc1ZhbGlkRWxlbWVudChhdHRyKSkge1xuICAgICAgICAgICAgICBfdGhpczIud2Fybk5vblN0eWxlZENvbXBvbmVudEF0dHJzT2JqZWN0S2V5KGtleSwgcHJvcHMuZm9yd2FyZGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczIuYXR0cnNba2V5XSA9IGF0dHI7XG4gICAgICAgIGNvbnRleHRba2V5XSA9IGF0dHI7XG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfTtcblxuICBTdHlsZWRDb21wb25lbnQucHJvdG90eXBlLmdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzID0gZnVuY3Rpb24gZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXModGhlbWUsIHByb3BzKSB7XG4gICAgdmFyIF9wcm9wcyRmb3J3YXJkZWRDb21wbzIgPSBwcm9wcy5mb3J3YXJkZWRDb21wb25lbnQsXG4gICAgICAgIGF0dHJzID0gX3Byb3BzJGZvcndhcmRlZENvbXBvMi5hdHRycyxcbiAgICAgICAgY29tcG9uZW50U3R5bGUgPSBfcHJvcHMkZm9yd2FyZGVkQ29tcG8yLmNvbXBvbmVudFN0eWxlLFxuICAgICAgICB3YXJuVG9vTWFueUNsYXNzZXMgPSBfcHJvcHMkZm9yd2FyZGVkQ29tcG8yLndhcm5Ub29NYW55Q2xhc3NlcztcblxuICAgIC8vIHN0YXRpY2FsbHkgc3R5bGVkLWNvbXBvbmVudHMgZG9uJ3QgbmVlZCB0byBidWlsZCBhbiBleGVjdXRpb24gY29udGV4dCBvYmplY3QsXG4gICAgLy8gYW5kIHNob3VsZG4ndCBiZSBpbmNyZWFzaW5nIHRoZSBudW1iZXIgb2YgY2xhc3MgbmFtZXNcblxuICAgIGlmIChjb21wb25lbnRTdHlsZS5pc1N0YXRpYyAmJiAhYXR0cnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50U3R5bGUuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMoRU1QVFlfT0JKRUNULCB0aGlzLnN0eWxlU2hlZXQpO1xuICAgIH1cblxuICAgIHZhciBjbGFzc05hbWUgPSBjb21wb25lbnRTdHlsZS5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcyh0aGlzLmJ1aWxkRXhlY3V0aW9uQ29udGV4dCh0aGVtZSwgcHJvcHMsIGF0dHJzKSwgdGhpcy5zdHlsZVNoZWV0KTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5Ub29NYW55Q2xhc3Nlcykgd2FyblRvb01hbnlDbGFzc2VzKGNsYXNzTmFtZSk7XG5cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9O1xuXG4gIHJldHVybiBTdHlsZWRDb21wb25lbnQ7XG59KENvbXBvbmVudCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlZENvbXBvbmVudCh0YXJnZXQsIG9wdGlvbnMsIHJ1bGVzKSB7XG4gIHZhciBpc1RhcmdldFN0eWxlZENvbXAgPSBpc1N0eWxlZENvbXBvbmVudCh0YXJnZXQpO1xuICB2YXIgaXNDbGFzcyA9ICFpc1RhZyh0YXJnZXQpO1xuXG4gIHZhciBfb3B0aW9ucyRkaXNwbGF5TmFtZSA9IG9wdGlvbnMuZGlzcGxheU5hbWUsXG4gICAgICBkaXNwbGF5TmFtZSA9IF9vcHRpb25zJGRpc3BsYXlOYW1lID09PSB1bmRlZmluZWQgPyBnZW5lcmF0ZURpc3BsYXlOYW1lKHRhcmdldCkgOiBfb3B0aW9ucyRkaXNwbGF5TmFtZSxcbiAgICAgIF9vcHRpb25zJGNvbXBvbmVudElkID0gb3B0aW9ucy5jb21wb25lbnRJZCxcbiAgICAgIGNvbXBvbmVudElkID0gX29wdGlvbnMkY29tcG9uZW50SWQgPT09IHVuZGVmaW5lZCA/IGdlbmVyYXRlSWQoQ29tcG9uZW50U3R5bGUsIG9wdGlvbnMuZGlzcGxheU5hbWUsIG9wdGlvbnMucGFyZW50Q29tcG9uZW50SWQpIDogX29wdGlvbnMkY29tcG9uZW50SWQsXG4gICAgICBfb3B0aW9ucyRQYXJlbnRDb21wb24gPSBvcHRpb25zLlBhcmVudENvbXBvbmVudCxcbiAgICAgIFBhcmVudENvbXBvbmVudCA9IF9vcHRpb25zJFBhcmVudENvbXBvbiA9PT0gdW5kZWZpbmVkID8gU3R5bGVkQ29tcG9uZW50IDogX29wdGlvbnMkUGFyZW50Q29tcG9uLFxuICAgICAgX29wdGlvbnMkYXR0cnMgPSBvcHRpb25zLmF0dHJzLFxuICAgICAgYXR0cnMgPSBfb3B0aW9ucyRhdHRycyA9PT0gdW5kZWZpbmVkID8gRU1QVFlfQVJSQVkgOiBfb3B0aW9ucyRhdHRycztcblxuXG4gIHZhciBzdHlsZWRDb21wb25lbnRJZCA9IG9wdGlvbnMuZGlzcGxheU5hbWUgJiYgb3B0aW9ucy5jb21wb25lbnRJZCA/IGVzY2FwZShvcHRpb25zLmRpc3BsYXlOYW1lKSArICctJyArIG9wdGlvbnMuY29tcG9uZW50SWQgOiBvcHRpb25zLmNvbXBvbmVudElkIHx8IGNvbXBvbmVudElkO1xuXG4gIC8vIGZvbGQgdGhlIHVuZGVybHlpbmcgU3R5bGVkQ29tcG9uZW50IGF0dHJzIHVwIChpbXBsaWNpdCBleHRlbmQpXG4gIHZhciBmaW5hbEF0dHJzID1cbiAgLy8gJEZsb3dGaXhNZVxuICBpc1RhcmdldFN0eWxlZENvbXAgJiYgdGFyZ2V0LmF0dHJzID8gQXJyYXkucHJvdG90eXBlLmNvbmNhdCh0YXJnZXQuYXR0cnMsIGF0dHJzKS5maWx0ZXIoQm9vbGVhbikgOiBhdHRycztcblxuICB2YXIgY29tcG9uZW50U3R5bGUgPSBuZXcgQ29tcG9uZW50U3R5bGUoaXNUYXJnZXRTdHlsZWRDb21wID8gLy8gZm9sZCB0aGUgdW5kZXJseWluZyBTdHlsZWRDb21wb25lbnQgcnVsZXMgdXAgKGltcGxpY2l0IGV4dGVuZClcbiAgLy8gJEZsb3dGaXhNZVxuICB0YXJnZXQuY29tcG9uZW50U3R5bGUucnVsZXMuY29uY2F0KHJ1bGVzKSA6IHJ1bGVzLCBmaW5hbEF0dHJzLCBzdHlsZWRDb21wb25lbnRJZCk7XG5cbiAgLyoqXG4gICAqIGZvcndhcmRSZWYgY3JlYXRlcyBhIG5ldyBpbnRlcmltIGNvbXBvbmVudCwgd2hpY2ggd2UnbGwgdGFrZSBhZHZhbnRhZ2Ugb2ZcbiAgICogaW5zdGVhZCBvZiBleHRlbmRpbmcgUGFyZW50Q29tcG9uZW50IHRvIGNyZWF0ZSBfYW5vdGhlcl8gaW50ZXJpbSBjbGFzc1xuICAgKi9cbiAgdmFyIFdyYXBwZWRTdHlsZWRDb21wb25lbnQgPSB2b2lkIDA7XG4gIHZhciBmb3J3YXJkUmVmID0gZnVuY3Rpb24gZm9yd2FyZFJlZihwcm9wcywgcmVmKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFyZW50Q29tcG9uZW50LCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgZm9yd2FyZGVkQ29tcG9uZW50OiBXcmFwcGVkU3R5bGVkQ29tcG9uZW50LCBmb3J3YXJkZWRSZWY6IHJlZiB9KSk7XG4gIH07XG4gIGZvcndhcmRSZWYuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgV3JhcHBlZFN0eWxlZENvbXBvbmVudCA9IFJlYWN0LmZvcndhcmRSZWYoZm9yd2FyZFJlZik7XG4gIFdyYXBwZWRTdHlsZWRDb21wb25lbnQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcblxuICAvLyAkRmxvd0ZpeE1lXG4gIFdyYXBwZWRTdHlsZWRDb21wb25lbnQuYXR0cnMgPSBmaW5hbEF0dHJzO1xuICAvLyAkRmxvd0ZpeE1lXG4gIFdyYXBwZWRTdHlsZWRDb21wb25lbnQuY29tcG9uZW50U3R5bGUgPSBjb21wb25lbnRTdHlsZTtcblxuICAvLyAkRmxvd0ZpeE1lXG4gIFdyYXBwZWRTdHlsZWRDb21wb25lbnQuZm9sZGVkQ29tcG9uZW50SWRzID0gaXNUYXJnZXRTdHlsZWRDb21wID8gLy8gJEZsb3dGaXhNZVxuICBBcnJheS5wcm90b3R5cGUuY29uY2F0KHRhcmdldC5mb2xkZWRDb21wb25lbnRJZHMsIHRhcmdldC5zdHlsZWRDb21wb25lbnRJZCkgOiBFTVBUWV9BUlJBWTtcblxuICAvLyAkRmxvd0ZpeE1lXG4gIFdyYXBwZWRTdHlsZWRDb21wb25lbnQuc3R5bGVkQ29tcG9uZW50SWQgPSBzdHlsZWRDb21wb25lbnRJZDtcblxuICAvLyBmb2xkIHRoZSB1bmRlcmx5aW5nIFN0eWxlZENvbXBvbmVudCB0YXJnZXQgdXAgc2luY2Ugd2UgZm9sZGVkIHRoZSBzdHlsZXNcbiAgLy8gJEZsb3dGaXhNZVxuICBXcmFwcGVkU3R5bGVkQ29tcG9uZW50LnRhcmdldCA9IGlzVGFyZ2V0U3R5bGVkQ29tcCA/IHRhcmdldC50YXJnZXQgOiB0YXJnZXQ7XG5cbiAgLy8gJEZsb3dGaXhNZVxuICBXcmFwcGVkU3R5bGVkQ29tcG9uZW50LndpdGhDb21wb25lbnQgPSBmdW5jdGlvbiB3aXRoQ29tcG9uZW50KHRhZykge1xuICAgIHZhciBwcmV2aW91c0NvbXBvbmVudElkID0gb3B0aW9ucy5jb21wb25lbnRJZCxcbiAgICAgICAgb3B0aW9uc1RvQ29weSA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9wdGlvbnMsIFsnY29tcG9uZW50SWQnXSk7XG5cblxuICAgIHZhciBuZXdDb21wb25lbnRJZCA9IHByZXZpb3VzQ29tcG9uZW50SWQgJiYgcHJldmlvdXNDb21wb25lbnRJZCArICctJyArIChpc1RhZyh0YWcpID8gdGFnIDogZXNjYXBlKGdldENvbXBvbmVudE5hbWUodGFnKSkpO1xuXG4gICAgdmFyIG5ld09wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9uc1RvQ29weSwge1xuICAgICAgYXR0cnM6IGZpbmFsQXR0cnMsXG4gICAgICBjb21wb25lbnRJZDogbmV3Q29tcG9uZW50SWQsXG4gICAgICBQYXJlbnRDb21wb25lbnQ6IFBhcmVudENvbXBvbmVudFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNyZWF0ZVN0eWxlZENvbXBvbmVudCh0YWcsIG5ld09wdGlvbnMsIHJ1bGVzKTtcbiAgfTtcblxuICAvLyAkRmxvd0ZpeE1lXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVkU3R5bGVkQ29tcG9uZW50LCAnZGVmYXVsdFByb3BzJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZvbGRlZERlZmF1bHRQcm9wcztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKG9iaikge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgdGhpcy5fZm9sZGVkRGVmYXVsdFByb3BzID0gaXNUYXJnZXRTdHlsZWRDb21wID8gbWVyZ2UodGFyZ2V0LmRlZmF1bHRQcm9wcywgb2JqKSA6IG9iajtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIFdyYXBwZWRTdHlsZWRDb21wb25lbnQud2FyblRvb01hbnlDbGFzc2VzID0gY3JlYXRlV2FyblRvb01hbnlDbGFzc2VzKGRpc3BsYXlOYW1lKTtcbiAgfVxuXG4gIC8vICRGbG93Rml4TWVcbiAgV3JhcHBlZFN0eWxlZENvbXBvbmVudC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJy4nICsgV3JhcHBlZFN0eWxlZENvbXBvbmVudC5zdHlsZWRDb21wb25lbnRJZDtcbiAgfTtcblxuICBpZiAoaXNDbGFzcykge1xuICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKFdyYXBwZWRTdHlsZWRDb21wb25lbnQsIHRhcmdldCwge1xuICAgICAgLy8gYWxsIFNDLXNwZWNpZmljIHRoaW5ncyBzaG91bGQgbm90IGJlIGhvaXN0ZWRcbiAgICAgIGF0dHJzOiB0cnVlLFxuICAgICAgY29tcG9uZW50U3R5bGU6IHRydWUsXG4gICAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICAgIGZvbGRlZENvbXBvbmVudElkczogdHJ1ZSxcbiAgICAgIHN0eWxlZENvbXBvbmVudElkOiB0cnVlLFxuICAgICAgdGFyZ2V0OiB0cnVlLFxuICAgICAgd2l0aENvbXBvbmVudDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIFdyYXBwZWRTdHlsZWRDb21wb25lbnQ7XG59XG5cbi8vIFxuLy8gVGhhbmtzIHRvIFJlYWN0RE9NRmFjdG9yaWVzIGZvciB0aGlzIGhhbmR5IGxpc3QhXG5cbnZhciBkb21FbGVtZW50cyA9IFsnYScsICdhYmJyJywgJ2FkZHJlc3MnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2F1ZGlvJywgJ2InLCAnYmFzZScsICdiZGknLCAnYmRvJywgJ2JpZycsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhbnZhcycsICdjYXB0aW9uJywgJ2NpdGUnLCAnY29kZScsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGF0YScsICdkYXRhbGlzdCcsICdkZCcsICdkZWwnLCAnZGV0YWlscycsICdkZm4nLCAnZGlhbG9nJywgJ2RpdicsICdkbCcsICdkdCcsICdlbScsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaW5zJywgJ2tiZCcsICdrZXlnZW4nLCAnbGFiZWwnLCAnbGVnZW5kJywgJ2xpJywgJ2xpbmsnLCAnbWFpbicsICdtYXAnLCAnbWFyaycsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICdtZXRlcicsICduYXYnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ29wdGdyb3VwJywgJ29wdGlvbicsICdvdXRwdXQnLCAncCcsICdwYXJhbScsICdwaWN0dXJlJywgJ3ByZScsICdwcm9ncmVzcycsICdxJywgJ3JwJywgJ3J0JywgJ3J1YnknLCAncycsICdzYW1wJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzbWFsbCcsICdzb3VyY2UnLCAnc3BhbicsICdzdHJvbmcnLCAnc3R5bGUnLCAnc3ViJywgJ3N1bW1hcnknLCAnc3VwJywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpbWUnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndScsICd1bCcsICd2YXInLCAndmlkZW8nLCAnd2JyJyxcblxuLy8gU1ZHXG4nY2lyY2xlJywgJ2NsaXBQYXRoJywgJ2RlZnMnLCAnZWxsaXBzZScsICdmb3JlaWduT2JqZWN0JywgJ2cnLCAnaW1hZ2UnLCAnbGluZScsICdsaW5lYXJHcmFkaWVudCcsICdtYXJrZXInLCAnbWFzaycsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxHcmFkaWVudCcsICdyZWN0JywgJ3N0b3AnLCAnc3ZnJywgJ3RleHQnLCAndHNwYW4nXTtcblxuLy8gXG5cbnZhciBzdHlsZWQgPSBmdW5jdGlvbiBzdHlsZWQodGFnKSB7XG4gIHJldHVybiBjb25zdHJ1Y3RXaXRoT3B0aW9ucyhjcmVhdGVTdHlsZWRDb21wb25lbnQsIHRhZyk7XG59O1xuXG4vLyBTaG9ydGhhbmRzIGZvciBhbGwgdmFsaWQgSFRNTCBFbGVtZW50c1xuZG9tRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZG9tRWxlbWVudCkge1xuICBzdHlsZWRbZG9tRWxlbWVudF0gPSBzdHlsZWQoZG9tRWxlbWVudCk7XG59KTtcblxuLy8gXG5cbnZhciBHbG9iYWxTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR2xvYmFsU3R5bGUocnVsZXMsIGNvbXBvbmVudElkKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgR2xvYmFsU3R5bGUpO1xuXG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgIHRoaXMuY29tcG9uZW50SWQgPSBjb21wb25lbnRJZDtcbiAgICB0aGlzLmlzU3RhdGljID0gaXNTdGF0aWNSdWxlcyhydWxlcywgRU1QVFlfQVJSQVkpO1xuXG4gICAgaWYgKCFTdHlsZVNoZWV0Lm1hc3Rlci5oYXNJZChjb21wb25lbnRJZCkpIHtcbiAgICAgIFN0eWxlU2hlZXQubWFzdGVyLmRlZmVycmVkSW5qZWN0KGNvbXBvbmVudElkLCBbXSk7XG4gICAgfVxuICB9XG5cbiAgR2xvYmFsU3R5bGUucHJvdG90eXBlLmNyZWF0ZVN0eWxlcyA9IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlcyhleGVjdXRpb25Db250ZXh0LCBzdHlsZVNoZWV0KSB7XG4gICAgdmFyIGZsYXRDU1MgPSBmbGF0dGVuKHRoaXMucnVsZXMsIGV4ZWN1dGlvbkNvbnRleHQsIHN0eWxlU2hlZXQpO1xuICAgIHZhciBjc3MgPSBzdHJpbmdpZnlSdWxlcyhmbGF0Q1NTLCAnJyk7XG5cbiAgICBzdHlsZVNoZWV0LmluamVjdCh0aGlzLmNvbXBvbmVudElkLCBjc3MpO1xuICB9O1xuXG4gIEdsb2JhbFN0eWxlLnByb3RvdHlwZS5yZW1vdmVTdHlsZXMgPSBmdW5jdGlvbiByZW1vdmVTdHlsZXMoc3R5bGVTaGVldCkge1xuICAgIHZhciBjb21wb25lbnRJZCA9IHRoaXMuY29tcG9uZW50SWQ7XG5cbiAgICBpZiAoc3R5bGVTaGVldC5oYXNJZChjb21wb25lbnRJZCkpIHtcbiAgICAgIHN0eWxlU2hlZXQucmVtb3ZlKGNvbXBvbmVudElkKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVE9ETzogb3ZlcndyaXRlIGluLXBsYWNlIGluc3RlYWQgb2YgcmVtb3ZlK2NyZWF0ZT9cblxuXG4gIEdsb2JhbFN0eWxlLnByb3RvdHlwZS5yZW5kZXJTdHlsZXMgPSBmdW5jdGlvbiByZW5kZXJTdHlsZXMoZXhlY3V0aW9uQ29udGV4dCwgc3R5bGVTaGVldCkge1xuICAgIHRoaXMucmVtb3ZlU3R5bGVzKHN0eWxlU2hlZXQpO1xuICAgIHRoaXMuY3JlYXRlU3R5bGVzKGV4ZWN1dGlvbkNvbnRleHQsIHN0eWxlU2hlZXQpO1xuICB9O1xuXG4gIHJldHVybiBHbG9iYWxTdHlsZTtcbn0oKTtcblxuLy8gXG5cbi8vIHBsYWNlIG91ciBjYWNoZSBpbnRvIHNoYXJlZCBjb250ZXh0IHNvIGl0J2xsIHBlcnNpc3QgYmV0d2VlbiBITVJzXG5pZiAoSVNfQlJPV1NFUikge1xuICB3aW5kb3cuc2NDR1NITVJDYWNoZSA9IHt9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVHbG9iYWxTdHlsZShzdHJpbmdzKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpbnRlcnBvbGF0aW9ucyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBpbnRlcnBvbGF0aW9uc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgcnVsZXMgPSBjc3MuYXBwbHkodW5kZWZpbmVkLCBbc3RyaW5nc10uY29uY2F0KGludGVycG9sYXRpb25zKSk7XG4gIHZhciBpZCA9ICdzYy1nbG9iYWwtJyArIG11cm11cmhhc2goSlNPTi5zdHJpbmdpZnkocnVsZXMpKTtcbiAgdmFyIHN0eWxlID0gbmV3IEdsb2JhbFN0eWxlKHJ1bGVzLCBpZCk7XG5cbiAgdmFyIEdsb2JhbFN0eWxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBpbmhlcml0cyhHbG9iYWxTdHlsZUNvbXBvbmVudCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBHbG9iYWxTdHlsZUNvbXBvbmVudChwcm9wcykge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgR2xvYmFsU3R5bGVDb21wb25lbnQpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICB2YXIgX3RoaXMkY29uc3RydWN0b3IgPSBfdGhpcy5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBnbG9iYWxTdHlsZSA9IF90aGlzJGNvbnN0cnVjdG9yLmdsb2JhbFN0eWxlLFxuICAgICAgICAgIHN0eWxlZENvbXBvbmVudElkID0gX3RoaXMkY29uc3RydWN0b3Iuc3R5bGVkQ29tcG9uZW50SWQ7XG5cblxuICAgICAgaWYgKElTX0JST1dTRVIpIHtcbiAgICAgICAgd2luZG93LnNjQ0dTSE1SQ2FjaGVbc3R5bGVkQ29tcG9uZW50SWRdID0gKHdpbmRvdy5zY0NHU0hNUkNhY2hlW3N0eWxlZENvbXBvbmVudElkXSB8fCAwKSArIDE7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmaXhlcyBITVIgY29tcGF0aWJpbGl0eS4gRG9uJ3QgYXNrIG1lIHdoeSwgYnV0IHRoaXMgY29tYmluYXRpb24gb2ZcbiAgICAgICAqIGNhY2hpbmcgdGhlIGNsb3N1cmUgdmFyaWFibGVzIHZpYSBzdGF0aWNzIGFuZCB0aGVuIHBlcnNpc3RpbmcgdGhlIHN0YXRpY3MgaW5cbiAgICAgICAqIHN0YXRlIHdvcmtzIGFjcm9zcyBITVIgd2hlcmUgbm8gb3RoZXIgY29tYmluYXRpb24gZGlkLiDCr1xcXyjjg4QpXy/Cr1xuICAgICAgICovXG4gICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgZ2xvYmFsU3R5bGU6IGdsb2JhbFN0eWxlLFxuICAgICAgICBzdHlsZWRDb21wb25lbnRJZDogc3R5bGVkQ29tcG9uZW50SWRcbiAgICAgIH07XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgR2xvYmFsU3R5bGVDb21wb25lbnQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICBpZiAod2luZG93LnNjQ0dTSE1SQ2FjaGVbdGhpcy5zdGF0ZS5zdHlsZWRDb21wb25lbnRJZF0pIHtcbiAgICAgICAgd2luZG93LnNjQ0dTSE1SQ2FjaGVbdGhpcy5zdGF0ZS5zdHlsZWRDb21wb25lbnRJZF0gLT0gMTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRGVwZW5kaW5nIG9uIHRoZSBvcmRlciBcInJlbmRlclwiIGlzIGNhbGxlZCB0aGlzIGNhbiBjYXVzZSB0aGUgc3R5bGVzIHRvIGJlIGxvc3RcbiAgICAgICAqIHVudGlsIHRoZSBuZXh0IHJlbmRlciBwYXNzIG9mIHRoZSByZW1haW5pbmcgaW5zdGFuY2UsIHdoaWNoIG1heVxuICAgICAgICogbm90IGJlIGltbWVkaWF0ZS5cbiAgICAgICAqL1xuICAgICAgaWYgKHdpbmRvdy5zY0NHU0hNUkNhY2hlW3RoaXMuc3RhdGUuc3R5bGVkQ29tcG9uZW50SWRdID09PSAwKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuZ2xvYmFsU3R5bGUucmVtb3ZlU3R5bGVzKHRoaXMuc3R5bGVTaGVldCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEdsb2JhbFN0eWxlQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgUmVhY3QuQ2hpbGRyZW4uY291bnQodGhpcy5wcm9wcy5jaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKCdUaGUgZ2xvYmFsIHN0eWxlIGNvbXBvbmVudCAnICsgdGhpcy5zdGF0ZS5zdHlsZWRDb21wb25lbnRJZCArICcgd2FzIGdpdmVuIGNoaWxkIEpTWC4gY3JlYXRlR2xvYmFsU3R5bGUgZG9lcyBub3QgcmVuZGVyIGNoaWxkcmVuLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgU3R5bGVTaGVldENvbnN1bWVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBmdW5jdGlvbiAoc3R5bGVTaGVldCkge1xuICAgICAgICAgIF90aGlzMi5zdHlsZVNoZWV0ID0gc3R5bGVTaGVldCB8fCBTdHlsZVNoZWV0Lm1hc3RlcjtcblxuICAgICAgICAgIHZhciBnbG9iYWxTdHlsZSA9IF90aGlzMi5zdGF0ZS5nbG9iYWxTdHlsZTtcblxuXG4gICAgICAgICAgaWYgKGdsb2JhbFN0eWxlLmlzU3RhdGljKSB7XG4gICAgICAgICAgICBnbG9iYWxTdHlsZS5yZW5kZXJTdHlsZXMoU1RBVElDX0VYRUNVVElPTl9DT05URVhULCBfdGhpczIuc3R5bGVTaGVldCk7XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgVGhlbWVDb25zdW1lcixcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKHRoZW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSBfdGhpczIuY29uc3RydWN0b3IuZGVmYXVsdFByb3BzO1xuXG5cbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IF9leHRlbmRzKHt9LCBfdGhpczIucHJvcHMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGVtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQudGhlbWUgPSBkZXRlcm1pbmVUaGVtZShfdGhpczIucHJvcHMsIHRoZW1lLCBkZWZhdWx0UHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGdsb2JhbFN0eWxlLnJlbmRlclN0eWxlcyhjb250ZXh0LCBfdGhpczIuc3R5bGVTaGVldCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBHbG9iYWxTdHlsZUNvbXBvbmVudDtcbiAgfShSZWFjdC5Db21wb25lbnQpO1xuXG4gIEdsb2JhbFN0eWxlQ29tcG9uZW50Lmdsb2JhbFN0eWxlID0gc3R5bGU7XG4gIEdsb2JhbFN0eWxlQ29tcG9uZW50LnN0eWxlZENvbXBvbmVudElkID0gaWQ7XG5cblxuICByZXR1cm4gR2xvYmFsU3R5bGVDb21wb25lbnQ7XG59XG5cbi8vIFxuXG52YXIgcmVwbGFjZVdoaXRlc3BhY2UgPSBmdW5jdGlvbiByZXBsYWNlV2hpdGVzcGFjZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHN8XFxcXG4vZywgJycpO1xufTtcblxuZnVuY3Rpb24ga2V5ZnJhbWVzKHN0cmluZ3MpIHtcbiAgLyogV2FybmluZyBpZiB5b3UndmUgdXNlZCBrZXlmcmFtZXMgb24gUmVhY3QgTmF0aXZlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oJ2BrZXlmcmFtZXNgIGNhbm5vdCBiZSB1c2VkIG9uIFJlYWN0TmF0aXZlLCBvbmx5IG9uIHRoZSB3ZWIuIFRvIGRvIGFuaW1hdGlvbiBpbiBSZWFjdE5hdGl2ZSBwbGVhc2UgdXNlIEFuaW1hdGVkLicpO1xuICB9XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGludGVycG9sYXRpb25zID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGludGVycG9sYXRpb25zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBydWxlcyA9IGNzcy5hcHBseSh1bmRlZmluZWQsIFtzdHJpbmdzXS5jb25jYXQoaW50ZXJwb2xhdGlvbnMpKTtcblxuICB2YXIgbmFtZSA9IGdlbmVyYXRlQWxwaGFiZXRpY05hbWUobXVybXVyaGFzaChyZXBsYWNlV2hpdGVzcGFjZShKU09OLnN0cmluZ2lmeShydWxlcykpKSk7XG5cbiAgcmV0dXJuIG5ldyBLZXlmcmFtZXMobmFtZSwgc3RyaW5naWZ5UnVsZXMocnVsZXMsIG5hbWUsICdAa2V5ZnJhbWVzJykpO1xufVxuXG4vLyBcblxudmFyIHdpdGhUaGVtZSA9IChmdW5jdGlvbiAoQ29tcG9uZW50JCQxKSB7XG4gIHZhciBXaXRoVGhlbWUgPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBUaGVtZUNvbnN1bWVyLFxuICAgICAgbnVsbCxcbiAgICAgIGZ1bmN0aW9uICh0aGVtZSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSBDb21wb25lbnQkJDEuZGVmYXVsdFByb3BzO1xuXG4gICAgICAgIHZhciB0aGVtZVByb3AgPSBkZXRlcm1pbmVUaGVtZShwcm9wcywgdGhlbWUsIGRlZmF1bHRQcm9wcyk7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhlbWVQcm9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIGNvbnNvbGUud2FybignW3dpdGhUaGVtZV0gWW91IGFyZSBub3QgdXNpbmcgYSBUaGVtZVByb3ZpZGVyIG5vciBwYXNzaW5nIGEgdGhlbWUgcHJvcCBvciBhIHRoZW1lIGluIGRlZmF1bHRQcm9wcyBpbiBjb21wb25lbnQgY2xhc3MgXCInICsgZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQkJDEpICsgJ1wiJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQkJDEsIF9leHRlbmRzKHt9LCBwcm9wcywgeyB0aGVtZTogdGhlbWVQcm9wLCByZWY6IHJlZiB9KSk7XG4gICAgICB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaG9pc3ROb25SZWFjdFN0YXRpY3MoV2l0aFRoZW1lLCBDb21wb25lbnQkJDEpO1xuXG4gIFdpdGhUaGVtZS5kaXNwbGF5TmFtZSA9ICdXaXRoVGhlbWUoJyArIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50JCQxKSArICcpJztcblxuICByZXR1cm4gV2l0aFRoZW1lO1xufSk7XG5cbi8vIFxuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIF9fRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9IQVVOVEVEX0JZX1NQT09LWV9HSE9TVFMgPSB7XG4gIFN0eWxlU2hlZXQ6IFN0eWxlU2hlZXRcbn07XG5cbi8vIFxuXG4vKiBXYXJuaW5nIGlmIHlvdSd2ZSBpbXBvcnRlZCB0aGlzIGZpbGUgb24gUmVhY3QgTmF0aXZlICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLndhcm4oXCJJdCBsb29rcyBsaWtlIHlvdSd2ZSBpbXBvcnRlZCAnc3R5bGVkLWNvbXBvbmVudHMnIG9uIFJlYWN0IE5hdGl2ZS5cXG5cIiArIFwiUGVyaGFwcyB5b3UncmUgbG9va2luZyB0byBpbXBvcnQgJ3N0eWxlZC1jb21wb25lbnRzL25hdGl2ZSc/XFxuXCIgKyAnUmVhZCBtb3JlIGFib3V0IHRoaXMgYXQgaHR0cHM6Ly93d3cuc3R5bGVkLWNvbXBvbmVudHMuY29tL2RvY3MvYmFzaWNzI3JlYWN0LW5hdGl2ZScpO1xufVxuXG4vKiBXYXJuaW5nIGlmIHRoZXJlIGFyZSBzZXZlcmFsIGluc3RhbmNlcyBvZiBzdHlsZWQtY29tcG9uZW50cyAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudCA9PT0gJ3N0cmluZycgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdOb2RlLmpzJykgPT09IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignanNkb20nKSA9PT0gLTEpIHtcbiAgd2luZG93WydfX3N0eWxlZC1jb21wb25lbnRzLWluaXRfXyddID0gd2luZG93WydfX3N0eWxlZC1jb21wb25lbnRzLWluaXRfXyddIHx8IDA7XG5cbiAgaWYgKHdpbmRvd1snX19zdHlsZWQtY29tcG9uZW50cy1pbml0X18nXSA9PT0gMSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKFwiSXQgbG9va3MgbGlrZSB0aGVyZSBhcmUgc2V2ZXJhbCBpbnN0YW5jZXMgb2YgJ3N0eWxlZC1jb21wb25lbnRzJyBpbml0aWFsaXplZCBpbiB0aGlzIGFwcGxpY2F0aW9uLiBcIiArICdUaGlzIG1heSBjYXVzZSBkeW5hbWljIHN0eWxlcyBub3QgcmVuZGVyaW5nIHByb3Blcmx5LCBlcnJvcnMgaGFwcGVuaW5nIGR1cmluZyByZWh5ZHJhdGlvbiBwcm9jZXNzICcgKyAnYW5kIG1ha2VzIHlvdXIgYXBwbGljYXRpb24gYmlnZ2VyIHdpdGhvdXQgYSBnb29kIHJlYXNvbi5cXG5cXG4nICsgJ1NlZSBodHRwczovL3MtYy5zaC8yQkFYemVkIGZvciBtb3JlIGluZm8uJyk7XG4gIH1cblxuICB3aW5kb3dbJ19fc3R5bGVkLWNvbXBvbmVudHMtaW5pdF9fJ10gKz0gMTtcbn1cblxuLy9cblxuZXhwb3J0IGRlZmF1bHQgc3R5bGVkO1xuZXhwb3J0IHsgY3JlYXRlR2xvYmFsU3R5bGUsIGNzcywgaXNTdHlsZWRDb21wb25lbnQsIGtleWZyYW1lcywgU2VydmVyU3R5bGVTaGVldCwgU3R5bGVTaGVldENvbnN1bWVyLCBTdHlsZVNoZWV0Q29udGV4dCwgU3R5bGVTaGVldE1hbmFnZXIsIFRoZW1lQ29uc3VtZXIsIFRoZW1lQ29udGV4dCwgVGhlbWVQcm92aWRlciwgd2l0aFRoZW1lLCBfX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfSEFVTlRFRF9CWV9TUE9PS1lfR0hPU1RTIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZWQtY29tcG9uZW50cy5icm93c2VyLmVzbS5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUdBO0FBQ0E7QUFDQTtBQUNBLGFBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n")},function(module,exports,__webpack_require__){eval("(function (factory) {\n\t true ? (module['exports'] = factory()) :\n\t\tundefined\n}(function () {\n\n\t'use strict'\n\n\treturn function (insertRule) {\n\t\tvar delimiter = '/*|*/'\n\t\tvar needle = delimiter+'}'\n\n\t\tfunction toSheet (block) {\n\t\t\tif (block)\n\t\t\t\ttry {\n\t\t\t\t\tinsertRule(block + '}')\n\t\t\t\t} catch (e) {}\n\t\t}\n\n\t\treturn function ruleSheet (context, content, selectors, parents, line, column, length, ns, depth, at) {\n\t\t\tswitch (context) {\n\t\t\t\t// property\n\t\t\t\tcase 1:\n\t\t\t\t\t// @import\n\t\t\t\t\tif (depth === 0 && content.charCodeAt(0) === 64)\n\t\t\t\t\t\treturn insertRule(content+';'), ''\n\t\t\t\t\tbreak\n\t\t\t\t// selector\n\t\t\t\tcase 2:\n\t\t\t\t\tif (ns === 0)\n\t\t\t\t\t\treturn content + delimiter\n\t\t\t\t\tbreak\n\t\t\t\t// at-rule\n\t\t\t\tcase 3:\n\t\t\t\t\tswitch (ns) {\n\t\t\t\t\t\t// @font-face, @page\n\t\t\t\t\t\tcase 102:\n\t\t\t\t\t\tcase 112:\n\t\t\t\t\t\t\treturn insertRule(selectors[0]+content), ''\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn content + (at === 0 ? delimiter : '')\n\t\t\t\t\t}\n\t\t\t\tcase -2:\n\t\t\t\t\tcontent.split(needle).forEach(toSheet)\n\t\t\t}\n\t\t}\n\t}\n}))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlcml2LXAycC5bbmFtZV0vLi9ub2RlX21vZHVsZXMvc3R5bGlzLXJ1bGUtc2hlZXQvaW5kZXguanM/NGMwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gKG1vZHVsZVsnZXhwb3J0cyddID0gZmFjdG9yeSgpKSA6XG5cdFx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddID8gZGVmaW5lKGZhY3RvcnkoKSkgOlxuXHRcdFx0KHdpbmRvd1snc3R5bGlzUnVsZVNoZWV0J10gPSBmYWN0b3J5KCkpXG59KGZ1bmN0aW9uICgpIHtcblxuXHQndXNlIHN0cmljdCdcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluc2VydFJ1bGUpIHtcblx0XHR2YXIgZGVsaW1pdGVyID0gJy8qfCovJ1xuXHRcdHZhciBuZWVkbGUgPSBkZWxpbWl0ZXIrJ30nXG5cblx0XHRmdW5jdGlvbiB0b1NoZWV0IChibG9jaykge1xuXHRcdFx0aWYgKGJsb2NrKVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGluc2VydFJ1bGUoYmxvY2sgKyAnfScpXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJ1bGVTaGVldCAoY29udGV4dCwgY29udGVudCwgc2VsZWN0b3JzLCBwYXJlbnRzLCBsaW5lLCBjb2x1bW4sIGxlbmd0aCwgbnMsIGRlcHRoLCBhdCkge1xuXHRcdFx0c3dpdGNoIChjb250ZXh0KSB7XG5cdFx0XHRcdC8vIHByb3BlcnR5XG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHQvLyBAaW1wb3J0XG5cdFx0XHRcdFx0aWYgKGRlcHRoID09PSAwICYmIGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gNjQpXG5cdFx0XHRcdFx0XHRyZXR1cm4gaW5zZXJ0UnVsZShjb250ZW50Kyc7JyksICcnXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Ly8gc2VsZWN0b3Jcblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdGlmIChucyA9PT0gMClcblx0XHRcdFx0XHRcdHJldHVybiBjb250ZW50ICsgZGVsaW1pdGVyXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Ly8gYXQtcnVsZVxuXHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0c3dpdGNoIChucykge1xuXHRcdFx0XHRcdFx0Ly8gQGZvbnQtZmFjZSwgQHBhZ2Vcblx0XHRcdFx0XHRcdGNhc2UgMTAyOlxuXHRcdFx0XHRcdFx0Y2FzZSAxMTI6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBpbnNlcnRSdWxlKHNlbGVjdG9yc1swXStjb250ZW50KSwgJydcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBjb250ZW50ICsgKGF0ID09PSAwID8gZGVsaW1pdGVyIDogJycpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIC0yOlxuXHRcdFx0XHRcdGNvbnRlbnQuc3BsaXQobmVlZGxlKS5mb3JFYWNoKHRvU2hlZXQpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KSlcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLFdBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('var unitlessKeys = {\n  animationIterationCount: 1,\n  borderImageOutset: 1,\n  borderImageSlice: 1,\n  borderImageWidth: 1,\n  boxFlex: 1,\n  boxFlexGroup: 1,\n  boxOrdinalGroup: 1,\n  columnCount: 1,\n  columns: 1,\n  flex: 1,\n  flexGrow: 1,\n  flexPositive: 1,\n  flexShrink: 1,\n  flexNegative: 1,\n  flexOrder: 1,\n  gridRow: 1,\n  gridRowEnd: 1,\n  gridRowSpan: 1,\n  gridRowStart: 1,\n  gridColumn: 1,\n  gridColumnEnd: 1,\n  gridColumnSpan: 1,\n  gridColumnStart: 1,\n  msGridRow: 1,\n  msGridRowSpan: 1,\n  msGridColumn: 1,\n  msGridColumnSpan: 1,\n  fontWeight: 1,\n  lineHeight: 1,\n  opacity: 1,\n  order: 1,\n  orphans: 1,\n  tabSize: 1,\n  widows: 1,\n  zIndex: 1,\n  zoom: 1,\n  WebkitLineClamp: 1,\n  // SVG-related properties\n  fillOpacity: 1,\n  floodOpacity: 1,\n  stopOpacity: 1,\n  strokeDasharray: 1,\n  strokeDashoffset: 1,\n  strokeMiterlimit: 1,\n  strokeOpacity: 1,\n  strokeWidth: 1\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (unitlessKeys);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlcml2LXAycC5bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vdW5pdGxlc3MvZGlzdC91bml0bGVzcy5icm93c2VyLmVzbS5qcz8zMDRlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB1bml0bGVzc0tleXMgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiAxLFxuICBib3JkZXJJbWFnZU91dHNldDogMSxcbiAgYm9yZGVySW1hZ2VTbGljZTogMSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogMSxcbiAgYm94RmxleDogMSxcbiAgYm94RmxleEdyb3VwOiAxLFxuICBib3hPcmRpbmFsR3JvdXA6IDEsXG4gIGNvbHVtbkNvdW50OiAxLFxuICBjb2x1bW5zOiAxLFxuICBmbGV4OiAxLFxuICBmbGV4R3JvdzogMSxcbiAgZmxleFBvc2l0aXZlOiAxLFxuICBmbGV4U2hyaW5rOiAxLFxuICBmbGV4TmVnYXRpdmU6IDEsXG4gIGZsZXhPcmRlcjogMSxcbiAgZ3JpZFJvdzogMSxcbiAgZ3JpZFJvd0VuZDogMSxcbiAgZ3JpZFJvd1NwYW46IDEsXG4gIGdyaWRSb3dTdGFydDogMSxcbiAgZ3JpZENvbHVtbjogMSxcbiAgZ3JpZENvbHVtbkVuZDogMSxcbiAgZ3JpZENvbHVtblNwYW46IDEsXG4gIGdyaWRDb2x1bW5TdGFydDogMSxcbiAgbXNHcmlkUm93OiAxLFxuICBtc0dyaWRSb3dTcGFuOiAxLFxuICBtc0dyaWRDb2x1bW46IDEsXG4gIG1zR3JpZENvbHVtblNwYW46IDEsXG4gIGZvbnRXZWlnaHQ6IDEsXG4gIGxpbmVIZWlnaHQ6IDEsXG4gIG9wYWNpdHk6IDEsXG4gIG9yZGVyOiAxLFxuICBvcnBoYW5zOiAxLFxuICB0YWJTaXplOiAxLFxuICB3aWRvd3M6IDEsXG4gIHpJbmRleDogMSxcbiAgem9vbTogMSxcbiAgV2Via2l0TGluZUNsYW1wOiAxLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiAxLFxuICBmbG9vZE9wYWNpdHk6IDEsXG4gIHN0b3BPcGFjaXR5OiAxLFxuICBzdHJva2VEYXNoYXJyYXk6IDEsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IDEsXG4gIHN0cm9rZU1pdGVybGltaXQ6IDEsXG4gIHN0cm9rZU9wYWNpdHk6IDEsXG4gIHN0cm9rZVdpZHRoOiAxXG59O1xuXG5leHBvcnQgZGVmYXVsdCB1bml0bGVzc0tleXM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/styled-components/node_modules/@emotion/memoize/dist/memoize.browser.esm.js\nfunction memoize(fn) {\n  var cache = {};\n  return function (arg) {\n    if (cache[arg] === undefined) cache[arg] = fn(arg);\n    return cache[arg];\n  };\n}\n\n/* harmony default export */ var memoize_browser_esm = (memoize);\n\n// CONCATENATED MODULE: ./node_modules/styled-components/node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js\n\n\nvar reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23\n\nvar index = memoize_browser_esm(function (prop) {\n  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111\n  /* o */\n  && prop.charCodeAt(1) === 110\n  /* n */\n  && prop.charCodeAt(2) < 91;\n}\n/* Z+1 */\n);\n\n/* harmony default export */ var is_prop_valid_browser_esm = __webpack_exports__["a"] = (index);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlcml2LXAycC5bbmFtZV0vLi9ub2RlX21vZHVsZXMvc3R5bGVkLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL0BlbW90aW9uL21lbW9pemUvZGlzdC9tZW1vaXplLmJyb3dzZXIuZXNtLmpzP2RkMjEiLCJ3ZWJwYWNrOi8vZGVyaXYtcDJwLltuYW1lXS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvQGVtb3Rpb24vaXMtcHJvcC12YWxpZC9kaXN0L2lzLXByb3AtdmFsaWQuYnJvd3Nlci5lc20uanM/OTIzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBtZW1vaXplKGZuKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIGlmIChjYWNoZVthcmddID09PSB1bmRlZmluZWQpIGNhY2hlW2FyZ10gPSBmbihhcmcpO1xuICAgIHJldHVybiBjYWNoZVthcmddO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplO1xuIiwiaW1wb3J0IG1lbW9pemUgZnJvbSAnQGVtb3Rpb24vbWVtb2l6ZSc7XG5cbnZhciByZWFjdFByb3BzUmVnZXggPSAvXigoY2hpbGRyZW58ZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUx8a2V5fHJlZnxhdXRvRm9jdXN8ZGVmYXVsdFZhbHVlfGRlZmF1bHRDaGVja2VkfGlubmVySFRNTHxzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmd8c3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nfHZhbHVlTGlua3xhY2NlcHR8YWNjZXB0Q2hhcnNldHxhY2Nlc3NLZXl8YWN0aW9ufGFsbG93fGFsbG93VXNlck1lZGlhfGFsbG93UGF5bWVudFJlcXVlc3R8YWxsb3dGdWxsU2NyZWVufGFsbG93VHJhbnNwYXJlbmN5fGFsdHxhc3luY3xhdXRvQ29tcGxldGV8YXV0b1BsYXl8Y2FwdHVyZXxjZWxsUGFkZGluZ3xjZWxsU3BhY2luZ3xjaGFsbGVuZ2V8Y2hhclNldHxjaGVja2VkfGNpdGV8Y2xhc3NJRHxjbGFzc05hbWV8Y29sc3xjb2xTcGFufGNvbnRlbnR8Y29udGVudEVkaXRhYmxlfGNvbnRleHRNZW51fGNvbnRyb2xzfGNvbnRyb2xzTGlzdHxjb29yZHN8Y3Jvc3NPcmlnaW58ZGF0YXxkYXRlVGltZXxkZWNvZGluZ3xkZWZhdWx0fGRlZmVyfGRpcnxkaXNhYmxlZHxkb3dubG9hZHxkcmFnZ2FibGV8ZW5jVHlwZXxmb3JtfGZvcm1BY3Rpb258Zm9ybUVuY1R5cGV8Zm9ybU1ldGhvZHxmb3JtTm9WYWxpZGF0ZXxmb3JtVGFyZ2V0fGZyYW1lQm9yZGVyfGhlYWRlcnN8aGVpZ2h0fGhpZGRlbnxoaWdofGhyZWZ8aHJlZkxhbmd8aHRtbEZvcnxodHRwRXF1aXZ8aWR8aW5wdXRNb2RlfGludGVncml0eXxpc3xrZXlQYXJhbXN8a2V5VHlwZXxraW5kfGxhYmVsfGxhbmd8bGlzdHxsb2FkaW5nfGxvb3B8bG93fG1hcmdpbkhlaWdodHxtYXJnaW5XaWR0aHxtYXh8bWF4TGVuZ3RofG1lZGlhfG1lZGlhR3JvdXB8bWV0aG9kfG1pbnxtaW5MZW5ndGh8bXVsdGlwbGV8bXV0ZWR8bmFtZXxub25jZXxub1ZhbGlkYXRlfG9wZW58b3B0aW11bXxwYXR0ZXJufHBsYWNlaG9sZGVyfHBsYXlzSW5saW5lfHBvc3RlcnxwcmVsb2FkfHByb2ZpbGV8cmFkaW9Hcm91cHxyZWFkT25seXxyZWZlcnJlclBvbGljeXxyZWx8cmVxdWlyZWR8cmV2ZXJzZWR8cm9sZXxyb3dzfHJvd1NwYW58c2FuZGJveHxzY29wZXxzY29wZWR8c2Nyb2xsaW5nfHNlYW1sZXNzfHNlbGVjdGVkfHNoYXBlfHNpemV8c2l6ZXN8c2xvdHxzcGFufHNwZWxsQ2hlY2t8c3JjfHNyY0RvY3xzcmNMYW5nfHNyY1NldHxzdGFydHxzdGVwfHN0eWxlfHN1bW1hcnl8dGFiSW5kZXh8dGFyZ2V0fHRpdGxlfHR5cGV8dXNlTWFwfHZhbHVlfHdpZHRofHdtb2RlfHdyYXB8YWJvdXR8ZGF0YXR5cGV8aW5saXN0fHByZWZpeHxwcm9wZXJ0eXxyZXNvdXJjZXx0eXBlb2Z8dm9jYWJ8YXV0b0NhcGl0YWxpemV8YXV0b0NvcnJlY3R8YXV0b1NhdmV8Y29sb3J8aXRlbVByb3B8aXRlbVNjb3BlfGl0ZW1UeXBlfGl0ZW1JRHxpdGVtUmVmfG9ufHJlc3VsdHN8c2VjdXJpdHl8dW5zZWxlY3RhYmxlfGFjY2VudEhlaWdodHxhY2N1bXVsYXRlfGFkZGl0aXZlfGFsaWdubWVudEJhc2VsaW5lfGFsbG93UmVvcmRlcnxhbHBoYWJldGljfGFtcGxpdHVkZXxhcmFiaWNGb3JtfGFzY2VudHxhdHRyaWJ1dGVOYW1lfGF0dHJpYnV0ZVR5cGV8YXV0b1JldmVyc2V8YXppbXV0aHxiYXNlRnJlcXVlbmN5fGJhc2VsaW5lU2hpZnR8YmFzZVByb2ZpbGV8YmJveHxiZWdpbnxiaWFzfGJ5fGNhbGNNb2RlfGNhcEhlaWdodHxjbGlwfGNsaXBQYXRoVW5pdHN8Y2xpcFBhdGh8Y2xpcFJ1bGV8Y29sb3JJbnRlcnBvbGF0aW9ufGNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnN8Y29sb3JQcm9maWxlfGNvbG9yUmVuZGVyaW5nfGNvbnRlbnRTY3JpcHRUeXBlfGNvbnRlbnRTdHlsZVR5cGV8Y3Vyc29yfGN4fGN5fGR8ZGVjZWxlcmF0ZXxkZXNjZW50fGRpZmZ1c2VDb25zdGFudHxkaXJlY3Rpb258ZGlzcGxheXxkaXZpc29yfGRvbWluYW50QmFzZWxpbmV8ZHVyfGR4fGR5fGVkZ2VNb2RlfGVsZXZhdGlvbnxlbmFibGVCYWNrZ3JvdW5kfGVuZHxleHBvbmVudHxleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkfGZpbGx8ZmlsbE9wYWNpdHl8ZmlsbFJ1bGV8ZmlsdGVyfGZpbHRlclJlc3xmaWx0ZXJVbml0c3xmbG9vZENvbG9yfGZsb29kT3BhY2l0eXxmb2N1c2FibGV8Zm9udEZhbWlseXxmb250U2l6ZXxmb250U2l6ZUFkanVzdHxmb250U3RyZXRjaHxmb250U3R5bGV8Zm9udFZhcmlhbnR8Zm9udFdlaWdodHxmb3JtYXR8ZnJvbXxmcnxmeHxmeXxnMXxnMnxnbHlwaE5hbWV8Z2x5cGhPcmllbnRhdGlvbkhvcml6b250YWx8Z2x5cGhPcmllbnRhdGlvblZlcnRpY2FsfGdseXBoUmVmfGdyYWRpZW50VHJhbnNmb3JtfGdyYWRpZW50VW5pdHN8aGFuZ2luZ3xob3JpekFkdlh8aG9yaXpPcmlnaW5YfGlkZW9ncmFwaGljfGltYWdlUmVuZGVyaW5nfGlufGluMnxpbnRlcmNlcHR8a3xrMXxrMnxrM3xrNHxrZXJuZWxNYXRyaXh8a2VybmVsVW5pdExlbmd0aHxrZXJuaW5nfGtleVBvaW50c3xrZXlTcGxpbmVzfGtleVRpbWVzfGxlbmd0aEFkanVzdHxsZXR0ZXJTcGFjaW5nfGxpZ2h0aW5nQ29sb3J8bGltaXRpbmdDb25lQW5nbGV8bG9jYWx8bWFya2VyRW5kfG1hcmtlck1pZHxtYXJrZXJTdGFydHxtYXJrZXJIZWlnaHR8bWFya2VyVW5pdHN8bWFya2VyV2lkdGh8bWFza3xtYXNrQ29udGVudFVuaXRzfG1hc2tVbml0c3xtYXRoZW1hdGljYWx8bW9kZXxudW1PY3RhdmVzfG9mZnNldHxvcGFjaXR5fG9wZXJhdG9yfG9yZGVyfG9yaWVudHxvcmllbnRhdGlvbnxvcmlnaW58b3ZlcmZsb3d8b3ZlcmxpbmVQb3NpdGlvbnxvdmVybGluZVRoaWNrbmVzc3xwYW5vc2UxfHBhaW50T3JkZXJ8cGF0aExlbmd0aHxwYXR0ZXJuQ29udGVudFVuaXRzfHBhdHRlcm5UcmFuc2Zvcm18cGF0dGVyblVuaXRzfHBvaW50ZXJFdmVudHN8cG9pbnRzfHBvaW50c0F0WHxwb2ludHNBdFl8cG9pbnRzQXRafHByZXNlcnZlQWxwaGF8cHJlc2VydmVBc3BlY3RSYXRpb3xwcmltaXRpdmVVbml0c3xyfHJhZGl1c3xyZWZYfHJlZll8cmVuZGVyaW5nSW50ZW50fHJlcGVhdENvdW50fHJlcGVhdER1cnxyZXF1aXJlZEV4dGVuc2lvbnN8cmVxdWlyZWRGZWF0dXJlc3xyZXN0YXJ0fHJlc3VsdHxyb3RhdGV8cnh8cnl8c2NhbGV8c2VlZHxzaGFwZVJlbmRlcmluZ3xzbG9wZXxzcGFjaW5nfHNwZWN1bGFyQ29uc3RhbnR8c3BlY3VsYXJFeHBvbmVudHxzcGVlZHxzcHJlYWRNZXRob2R8c3RhcnRPZmZzZXR8c3RkRGV2aWF0aW9ufHN0ZW1ofHN0ZW12fHN0aXRjaFRpbGVzfHN0b3BDb2xvcnxzdG9wT3BhY2l0eXxzdHJpa2V0aHJvdWdoUG9zaXRpb258c3RyaWtldGhyb3VnaFRoaWNrbmVzc3xzdHJpbmd8c3Ryb2tlfHN0cm9rZURhc2hhcnJheXxzdHJva2VEYXNob2Zmc2V0fHN0cm9rZUxpbmVjYXB8c3Ryb2tlTGluZWpvaW58c3Ryb2tlTWl0ZXJsaW1pdHxzdHJva2VPcGFjaXR5fHN0cm9rZVdpZHRofHN1cmZhY2VTY2FsZXxzeXN0ZW1MYW5ndWFnZXx0YWJsZVZhbHVlc3x0YXJnZXRYfHRhcmdldFl8dGV4dEFuY2hvcnx0ZXh0RGVjb3JhdGlvbnx0ZXh0UmVuZGVyaW5nfHRleHRMZW5ndGh8dG98dHJhbnNmb3JtfHUxfHUyfHVuZGVybGluZVBvc2l0aW9ufHVuZGVybGluZVRoaWNrbmVzc3x1bmljb2RlfHVuaWNvZGVCaWRpfHVuaWNvZGVSYW5nZXx1bml0c1BlckVtfHZBbHBoYWJldGljfHZIYW5naW5nfHZJZGVvZ3JhcGhpY3x2TWF0aGVtYXRpY2FsfHZhbHVlc3x2ZWN0b3JFZmZlY3R8dmVyc2lvbnx2ZXJ0QWR2WXx2ZXJ0T3JpZ2luWHx2ZXJ0T3JpZ2luWXx2aWV3Qm94fHZpZXdUYXJnZXR8dmlzaWJpbGl0eXx3aWR0aHN8d29yZFNwYWNpbmd8d3JpdGluZ01vZGV8eHx4SGVpZ2h0fHgxfHgyfHhDaGFubmVsU2VsZWN0b3J8eGxpbmtBY3R1YXRlfHhsaW5rQXJjcm9sZXx4bGlua0hyZWZ8eGxpbmtSb2xlfHhsaW5rU2hvd3x4bGlua1RpdGxlfHhsaW5rVHlwZXx4bWxCYXNlfHhtbG5zfHhtbG5zWGxpbmt8eG1sTGFuZ3x4bWxTcGFjZXx5fHkxfHkyfHlDaGFubmVsU2VsZWN0b3J8enx6b29tQW5kUGFufGZvcnxjbGFzc3xhdXRvZm9jdXMpfCgoW0RkXVtBYV1bVHRdW0FhXXxbQWFdW1JyXVtJaV1bQWFdfHgpLS4qKSkkLzsgLy8gaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81YmZlZTY4YTRjZDdlNjAwOWVmNjFkMjNcblxudmFyIGluZGV4ID0gbWVtb2l6ZShmdW5jdGlvbiAocHJvcCkge1xuICByZXR1cm4gcmVhY3RQcm9wc1JlZ2V4LnRlc3QocHJvcCkgfHwgcHJvcC5jaGFyQ29kZUF0KDApID09PSAxMTFcbiAgLyogbyAqL1xuICAmJiBwcm9wLmNoYXJDb2RlQXQoMSkgPT09IDExMFxuICAvKiBuICovXG4gICYmIHByb3AuY2hhckNvZGVBdCgyKSA8IDkxO1xufVxuLyogWisxICovXG4pO1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// CONCATENATED MODULE: ./node_modules/is-what/dist/index.esm.js\n/**\r\n * Returns the object type of the given payload\r\n *\r\n * @param {*} payload\r\n * @returns {string}\r\n */\r\nfunction getType(payload) {\r\n    return Object.prototype.toString.call(payload).slice(8, -1);\r\n}\r\n/**\r\n * Returns whether the payload is undefined\r\n *\r\n * @param {*} payload\r\n * @returns {payload is undefined}\r\n */\r\nfunction isUndefined(payload) {\r\n    return getType(payload) === 'Undefined';\r\n}\r\n/**\r\n * Returns whether the payload is null\r\n *\r\n * @param {*} payload\r\n * @returns {payload is null}\r\n */\r\nfunction isNull(payload) {\r\n    return getType(payload) === 'Null';\r\n}\r\n/**\r\n * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)\r\n *\r\n * @param {*} payload\r\n * @returns {payload is {[key: string]: any}}\r\n */\r\nfunction isPlainObject(payload) {\r\n    if (getType(payload) !== 'Object')\r\n        return false;\r\n    return (payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype);\r\n}\r\n/**\r\n * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)\r\n *\r\n * @param {*} payload\r\n * @returns {payload is {[key: string]: any}}\r\n */\r\nfunction isObject(payload) {\r\n    return isPlainObject(payload);\r\n}\r\n/**\r\n * Returns whether the payload is an any kind of object (including special classes or objects with different prototypes)\r\n *\r\n * @param {*} payload\r\n * @returns {payload is {[key: string]: any}}\r\n */\r\nfunction isAnyObject(payload) {\r\n    return getType(payload) === 'Object';\r\n}\r\n/**\r\n * Returns whether the payload is an object like a type passed in < >\r\n *\r\n * Usage: isObjectLike<{id: any}>(payload) // will make sure it's an object and has an `id` prop.\r\n *\r\n * @template T this must be passed in < >\r\n * @param {*} payload\r\n * @returns {payload is T}\r\n */\r\nfunction isObjectLike(payload) {\r\n    return isAnyObject(payload);\r\n}\r\n/**\r\n * Returns whether the payload is a function\r\n *\r\n * @param {*} payload\r\n * @returns {payload is Function}\r\n */\r\nfunction isFunction(payload) {\r\n    return getType(payload) === 'Function';\r\n}\r\n/**\r\n * Returns whether the payload is an array\r\n *\r\n * @param {*} payload\r\n * @returns {payload is undefined}\r\n */\r\nfunction isArray(payload) {\r\n    return getType(payload) === 'Array';\r\n}\r\n/**\r\n * Returns whether the payload is a string\r\n *\r\n * @param {*} payload\r\n * @returns {payload is string}\r\n */\r\nfunction isString(payload) {\r\n    return getType(payload) === 'String';\r\n}\r\n/**\r\n * Returns whether the payload is a string, BUT returns false for ''\r\n *\r\n * @param {*} payload\r\n * @returns {payload is string}\r\n */\r\nfunction isFullString(payload) {\r\n    return isString(payload) && payload !== '';\r\n}\r\n/**\r\n * Returns whether the payload is ''\r\n *\r\n * @param {*} payload\r\n * @returns {payload is string}\r\n */\r\nfunction isEmptyString(payload) {\r\n    return payload === '';\r\n}\r\n/**\r\n * Returns whether the payload is a number\r\n *\r\n * This will return false for NaN\r\n *\r\n * @param {*} payload\r\n * @returns {payload is number}\r\n */\r\nfunction isNumber(payload) {\r\n    return (getType(payload) === 'Number' && !isNaN(payload));\r\n}\r\n/**\r\n * Returns whether the payload is a boolean\r\n *\r\n * @param {*} payload\r\n * @returns {payload is boolean}\r\n */\r\nfunction isBoolean(payload) {\r\n    return getType(payload) === 'Boolean';\r\n}\r\n/**\r\n * Returns whether the payload is a regular expression\r\n *\r\n * @param {*} payload\r\n * @returns {payload is RegExp}\r\n */\r\nfunction isRegExp(payload) {\r\n    return getType(payload) === 'RegExp';\r\n}\r\n/**\r\n * Returns whether the payload is a date, and that the date is Valid\r\n *\r\n * @param {*} payload\r\n * @returns {payload is Date}\r\n */\r\nfunction isDate(payload) {\r\n    return (getType(payload) === 'Date' && !isNaN(payload));\r\n}\r\n/**\r\n * Returns whether the payload is a Symbol\r\n *\r\n * @param {*} payload\r\n * @returns {payload is symbol}\r\n */\r\nfunction isSymbol(payload) {\r\n    return (getType(payload) === 'Symbol');\r\n}\r\n/**\r\n * Returns whether the payload is a primitive type (eg. Boolean | Null | Undefined | Number | String | Symbol)\r\n *\r\n * @param {*} payload\r\n * @returns {(payload is boolean | null | undefined | number | string | symbol)}\r\n */\r\nfunction isPrimitive(payload) {\r\n    return (isBoolean(payload) ||\r\n        isNull(payload) ||\r\n        isUndefined(payload) ||\r\n        isNumber(payload) ||\r\n        isString(payload) ||\r\n        isSymbol(payload));\r\n}\r\n/**\r\n * Does a generic check to check that the given payload is of a given type.\r\n * In cases like Number, it will return true for NaN as NaN is a Number (thanks javascript!);\r\n * It will, however, differentiate between object and null\r\n *\r\n * @template T\r\n * @param {*} payload\r\n * @param {T} type\r\n * @throws {TypeError} Will throw type error if type is an invalid type\r\n * @returns {payload is T}\r\n */\r\nfunction isType(payload, type) {\r\n    if (!(type instanceof Function)) {\r\n        throw new TypeError('Type must be a function');\r\n    }\r\n    if (!type.hasOwnProperty('prototype')) {\r\n        throw new TypeError('Type is not a class');\r\n    }\r\n    // Classes usually have names (as functions usually have names)\r\n    var name = type.name;\r\n    return (getType(payload) === name) || Boolean(payload && (payload.constructor === type));\r\n}\n\n\n\n// CONCATENATED MODULE: ./node_modules/merge-anything/dist/index.esm.js\n/* unused harmony export merge */\n/* unused harmony export concatArrays */\n\n\nfunction assignProp(carry, key, newVal, originalObject) {\r\n    var propType = originalObject.propertyIsEnumerable(key)\r\n        ? 'enumerable'\r\n        : 'nonenumerable';\r\n    if (propType === 'enumerable')\r\n        carry[key] = newVal;\r\n    if (propType === 'nonenumerable') {\r\n        Object.defineProperty(carry, key, {\r\n            value: newVal,\r\n            enumerable: false,\r\n            writable: true,\r\n            configurable: true\r\n        });\r\n    }\r\n}\r\nfunction mergeRecursively(origin, newComer, extensions) {\r\n    // work directly on newComer if its not an object\r\n    if (!isPlainObject(newComer)) {\r\n        // extend merge rules\r\n        if (extensions && isArray(extensions)) {\r\n            extensions.forEach(function (extend) {\r\n                newComer = extend(origin, newComer);\r\n            });\r\n        }\r\n        return newComer;\r\n    }\r\n    // define newObject to merge all values upon\r\n    var newObject = {};\r\n    if (isPlainObject(origin)) {\r\n        var props_1 = Object.getOwnPropertyNames(origin);\r\n        var symbols_1 = Object.getOwnPropertySymbols(origin);\r\n        newObject = props_1.concat(symbols_1).reduce(function (carry, key) {\r\n            // @ts-ignore\r\n            var targetVal = origin[key];\r\n            if ((!isSymbol(key) && !Object.getOwnPropertyNames(newComer).includes(key)) ||\r\n                (isSymbol(key) && !Object.getOwnPropertySymbols(newComer).includes(key))) {\r\n                assignProp(carry, key, targetVal, origin);\r\n            }\r\n            return carry;\r\n        }, {});\r\n    }\r\n    var props = Object.getOwnPropertyNames(newComer);\r\n    var symbols = Object.getOwnPropertySymbols(newComer);\r\n    var result = props.concat(symbols).reduce(function (carry, key) {\r\n        // re-define the origin and newComer as targetVal and newVal\r\n        var newVal = newComer[key];\r\n        var targetVal = (isPlainObject(origin))\r\n            // @ts-ignore\r\n            ? origin[key]\r\n            : undefined;\r\n        // extend merge rules\r\n        if (extensions && isArray(extensions)) {\r\n            extensions.forEach(function (extend) {\r\n                newVal = extend(targetVal, newVal);\r\n            });\r\n        }\r\n        // When newVal is an object do the merge recursively\r\n        if (targetVal !== undefined && isPlainObject(newVal)) {\r\n            newVal = mergeRecursively(targetVal, newVal, extensions);\r\n        }\r\n        assignProp(carry, key, newVal, newComer);\r\n        return carry;\r\n    }, newObject);\r\n    return result;\r\n}\r\n/**\r\n * Merge anything recursively.\r\n * Objects get merged, special objects (classes etc.) are re-assigned \"as is\".\r\n * Basic types overwrite objects or other basic types.\r\n *\r\n * @param {(IConfig | any)} origin\r\n * @param {...any[]} newComers\r\n * @returns the result\r\n */\r\nfunction merge(origin) {\r\n    var newComers = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        newComers[_i - 1] = arguments[_i];\r\n    }\r\n    var extensions = null;\r\n    var base = origin;\r\n    if (isPlainObject(origin) && origin.extensions && Object.keys(origin).length === 1) {\r\n        base = {};\r\n        extensions = origin.extensions;\r\n    }\r\n    return newComers.reduce(function (result, newComer) {\r\n        return mergeRecursively(result, newComer, extensions);\r\n    }, base);\r\n}\n\nfunction concatArrays(originVal, newVal) {\r\n    if (isArray(originVal) && isArray(newVal)) {\r\n        // concat logic\r\n        return originVal.concat(newVal);\r\n    }\r\n    return newVal; // always return newVal as fallback!!\r\n}\n\n/* harmony default export */ var index_esm = __webpack_exports__[\"a\"] = (merge);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlcml2LXAycC5bbmFtZV0vLi9ub2RlX21vZHVsZXMvaXMtd2hhdC9kaXN0L2luZGV4LmVzbS5qcz8yYTdiIiwid2VicGFjazovL2Rlcml2LXAycC5bbmFtZV0vLi9ub2RlX21vZHVsZXMvbWVyZ2UtYW55dGhpbmcvZGlzdC9pbmRleC5lc20uanM/MTAyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogUmV0dXJucyB0aGUgb2JqZWN0IHR5cGUgb2YgdGhlIGdpdmVuIHBheWxvYWRcclxuICpcclxuICogQHBhcmFtIHsqfSBwYXlsb2FkXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUeXBlKHBheWxvYWQpIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocGF5bG9hZCkuc2xpY2UoOCwgLTEpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgdW5kZWZpbmVkXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZFxyXG4gKiBAcmV0dXJucyB7cGF5bG9hZCBpcyB1bmRlZmluZWR9XHJcbiAqL1xyXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChwYXlsb2FkKSB7XHJcbiAgICByZXR1cm4gZ2V0VHlwZShwYXlsb2FkKSA9PT0gJ1VuZGVmaW5lZCc7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBudWxsXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZFxyXG4gKiBAcmV0dXJucyB7cGF5bG9hZCBpcyBudWxsfVxyXG4gKi9cclxuZnVuY3Rpb24gaXNOdWxsKHBheWxvYWQpIHtcclxuICAgIHJldHVybiBnZXRUeXBlKHBheWxvYWQpID09PSAnTnVsbCc7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IChleGNsdWRpbmcgc3BlY2lhbCBjbGFzc2VzIG9yIG9iamVjdHMgd2l0aCBvdGhlciBwcm90b3R5cGVzKVxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHBheWxvYWRcclxuICogQHJldHVybnMge3BheWxvYWQgaXMge1trZXk6IHN0cmluZ106IGFueX19XHJcbiAqL1xyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHBheWxvYWQpIHtcclxuICAgIGlmIChnZXRUeXBlKHBheWxvYWQpICE9PSAnT2JqZWN0JylcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gKHBheWxvYWQuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGF5bG9hZCkgPT09IE9iamVjdC5wcm90b3R5cGUpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCAoZXhjbHVkaW5nIHNwZWNpYWwgY2xhc3NlcyBvciBvYmplY3RzIHdpdGggb3RoZXIgcHJvdG90eXBlcylcclxuICpcclxuICogQHBhcmFtIHsqfSBwYXlsb2FkXHJcbiAqIEByZXR1cm5zIHtwYXlsb2FkIGlzIHtba2V5OiBzdHJpbmddOiBhbnl9fVxyXG4gKi9cclxuZnVuY3Rpb24gaXNPYmplY3QocGF5bG9hZCkge1xyXG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QocGF5bG9hZCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBhbnkga2luZCBvZiBvYmplY3QgKGluY2x1ZGluZyBzcGVjaWFsIGNsYXNzZXMgb3Igb2JqZWN0cyB3aXRoIGRpZmZlcmVudCBwcm90b3R5cGVzKVxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHBheWxvYWRcclxuICogQHJldHVybnMge3BheWxvYWQgaXMge1trZXk6IHN0cmluZ106IGFueX19XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0FueU9iamVjdChwYXlsb2FkKSB7XHJcbiAgICByZXR1cm4gZ2V0VHlwZShwYXlsb2FkKSA9PT0gJ09iamVjdCc7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBvYmplY3QgbGlrZSBhIHR5cGUgcGFzc2VkIGluIDwgPlxyXG4gKlxyXG4gKiBVc2FnZTogaXNPYmplY3RMaWtlPHtpZDogYW55fT4ocGF5bG9hZCkgLy8gd2lsbCBtYWtlIHN1cmUgaXQncyBhbiBvYmplY3QgYW5kIGhhcyBhbiBgaWRgIHByb3AuXHJcbiAqXHJcbiAqIEB0ZW1wbGF0ZSBUIHRoaXMgbXVzdCBiZSBwYXNzZWQgaW4gPCA+XHJcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZFxyXG4gKiBAcmV0dXJucyB7cGF5bG9hZCBpcyBUfVxyXG4gKi9cclxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHBheWxvYWQpIHtcclxuICAgIHJldHVybiBpc0FueU9iamVjdChwYXlsb2FkKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGEgZnVuY3Rpb25cclxuICpcclxuICogQHBhcmFtIHsqfSBwYXlsb2FkXHJcbiAqIEByZXR1cm5zIHtwYXlsb2FkIGlzIEZ1bmN0aW9ufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNGdW5jdGlvbihwYXlsb2FkKSB7XHJcbiAgICByZXR1cm4gZ2V0VHlwZShwYXlsb2FkKSA9PT0gJ0Z1bmN0aW9uJztcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGFycmF5XHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZFxyXG4gKiBAcmV0dXJucyB7cGF5bG9hZCBpcyB1bmRlZmluZWR9XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0FycmF5KHBheWxvYWQpIHtcclxuICAgIHJldHVybiBnZXRUeXBlKHBheWxvYWQpID09PSAnQXJyYXknO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYSBzdHJpbmdcclxuICpcclxuICogQHBhcmFtIHsqfSBwYXlsb2FkXHJcbiAqIEByZXR1cm5zIHtwYXlsb2FkIGlzIHN0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIGlzU3RyaW5nKHBheWxvYWQpIHtcclxuICAgIHJldHVybiBnZXRUeXBlKHBheWxvYWQpID09PSAnU3RyaW5nJztcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGEgc3RyaW5nLCBCVVQgcmV0dXJucyBmYWxzZSBmb3IgJydcclxuICpcclxuICogQHBhcmFtIHsqfSBwYXlsb2FkXHJcbiAqIEByZXR1cm5zIHtwYXlsb2FkIGlzIHN0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIGlzRnVsbFN0cmluZyhwYXlsb2FkKSB7XHJcbiAgICByZXR1cm4gaXNTdHJpbmcocGF5bG9hZCkgJiYgcGF5bG9hZCAhPT0gJyc7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyAnJ1xyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHBheWxvYWRcclxuICogQHJldHVybnMge3BheWxvYWQgaXMgc3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gaXNFbXB0eVN0cmluZyhwYXlsb2FkKSB7XHJcbiAgICByZXR1cm4gcGF5bG9hZCA9PT0gJyc7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhIG51bWJlclxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgcmV0dXJuIGZhbHNlIGZvciBOYU5cclxuICpcclxuICogQHBhcmFtIHsqfSBwYXlsb2FkXHJcbiAqIEByZXR1cm5zIHtwYXlsb2FkIGlzIG51bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGlzTnVtYmVyKHBheWxvYWQpIHtcclxuICAgIHJldHVybiAoZ2V0VHlwZShwYXlsb2FkKSA9PT0gJ051bWJlcicgJiYgIWlzTmFOKHBheWxvYWQpKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGEgYm9vbGVhblxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHBheWxvYWRcclxuICogQHJldHVybnMge3BheWxvYWQgaXMgYm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzQm9vbGVhbihwYXlsb2FkKSB7XHJcbiAgICByZXR1cm4gZ2V0VHlwZShwYXlsb2FkKSA9PT0gJ0Jvb2xlYW4nO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYSByZWd1bGFyIGV4cHJlc3Npb25cclxuICpcclxuICogQHBhcmFtIHsqfSBwYXlsb2FkXHJcbiAqIEByZXR1cm5zIHtwYXlsb2FkIGlzIFJlZ0V4cH1cclxuICovXHJcbmZ1bmN0aW9uIGlzUmVnRXhwKHBheWxvYWQpIHtcclxuICAgIHJldHVybiBnZXRUeXBlKHBheWxvYWQpID09PSAnUmVnRXhwJztcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGEgZGF0ZSwgYW5kIHRoYXQgdGhlIGRhdGUgaXMgVmFsaWRcclxuICpcclxuICogQHBhcmFtIHsqfSBwYXlsb2FkXHJcbiAqIEByZXR1cm5zIHtwYXlsb2FkIGlzIERhdGV9XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RhdGUocGF5bG9hZCkge1xyXG4gICAgcmV0dXJuIChnZXRUeXBlKHBheWxvYWQpID09PSAnRGF0ZScgJiYgIWlzTmFOKHBheWxvYWQpKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGEgU3ltYm9sXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZFxyXG4gKiBAcmV0dXJucyB7cGF5bG9hZCBpcyBzeW1ib2x9XHJcbiAqL1xyXG5mdW5jdGlvbiBpc1N5bWJvbChwYXlsb2FkKSB7XHJcbiAgICByZXR1cm4gKGdldFR5cGUocGF5bG9hZCkgPT09ICdTeW1ib2wnKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGEgcHJpbWl0aXZlIHR5cGUgKGVnLiBCb29sZWFuIHwgTnVsbCB8IFVuZGVmaW5lZCB8IE51bWJlciB8IFN0cmluZyB8IFN5bWJvbClcclxuICpcclxuICogQHBhcmFtIHsqfSBwYXlsb2FkXHJcbiAqIEByZXR1cm5zIHsocGF5bG9hZCBpcyBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZCB8IG51bWJlciB8IHN0cmluZyB8IHN5bWJvbCl9XHJcbiAqL1xyXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShwYXlsb2FkKSB7XHJcbiAgICByZXR1cm4gKGlzQm9vbGVhbihwYXlsb2FkKSB8fFxyXG4gICAgICAgIGlzTnVsbChwYXlsb2FkKSB8fFxyXG4gICAgICAgIGlzVW5kZWZpbmVkKHBheWxvYWQpIHx8XHJcbiAgICAgICAgaXNOdW1iZXIocGF5bG9hZCkgfHxcclxuICAgICAgICBpc1N0cmluZyhwYXlsb2FkKSB8fFxyXG4gICAgICAgIGlzU3ltYm9sKHBheWxvYWQpKTtcclxufVxyXG4vKipcclxuICogRG9lcyBhIGdlbmVyaWMgY2hlY2sgdG8gY2hlY2sgdGhhdCB0aGUgZ2l2ZW4gcGF5bG9hZCBpcyBvZiBhIGdpdmVuIHR5cGUuXHJcbiAqIEluIGNhc2VzIGxpa2UgTnVtYmVyLCBpdCB3aWxsIHJldHVybiB0cnVlIGZvciBOYU4gYXMgTmFOIGlzIGEgTnVtYmVyICh0aGFua3MgamF2YXNjcmlwdCEpO1xyXG4gKiBJdCB3aWxsLCBob3dldmVyLCBkaWZmZXJlbnRpYXRlIGJldHdlZW4gb2JqZWN0IGFuZCBudWxsXHJcbiAqXHJcbiAqIEB0ZW1wbGF0ZSBUXHJcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZFxyXG4gKiBAcGFyYW0ge1R9IHR5cGVcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBXaWxsIHRocm93IHR5cGUgZXJyb3IgaWYgdHlwZSBpcyBhbiBpbnZhbGlkIHR5cGVcclxuICogQHJldHVybnMge3BheWxvYWQgaXMgVH1cclxuICovXHJcbmZ1bmN0aW9uIGlzVHlwZShwYXlsb2FkLCB0eXBlKSB7XHJcbiAgICBpZiAoISh0eXBlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHlwZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcclxuICAgIH1cclxuICAgIGlmICghdHlwZS5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUeXBlIGlzIG5vdCBhIGNsYXNzJyk7XHJcbiAgICB9XHJcbiAgICAvLyBDbGFzc2VzIHVzdWFsbHkgaGF2ZSBuYW1lcyAoYXMgZnVuY3Rpb25zIHVzdWFsbHkgaGF2ZSBuYW1lcylcclxuICAgIHZhciBuYW1lID0gdHlwZS5uYW1lO1xyXG4gICAgcmV0dXJuIChnZXRUeXBlKHBheWxvYWQpID09PSBuYW1lKSB8fCBCb29sZWFuKHBheWxvYWQgJiYgKHBheWxvYWQuY29uc3RydWN0b3IgPT09IHR5cGUpKTtcclxufVxuXG5leHBvcnQgeyBnZXRUeXBlLCBpc1VuZGVmaW5lZCwgaXNOdWxsLCBpc1BsYWluT2JqZWN0LCBpc09iamVjdCwgaXNBbnlPYmplY3QsIGlzT2JqZWN0TGlrZSwgaXNGdW5jdGlvbiwgaXNBcnJheSwgaXNTdHJpbmcsIGlzRnVsbFN0cmluZywgaXNFbXB0eVN0cmluZywgaXNOdW1iZXIsIGlzQm9vbGVhbiwgaXNSZWdFeHAsIGlzRGF0ZSwgaXNTeW1ib2wsIGlzUHJpbWl0aXZlLCBpc1R5cGUgfTtcbiIsImltcG9ydCB7IGlzQXJyYXksIGlzUGxhaW5PYmplY3QsIGlzU3ltYm9sIH0gZnJvbSAnaXMtd2hhdCc7XG5cbmZ1bmN0aW9uIGFzc2lnblByb3AoY2FycnksIGtleSwgbmV3VmFsLCBvcmlnaW5hbE9iamVjdCkge1xyXG4gICAgdmFyIHByb3BUeXBlID0gb3JpZ2luYWxPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUoa2V5KVxyXG4gICAgICAgID8gJ2VudW1lcmFibGUnXHJcbiAgICAgICAgOiAnbm9uZW51bWVyYWJsZSc7XHJcbiAgICBpZiAocHJvcFR5cGUgPT09ICdlbnVtZXJhYmxlJylcclxuICAgICAgICBjYXJyeVtrZXldID0gbmV3VmFsO1xyXG4gICAgaWYgKHByb3BUeXBlID09PSAnbm9uZW51bWVyYWJsZScpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FycnksIGtleSwge1xyXG4gICAgICAgICAgICB2YWx1ZTogbmV3VmFsLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1lcmdlUmVjdXJzaXZlbHkob3JpZ2luLCBuZXdDb21lciwgZXh0ZW5zaW9ucykge1xyXG4gICAgLy8gd29yayBkaXJlY3RseSBvbiBuZXdDb21lciBpZiBpdHMgbm90IGFuIG9iamVjdFxyXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KG5ld0NvbWVyKSkge1xyXG4gICAgICAgIC8vIGV4dGVuZCBtZXJnZSBydWxlc1xyXG4gICAgICAgIGlmIChleHRlbnNpb25zICYmIGlzQXJyYXkoZXh0ZW5zaW9ucykpIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChleHRlbmQpIHtcclxuICAgICAgICAgICAgICAgIG5ld0NvbWVyID0gZXh0ZW5kKG9yaWdpbiwgbmV3Q29tZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld0NvbWVyO1xyXG4gICAgfVxyXG4gICAgLy8gZGVmaW5lIG5ld09iamVjdCB0byBtZXJnZSBhbGwgdmFsdWVzIHVwb25cclxuICAgIHZhciBuZXdPYmplY3QgPSB7fTtcclxuICAgIGlmIChpc1BsYWluT2JqZWN0KG9yaWdpbikpIHtcclxuICAgICAgICB2YXIgcHJvcHNfMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9yaWdpbik7XHJcbiAgICAgICAgdmFyIHN5bWJvbHNfMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob3JpZ2luKTtcclxuICAgICAgICBuZXdPYmplY3QgPSBwcm9wc18xLmNvbmNhdChzeW1ib2xzXzEpLnJlZHVjZShmdW5jdGlvbiAoY2FycnksIGtleSkge1xyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRWYWwgPSBvcmlnaW5ba2V5XTtcclxuICAgICAgICAgICAgaWYgKCghaXNTeW1ib2woa2V5KSAmJiAhT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobmV3Q29tZXIpLmluY2x1ZGVzKGtleSkpIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNTeW1ib2woa2V5KSAmJiAhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhuZXdDb21lcikuaW5jbHVkZXMoa2V5KSkpIHtcclxuICAgICAgICAgICAgICAgIGFzc2lnblByb3AoY2FycnksIGtleSwgdGFyZ2V0VmFsLCBvcmlnaW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjYXJyeTtcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICB9XHJcbiAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuZXdDb21lcik7XHJcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobmV3Q29tZXIpO1xyXG4gICAgdmFyIHJlc3VsdCA9IHByb3BzLmNvbmNhdChzeW1ib2xzKS5yZWR1Y2UoZnVuY3Rpb24gKGNhcnJ5LCBrZXkpIHtcclxuICAgICAgICAvLyByZS1kZWZpbmUgdGhlIG9yaWdpbiBhbmQgbmV3Q29tZXIgYXMgdGFyZ2V0VmFsIGFuZCBuZXdWYWxcclxuICAgICAgICB2YXIgbmV3VmFsID0gbmV3Q29tZXJba2V5XTtcclxuICAgICAgICB2YXIgdGFyZ2V0VmFsID0gKGlzUGxhaW5PYmplY3Qob3JpZ2luKSlcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICA/IG9yaWdpbltrZXldXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIC8vIGV4dGVuZCBtZXJnZSBydWxlc1xyXG4gICAgICAgIGlmIChleHRlbnNpb25zICYmIGlzQXJyYXkoZXh0ZW5zaW9ucykpIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChleHRlbmQpIHtcclxuICAgICAgICAgICAgICAgIG5ld1ZhbCA9IGV4dGVuZCh0YXJnZXRWYWwsIG5ld1ZhbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXaGVuIG5ld1ZhbCBpcyBhbiBvYmplY3QgZG8gdGhlIG1lcmdlIHJlY3Vyc2l2ZWx5XHJcbiAgICAgICAgaWYgKHRhcmdldFZhbCAhPT0gdW5kZWZpbmVkICYmIGlzUGxhaW5PYmplY3QobmV3VmFsKSkge1xyXG4gICAgICAgICAgICBuZXdWYWwgPSBtZXJnZVJlY3Vyc2l2ZWx5KHRhcmdldFZhbCwgbmV3VmFsLCBleHRlbnNpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzaWduUHJvcChjYXJyeSwga2V5LCBuZXdWYWwsIG5ld0NvbWVyKTtcclxuICAgICAgICByZXR1cm4gY2Fycnk7XHJcbiAgICB9LCBuZXdPYmplY3QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogTWVyZ2UgYW55dGhpbmcgcmVjdXJzaXZlbHkuXHJcbiAqIE9iamVjdHMgZ2V0IG1lcmdlZCwgc3BlY2lhbCBvYmplY3RzIChjbGFzc2VzIGV0Yy4pIGFyZSByZS1hc3NpZ25lZCBcImFzIGlzXCIuXHJcbiAqIEJhc2ljIHR5cGVzIG92ZXJ3cml0ZSBvYmplY3RzIG9yIG90aGVyIGJhc2ljIHR5cGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0geyhJQ29uZmlnIHwgYW55KX0gb3JpZ2luXHJcbiAqIEBwYXJhbSB7Li4uYW55W119IG5ld0NvbWVyc1xyXG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0XHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZShvcmlnaW4pIHtcclxuICAgIHZhciBuZXdDb21lcnMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgbmV3Q29tZXJzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIGV4dGVuc2lvbnMgPSBudWxsO1xyXG4gICAgdmFyIGJhc2UgPSBvcmlnaW47XHJcbiAgICBpZiAoaXNQbGFpbk9iamVjdChvcmlnaW4pICYmIG9yaWdpbi5leHRlbnNpb25zICYmIE9iamVjdC5rZXlzKG9yaWdpbikubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgYmFzZSA9IHt9O1xyXG4gICAgICAgIGV4dGVuc2lvbnMgPSBvcmlnaW4uZXh0ZW5zaW9ucztcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdDb21lcnMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIG5ld0NvbWVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlUmVjdXJzaXZlbHkocmVzdWx0LCBuZXdDb21lciwgZXh0ZW5zaW9ucyk7XHJcbiAgICB9LCBiYXNlKTtcclxufVxuXG5mdW5jdGlvbiBjb25jYXRBcnJheXMob3JpZ2luVmFsLCBuZXdWYWwpIHtcclxuICAgIGlmIChpc0FycmF5KG9yaWdpblZhbCkgJiYgaXNBcnJheShuZXdWYWwpKSB7XHJcbiAgICAgICAgLy8gY29uY2F0IGxvZ2ljXHJcbiAgICAgICAgcmV0dXJuIG9yaWdpblZhbC5jb25jYXQobmV3VmFsKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdWYWw7IC8vIGFsd2F5cyByZXR1cm4gbmV3VmFsIGFzIGZhbGxiYWNrISFcclxufVxuXG5leHBvcnQgZGVmYXVsdCBtZXJnZTtcbmV4cG9ydCB7IG1lcmdlLCBjb25jYXRBcnJheXMgfTtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JNQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n")},function(module,exports,__webpack_require__){eval("\nvar content = __webpack_require__(10);\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(12)(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlcml2LXAycC5bbmFtZV0vLi9zcmMvc3R5bGVzL2FwcC5zY3NzPzVmNzEiXSwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1yZXNvdXJjZXMtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tNi0zIS4vYXBwLnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1yZXNvdXJjZXMtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tNi0zIS4vYXBwLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtcmVzb3VyY2VzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTYtMyEuL2FwcC5zY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(11)(false);\n// Module\nexports.push([module.i, "html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,input,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}html{height:100%;font-size:10px}body{line-height:1;height:100%}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:\'\';content:none}table{border-collapse:collapse;border-spacing:0}\\n", ""]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXJpdi1wMnAuW25hbWVdLy4vc3JjL3N0eWxlcy9hcHAuc2Nzcz9hOWI4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiaHRtbCxib2R5LGRpdixzcGFuLGFwcGxldCxvYmplY3QsaWZyYW1lLGgxLGgyLGgzLGg0LGg1LGg2LHAsYmxvY2txdW90ZSxwcmUsYSxhYmJyLGFjcm9ueW0sYWRkcmVzcyxiaWcsY2l0ZSxjb2RlLGRlbCxkZm4sZW0saW1nLGlucyxrYmQscSxzLHNhbXAsc21hbGwsc3RyaWtlLHN0cm9uZyxzdWIsc3VwLHR0LHZhcixiLHUsaSxjZW50ZXIsZGwsZHQsZGQsb2wsdWwsbGksZmllbGRzZXQsZm9ybSxsYWJlbCxsZWdlbmQsdGFibGUsY2FwdGlvbix0Ym9keSx0Zm9vdCx0aGVhZCx0cix0aCx0ZCxhcnRpY2xlLGFzaWRlLGNhbnZhcyxkZXRhaWxzLGVtYmVkLGZpZ3VyZSxmaWdjYXB0aW9uLGZvb3RlcixoZWFkZXIsaGdyb3VwLGlucHV0LG1lbnUsbmF2LG91dHB1dCxydWJ5LHNlY3Rpb24sc3VtbWFyeSx0aW1lLG1hcmssYXVkaW8sdmlkZW97bWFyZ2luOjA7cGFkZGluZzowO2JvcmRlcjowO2ZvbnQ6aW5oZXJpdDt2ZXJ0aWNhbC1hbGlnbjpiYXNlbGluZX1hcnRpY2xlLGFzaWRlLGRldGFpbHMsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsbWVudSxuYXYsc2VjdGlvbntkaXNwbGF5OmJsb2NrfWh0bWx7aGVpZ2h0OjEwMCU7Zm9udC1zaXplOjEwcHh9Ym9keXtsaW5lLWhlaWdodDoxO2hlaWdodDoxMDAlfW9sLHVse2xpc3Qtc3R5bGU6bm9uZX1ibG9ja3F1b3RlLHF7cXVvdGVzOm5vbmV9YmxvY2txdW90ZTpiZWZvcmUsYmxvY2txdW90ZTphZnRlcixxOmJlZm9yZSxxOmFmdGVye2NvbnRlbnQ6Jyc7Y29udGVudDpub25lfXRhYmxle2JvcmRlci1jb2xsYXBzZTpjb2xsYXBzZTtib3JkZXItc3BhY2luZzowfVxcblwiLCBcIlwiXSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], "{").concat(content, "}");\n      }\n\n      return content;\n    }).join(\'\');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === \'string\') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \'\']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      // eslint-disable-next-line prefer-destructuring\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = modules[_i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \'\'; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \'function\') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n  }\n\n  return [content].join(\'\\n\');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n  return "/*# ".concat(data, " */");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXJpdi1wMnAuW25hbWVdLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcz8yNGZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwie1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBtb2R1bGVzW19pXTsgLy8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuICAgICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcbiAgICAgIC8vIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cbiAgICAgIC8vIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblxuICAgICAgaWYgKGl0ZW1bMF0gPT0gbnVsbCB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBpZiAobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2UgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCIoXCIuY29uY2F0KGl0ZW1bMl0sIFwiKSBhbmQgKFwiKS5jb25jYXQobWVkaWFRdWVyeSwgXCIpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n')},function(module,exports,__webpack_require__){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === "undefined") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve "head" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }\n                // }\n                if (typeof target === \'function\') {\n                        return target();\n                }\n                if (typeof memo[target] === "undefined") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(13);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== "undefined" && DEBUG) {\n\t\tif (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === "object" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = "head";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = "bottom";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error("Couldn\'t find a style target. This probably means that the value for the \'insertInto\' parameter is invalid.");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === "top") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === "bottom") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === "object" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error("[Style Loader]\\n\\n Invalid value for parameter \'insertAt\' (\'options.insertAt\') found.\\n Must be \'top\', \'bottom\', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement("style");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = "text/css";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement("link");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = "text/css";\n\t}\n\toptions.attrs.rel = "stylesheet";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === \'function\'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don\'t add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === "function" &&\n\t\ttypeof URL.createObjectURL === "function" &&\n\t\ttypeof URL.revokeObjectURL === "function" &&\n\t\ttypeof Blob === "function" &&\n\t\ttypeof btoa === "function"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join(\'\\n\');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? "" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute("media", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn\'t defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";\n\t}\n\n\tvar blob = new Blob([css], { type: "text/css" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXJpdi1wMnAuW25hbWVdLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzPzY4NDQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQsIHBhcmVudCkge1xuICBpZiAocGFyZW50KXtcbiAgICByZXR1cm4gcGFyZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQsIHBhcmVudCk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbWVtb1t0YXJnZXRdXG5cdH07XG59KSgpO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuICAgICAgICBpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlLCB0YXJnZXQpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXG5cdGlmKG9wdGlvbnMuYXR0cnMubm9uY2UgPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBub25jZSA9IGdldE5vbmNlKCk7XG5cdFx0aWYgKG5vbmNlKSB7XG5cdFx0XHRvcHRpb25zLmF0dHJzLm5vbmNlID0gbm9uY2U7XG5cdFx0fVxuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9uY2UoKSB7XG5cdGlmICh0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4gX193ZWJwYWNrX25vbmNlX187XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gdHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nXG5cdFx0ID8gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcykgXG5cdFx0IDogb3B0aW9ucy50cmFuc2Zvcm0uZGVmYXVsdChvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n')},function(module,exports){eval('\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function "fixes" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== "undefined" && window.location;\n\n  if (!location) {\n    throw new Error("fixUrls requires window.location");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== "string") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + "//" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, "/");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word "url" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn\'t a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn\'t a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn\'t a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^"(.*)"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^\'(.*)\'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf("//") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf("/") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with \'/\'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, ""); // Strip leading \'./\'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn "url(" + JSON.stringify(newUrl) + ")";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXJpdi1wMnAuW25hbWVdLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcz9mNmQzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n')},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXJpdi1wMnAuW25hbWVdLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9mMjhjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n")},function(module,exports,__webpack_require__){"use strict";eval('/** @license React v16.12.0\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nObject.defineProperty(exports,"__esModule",{value:!0});\nvar b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?Symbol.for("react.suspense_list"):\n60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.fundamental"):60117,w=b?Symbol.for("react.responder"):60118,x=b?Symbol.for("react.scope"):60119;function y(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function z(a){return y(a)===m}\nexports.typeOf=y;exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;\nexports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===v||a.$$typeof===w||a.$$typeof===x)};exports.isAsyncMode=function(a){return z(a)||y(a)===l};exports.isConcurrentMode=z;exports.isContextConsumer=function(a){return y(a)===k};exports.isContextProvider=function(a){return y(a)===h};\nexports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return y(a)===n};exports.isFragment=function(a){return y(a)===e};exports.isLazy=function(a){return y(a)===t};exports.isMemo=function(a){return y(a)===r};exports.isPortal=function(a){return y(a)===d};exports.isProfiler=function(a){return y(a)===g};exports.isStrictMode=function(a){return y(a)===f};exports.isSuspense=function(a){return y(a)===p};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXJpdi1wMnAuW25hbWVdLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcz9hOTNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTIuMFxuICogcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7XG52YXIgYj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yLGM9Yj9TeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMyxkPWI/U3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTo2MDEwNixlPWI/U3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpOjYwMTA3LGY9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIik6NjAxMDgsZz1iP1N5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTo2MDExNCxoPWI/U3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpOjYwMTA5LGs9Yj9TeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKTo2MDExMCxsPWI/U3ltYm9sLmZvcihcInJlYWN0LmFzeW5jX21vZGVcIik6NjAxMTEsbT1iP1N5bWJvbC5mb3IoXCJyZWFjdC5jb25jdXJyZW50X21vZGVcIik6NjAxMTEsbj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTo2MDExMixwPWI/U3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpOjYwMTEzLHE9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKTpcbjYwMTIwLHI9Yj9TeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKTo2MDExNSx0PWI/U3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik6NjAxMTYsdj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5mdW5kYW1lbnRhbFwiKTo2MDExNyx3PWI/U3ltYm9sLmZvcihcInJlYWN0LnJlc3BvbmRlclwiKTo2MDExOCx4PWI/U3ltYm9sLmZvcihcInJlYWN0LnNjb3BlXCIpOjYwMTE5O2Z1bmN0aW9uIHkoYSl7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSl7dmFyIHU9YS4kJHR5cGVvZjtzd2l0Y2godSl7Y2FzZSBjOnN3aXRjaChhPWEudHlwZSxhKXtjYXNlIGw6Y2FzZSBtOmNhc2UgZTpjYXNlIGc6Y2FzZSBmOmNhc2UgcDpyZXR1cm4gYTtkZWZhdWx0OnN3aXRjaChhPWEmJmEuJCR0eXBlb2YsYSl7Y2FzZSBrOmNhc2UgbjpjYXNlIHQ6Y2FzZSByOmNhc2UgaDpyZXR1cm4gYTtkZWZhdWx0OnJldHVybiB1fX1jYXNlIGQ6cmV0dXJuIHV9fX1mdW5jdGlvbiB6KGEpe3JldHVybiB5KGEpPT09bX1cbmV4cG9ydHMudHlwZU9mPXk7ZXhwb3J0cy5Bc3luY01vZGU9bDtleHBvcnRzLkNvbmN1cnJlbnRNb2RlPW07ZXhwb3J0cy5Db250ZXh0Q29uc3VtZXI9aztleHBvcnRzLkNvbnRleHRQcm92aWRlcj1oO2V4cG9ydHMuRWxlbWVudD1jO2V4cG9ydHMuRm9yd2FyZFJlZj1uO2V4cG9ydHMuRnJhZ21lbnQ9ZTtleHBvcnRzLkxhenk9dDtleHBvcnRzLk1lbW89cjtleHBvcnRzLlBvcnRhbD1kO2V4cG9ydHMuUHJvZmlsZXI9ZztleHBvcnRzLlN0cmljdE1vZGU9ZjtleHBvcnRzLlN1c3BlbnNlPXA7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZT1mdW5jdGlvbihhKXtyZXR1cm5cInN0cmluZ1wiPT09dHlwZW9mIGF8fFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhfHxhPT09ZXx8YT09PW18fGE9PT1nfHxhPT09Znx8YT09PXB8fGE9PT1xfHxcIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiYoYS4kJHR5cGVvZj09PXR8fGEuJCR0eXBlb2Y9PT1yfHxhLiQkdHlwZW9mPT09aHx8YS4kJHR5cGVvZj09PWt8fGEuJCR0eXBlb2Y9PT1ufHxhLiQkdHlwZW9mPT09dnx8YS4kJHR5cGVvZj09PXd8fGEuJCR0eXBlb2Y9PT14KX07ZXhwb3J0cy5pc0FzeW5jTW9kZT1mdW5jdGlvbihhKXtyZXR1cm4geihhKXx8eShhKT09PWx9O2V4cG9ydHMuaXNDb25jdXJyZW50TW9kZT16O2V4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIHkoYSk9PT1rfTtleHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyPWZ1bmN0aW9uKGEpe3JldHVybiB5KGEpPT09aH07XG5leHBvcnRzLmlzRWxlbWVudD1mdW5jdGlvbihhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09Y307ZXhwb3J0cy5pc0ZvcndhcmRSZWY9ZnVuY3Rpb24oYSl7cmV0dXJuIHkoYSk9PT1ufTtleHBvcnRzLmlzRnJhZ21lbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHkoYSk9PT1lfTtleHBvcnRzLmlzTGF6eT1mdW5jdGlvbihhKXtyZXR1cm4geShhKT09PXR9O2V4cG9ydHMuaXNNZW1vPWZ1bmN0aW9uKGEpe3JldHVybiB5KGEpPT09cn07ZXhwb3J0cy5pc1BvcnRhbD1mdW5jdGlvbihhKXtyZXR1cm4geShhKT09PWR9O2V4cG9ydHMuaXNQcm9maWxlcj1mdW5jdGlvbihhKXtyZXR1cm4geShhKT09PWd9O2V4cG9ydHMuaXNTdHJpY3RNb2RlPWZ1bmN0aW9uKGEpe3JldHVybiB5KGEpPT09Zn07ZXhwb3J0cy5pc1N1c3BlbnNlPWZ1bmN0aW9uKGEpe3JldHVybiB5KGEpPT09cH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n')},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE__16__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXJpdi1wMnAuW25hbWVdL2V4dGVybmFsIFwicHJvcC10eXBlc1wiPzM4MzIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xNl9fOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: external "react"\nvar external_react_ = __webpack_require__(0);\nvar external_react_default = /*#__PURE__*/__webpack_require__.n(external_react_);\n\n// EXTERNAL MODULE: ./node_modules/styled-components/dist/styled-components.browser.esm.js\nvar styled_components_browser_esm = __webpack_require__(4);\n\n// EXTERNAL MODULE: ./src/styles/app.scss\nvar app = __webpack_require__(9);\n\n// CONCATENATED MODULE: ./src/components/app.jsx\n\n\n\nvar StyledDiv = styled_components_browser_esm["a" /* default */].div.withConfig({\n  displayName: "app__StyledDiv",\n  componentId: "sc-1vfmp3e-0"\n})(["background:var(--general-section-1);color:var(--text-general);"]);\n\nvar app_App = function App() {\n  return external_react_default.a.createElement(StyledDiv, null, "Hello p2p");\n};\n\n/* harmony default export */ var components_app = (app_App);\n// CONCATENATED MODULE: ./src/components/app.js\n\n/* harmony default export */ var src_components_app = __webpack_exports__["default"] = (components_app);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXJpdi1wMnAuW25hbWVdLy4vc3JjL2NvbXBvbmVudHMvYXBwLmpzeD9hNGJlIiwid2VicGFjazovL2Rlcml2LXAycC5bbmFtZV0vLi9zcmMvY29tcG9uZW50cy9hcHAuanM/NDA3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHN0eWxlZCBmcm9tICdzdHlsZWQtY29tcG9uZW50cyc7XG5pbXBvcnQgJy4uL3N0eWxlcy9hcHAuc2Nzcyc7XG5cbmNvbnN0IFN0eWxlZERpdiA9IHN0eWxlZC5kaXZgXG4gICAgYmFja2dyb3VuZDogdmFyKC0tZ2VuZXJhbC1zZWN0aW9uLTEpO1xuICAgIGNvbG9yOiB2YXIoLS10ZXh0LWdlbmVyYWwpO1xuYDtcblxuY29uc3QgQXBwID0gKCkgPT4gPFN0eWxlZERpdj5IZWxsbyBwMnA8L1N0eWxlZERpdj47XG5cbmV4cG9ydCBkZWZhdWx0IEFwcDtcbiIsImltcG9ydCBQYXltZW50IGZyb20gJy4vYXBwLmpzeCc7XG5cbmV4cG9ydCBkZWZhdWx0IFBheW1lbnQ7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUNYQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17\n')}]).default}));