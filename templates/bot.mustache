<!DOCTYPE html>
<html>

  <head>
    {{> security }} {{> head }}
    <title>Binary Bot</title>
    {{> bundle_css }}
    <link rel="stylesheet" href="https://style.binary.com/binary.css"> {{> bot_css }}
  </head>

  <body>
    <div id="tour"></div>
    <div id="center"></div>
    <span id="limits-dialog"></span>
    <span id="save-dialog"></span>
    <span id="chart-dialog"></span>
    <span id="trading-view-dialog"></span>
    <span id="logPanel" class="draggable-dialog" title="Log">
      <div id="logTable" class="logTable-scroll"></div>
    </span>
    <span id="summaryPanel" class="draggable-dialog">
    </span>


    <div>
      <div class="blocker"></div>
      <div class="reality-check" style="display: none">
        <h1 data-i18n-text="Reality Check"></h1>
        <p data-i18n-text="Options trading can become a real addiction, as can any other activity pushed to its limits. To avoid the danger of such an addiction, we provide a reality-check that gives you a summary of your trades and accounts on a regular basis."></p>
        <p data-i18n-text="Please specify your preferred reality-check interval in minutes">
        <input id="realityDuration" interval="1" maxlength="2" value="10">
        </p>
        <p id="rc-err" style="display: none;" class="error-msg" data-i18n-text="Please enter a number between 10 to 60."></p>
        <div>
          <button bcont="1" class="button" id="continue-trading" data-i18n-text="Continue Trading"></button>
          <a id="statement-reality-check" class="button-secondary" href="#">
            <span data-i18n-text="Statement"></span>
          </a>
          <a id="logout-reality-check" class="button-secondary" href="#">
            <span data-i18n-text="Log out"></span>
          </a>
        </div>
      </div>
    </div>
    {{> loading }}
    <div id="topbar">
      <div class="right-header show-on-load">
        {{> language }}
      </div>
    </div>
    <div id="header">
      <div class="left-header">
        <div class="logo-wrapper">
          <a href="https://www.binary.com" target="blank" id="logo">
            <div class="logo-parent">
              <div class="logo">
                <img class="responsive" src="https://style.binary.com/images/logo/symbol.svg" alt="Binary-logo" />
              </div>
              <div class="binary-logo-text">
                <img class="responsive" src="https://style.binary.com/images/logo/type.svg" alt="Binary-logo">
              </div>
            </div>
          </a>
        </div>
      </div>
      <div class="right-header show-on-load">
        <div class="intro-login-logout">
          <div id="account-list">
            <div id="main-logout">
              <ul id="main-account" class="nav-menu main-nav">
                <li class="account">
                  <a href="javascript:;">
                    <div class="main-account">
                      <div class="account-type"></div>
                      <div class="account-id"></div>
                      <div class="topMenuBalance">&ensp;</div>
                    </div>
                    <div class="nav-caret"></div>
                  </a>
                </li>
              </ul>
              <ul id="all-accounts" class="nav-menu main-nav">
                <li class="account">
                  <a href="javascript:;">
                    <div class="main-account">
                      <div class="account-type"></div>
                      <div class="account-id"></div>
                      <div class="topMenuBalance">&ensp;</div>
                    </div>
                    <div class="nav-caret"></div>
                  </a>
                  <ul>
                    <div class="login-id-list"></div>
                    <a href="javascript:;" id="btn_logout" class="logout">
                      <li id="logout" data-i18n-text="Log out"></li>
                    </a>
                  </ul>
                </li>
              </ul>
            </div>
          </div>
          <button id="login" data-i18n-text="Log in" />
        </div>
      </div>
    </div>
    <div id="blocklyDiv"></div>

    <form id="fileUploadForm" style="display: none;">
      <input title="Open an already saved XML file and retrieve its blocks" type="file" id="files" accept=".xml" multiple/>
    </form>
    <div id="toolbox" class="actions_menu show-on-load">
      <button title="Load new blocks (xml file)" id="loadXml" class="toolbox-button icon-browse"></button>
      <button title="Save the existing blocks (xml file)" id="save-xml" class="toolbox-button icon-save"></button>
      <button title="Undo the changes (Ctrl+Z)" id="undo" class="toolbox-button icon-undo"></button>
      <button title="Redo the changes (Ctrl+Shift+Z)" id="redo" class="toolbox-button icon-redo"></button>
      <button title="Zoom In (Ctrl + +)" id="zoomIn" class="toolbox-button icon-zoom-in"></button>
      <button title="Zoom Out (Ctrl + -)" id="zoomOut" class="toolbox-button icon-zoom-out"></button>
      <button title="Rearrange Vertically" id="rearrange" class="toolbox-button icon-sort"></button>
      <button title="Show/hide the summary pop-up" id="showSummary" class="toolbox-button icon-summary"></button>
      <button title="Reset the blocks to their initial state" id="resetButton" class="toolbox-button icon-reset"></button>
      <button title="Run the bot" id="runButton" class="toolbox-button icon-run"></button>
      <button title="Stop the bot" id="stopButton" class="toolbox-button icon-stop"></button>
      <button title="Show log" id="logButton" class="toolbox-button icon-info"></button>
      <button title="Show chart" id="chartButton" class="toolbox-button icon-chart-line"></button>
      <button title="Show Trading View" id="tradingViewButton" class="toolbox-button icon-trading-view"></button>
    </div>
    <div id="footer"></div>
    <audio id="announcement" src="sound/announcement.ogg" autostart="false" ></audio>
    <audio id="earned-money" src="sound/coins.ogg" autostart="false" ></audio>
    <audio id="job-done" src="sound/job-done.ogg" autostart="false" ></audio>
    <audio id="error" src="sound/out-of-bounds.ogg" autostart="false" ></audio>
    <audio id="severe-error" src="sound/i-am-being-serious.ogg" autostart="false" ></audio>
    {{> bundle}} 
    <script>
        Blockly.FieldDropdown.prototype.render_ = function() {
			  if (!this.visible_) {
			    this.size_.width = 0;
			    return;
			  }
			  if (this.sourceBlock_ && this.arrow_) {
			    // Update arrow's colour.
			    this.arrow_.style.fill = this.sourceBlock_.getColour();
			  }
			  goog.dom.removeChildren((this.textElement_));
			  goog.dom.removeNode(this.imageElement_);
			  this.imageElement_ = null;

			  if (this.imageJson_) {
			    this.renderSelectedImage_();
			  } else {
			    this.renderSelectedText_();
			  }
			  this.borderRect_.setAttribute('height', this.size_.height - 8);
			  this.borderRect_.setAttribute('width',
			      this.size_.width + Blockly.BlockSvg.SEP_SPACE_X);
			};
			Blockly.FieldDropdown.prototype.renderSelectedText_ = function() {
			  // Text option is selected.
			  // Replace the text.
			  var textNode = document.createTextNode(this.getDisplayText_());
			  this.textElement_.appendChild(textNode);
			  // Insert dropdown arrow.
			  if (this.sourceBlock_.RTL) {
			    this.textElement_.insertBefore(this.arrow_, this.textElement_.firstChild);
			  } else {
			    this.textElement_.appendChild(this.arrow_);
			  }
			  this.textElement_.setAttribute('text-anchor', 'start');
			  this.textElement_.setAttribute('x', 0);

			  this.size_.height = 30;
			  this.size_.width = Blockly.Field.getCachedWidth(this.textElement_);
			};

			Blockly.BlockSvg.SEP_SPACE_X = 20;
			Blockly.Field.prototype.init = function() {
			  if (this.fieldGroup_) {
			    // Field has already been initialized once.
			    return;
			  }
			  // Build the DOM.
			  this.fieldGroup_ = Blockly.utils.createSvgElement('g', {}, null);
			  if (!this.visible_) {
			    this.fieldGroup_.style.display = 'none';
			  }
			  this.borderRect_ = Blockly.utils.createSvgElement('rect',
			      {'rx': 4,
			       'ry': 4,
			       'x': -Blockly.BlockSvg.SEP_SPACE_X / 2,
			       'y': 0,
			       'height': 16}, this.fieldGroup_);
			  this.textElement_ = Blockly.utils.createSvgElement('text',
			      {'class': 'blocklyText', 'y': this.size_.height - 10},
			      this.fieldGroup_);

			  this.updateEditable();
			  this.sourceBlock_.getSvgRoot().appendChild(this.fieldGroup_);
			  this.mouseDownWrapper_ =
			      Blockly.bindEventWithChecks_(this.fieldGroup_, 'mousedown', this,
			      this.onMouseDown_);
			  // Force a render.
			  this.render_();
			};
			Blockly.FieldLabel.prototype.init = function() {
			  if (this.textElement_) {
			    // Text has already been initialized once.
			    return;
			  }
			  // Build the DOM.
			  this.textElement_ = Blockly.utils.createSvgElement('text',
			      {'class': 'blocklyText', 'y': this.size_.height - 2}, null);
			  if (this.class_) {
			    Blockly.utils.addClass(this.textElement_, this.class_);
			  }
			  if (!this.visible_) {
			    this.textElement_.style.display = 'none';
			  }
			  this.sourceBlock_.getSvgRoot().appendChild(this.textElement_);

			  // Configure the field to be transparent with respect to tooltips.
			  this.textElement_.tooltip = this.sourceBlock_;
			  Blockly.Tooltip.bindMouseEvents(this.textElement_);
			  // Force a render.
			  this.render_();
			};
Blockly.BlockSvg.prototype.renderCompute_ = function(iconWidth) {
  var inputList = this.inputList;
  var inputRows = [];
  inputRows.rightEdge = iconWidth + Blockly.BlockSvg.SEP_SPACE_X * 2;
  if (this.previousConnection || this.nextConnection) {
    inputRows.rightEdge = Math.max(inputRows.rightEdge,
        Blockly.BlockSvg.NOTCH_WIDTH + Blockly.BlockSvg.SEP_SPACE_X);
  }
  var fieldValueWidth = 0;  // Width of longest external value field.
  var fieldStatementWidth = 0;  // Width of longest statement field.
  var hasValue = false;
  var hasStatement = false;
  var hasDummy = false;
  var lastType = undefined;
  var isInline = this.getInputsInline() && !this.isCollapsed();
  for (var i = 0, input; input = inputList[i]; i++) {
    if (!input.isVisible()) {
      continue;
    }
    var row;
    if (!isInline || !lastType ||
        lastType == Blockly.NEXT_STATEMENT ||
        input.type == Blockly.NEXT_STATEMENT) {
      // Create new row.
      lastType = input.type;
      row = [];
      if (isInline && input.type != Blockly.NEXT_STATEMENT) {
        row.type = Blockly.BlockSvg.INLINE;
      } else {
        row.type = input.type;
      }
      row.height = 0;
      inputRows.push(row);
    } else {
      row = inputRows[inputRows.length - 1];
    }
    row.push(input);

    // Compute minimum input size.
    input.renderHeight = Blockly.BlockSvg.MIN_BLOCK_Y;
    // The width is currently only needed for inline value inputs.
    if (isInline && input.type == Blockly.INPUT_VALUE) {
      input.renderWidth = Blockly.BlockSvg.TAB_WIDTH +
          Blockly.BlockSvg.SEP_SPACE_X * 1.25;
    } else {
      input.renderWidth = 0;
    }
    // Expand input size if there is a connection.
    if (input.connection && input.connection.isConnected()) {
      var linkedBlock = input.connection.targetBlock();
      var bBox = linkedBlock.getHeightWidth();
      input.renderHeight = Math.max(input.renderHeight, bBox.height);
      input.renderWidth = Math.max(input.renderWidth, bBox.width);
    }
    // Blocks have a one pixel shadow that should sometimes overhang.
    if (!isInline && i == inputList.length - 1) {
      // Last value input should overhang.
      input.renderHeight--;
    } else if (!isInline && input.type == Blockly.INPUT_VALUE &&
        inputList[i + 1] && inputList[i + 1].type == Blockly.NEXT_STATEMENT) {
      // Value input above statement input should overhang.
      input.renderHeight--;
    }

    row.height = Math.max(row.height, input.renderHeight);
    input.fieldWidth = 0;
    if (inputRows.length == 1) {
      // The first row gets shifted to accommodate any icons.
      input.fieldWidth += this.RTL ? -iconWidth : iconWidth;
    }
    var previousFieldEditable = false;
    for (var j = 0, field; field = input.fieldRow[j]; j++) {
      if (j != 0) {
        input.fieldWidth += Blockly.BlockSvg.SEP_SPACE_X;
      }
      // Get the dimensions of the field.
      var fieldSize = field.getSize();
      field.renderWidth = fieldSize.width;
      field.renderSep = (previousFieldEditable && field.EDITABLE) ?
          Blockly.BlockSvg.SEP_SPACE_X : 0;
      input.fieldWidth += field.renderWidth + field.renderSep;
      row.height = Math.max(row.height, fieldSize.height)+1 ;
      previousFieldEditable = field.EDITABLE;
    }

    if (row.type != Blockly.BlockSvg.INLINE) {
      if (row.type == Blockly.NEXT_STATEMENT) {
        hasStatement = true;
        fieldStatementWidth = Math.max(fieldStatementWidth, input.fieldWidth);
      } else {
        if (row.type == Blockly.INPUT_VALUE) {
          hasValue = true;
        } else if (row.type == Blockly.DUMMY_INPUT) {
          hasDummy = true;
        }
        fieldValueWidth = Math.max(fieldValueWidth, input.fieldWidth);
      }
    }
  }

  // Make inline rows a bit thicker in order to enclose the values.
  for (var y = 0, row; row = inputRows[y]; y++) {
    row.thicker = false;
    if (row.type == Blockly.BlockSvg.INLINE) {
      for (var z = 0, input; input = row[z]; z++) {
        if (input.type == Blockly.INPUT_VALUE) {
          row.height += 2 * Blockly.BlockSvg.INLINE_PADDING_Y;
          row.thicker = true;
          break;
        }
      }
    }
  }

  // Compute the statement edge.
  // This is the width of a block where statements are nested.
  inputRows.statementEdge = 2 * Blockly.BlockSvg.SEP_SPACE_X +
      fieldStatementWidth;
  // Compute the preferred right edge.  Inline blocks may extend beyond.
  // This is the width of the block where external inputs connect.
  if (hasStatement) {
    inputRows.rightEdge = Math.max(inputRows.rightEdge,
        inputRows.statementEdge + Blockly.BlockSvg.NOTCH_WIDTH);
  }
  if (hasValue) {
    inputRows.rightEdge = Math.max(inputRows.rightEdge, fieldValueWidth +
        Blockly.BlockSvg.SEP_SPACE_X * 2 + Blockly.BlockSvg.TAB_WIDTH);
  } else if (hasDummy) {
    inputRows.rightEdge = Math.max(inputRows.rightEdge, fieldValueWidth +
        Blockly.BlockSvg.SEP_SPACE_X * 2);
  }

  inputRows.hasValue = hasValue;
  inputRows.hasStatement = hasStatement;
  inputRows.hasDummy = hasDummy;
  return inputRows;
};

    </script>
    {{> bot}}
  </body>
</html>
